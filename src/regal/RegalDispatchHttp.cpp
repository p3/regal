/* NOTE: Do not edit this file, it is generated by a script:
   Export.py --api gl 4.4 --api wgl 4.4 --api glx 4.4 --api cgl 1.4 --api egl 1.0 --outdir .
*/

/*
  Copyright (c) 2011-2014 NVIDIA Corporation
  Copyright (c) 2012-2014 Scott Nations
  Copyright (c) 2012-2014 Nigel Stewart
  Copyright (c) 2011-2013 Cass Everitt
  Copyright (c) 2012 Mathias Schott
  Copyright (c) 2012-2013 Google Inc.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
  Intended formatting conventions:
  $ astyle --style=allman --indent=spaces=2 --indent-switches
*/

#include "pch.h" /* For MS precompiled header support */

#include "RegalUtil.h"

#if REGAL_HTTP

REGAL_GLOBAL_BEGIN

#include "RegalLog.h"
#include "RegalHttp.h"
#include "RegalPush.h"
#include "RegalToken.h"
#include "RegalHelper.h"
#include "RegalContext.h"
#include "RegalDispatch.h"
#include "RegalDispatcherGL.h"
#include "RegalDispatcherGlobal.h"

using namespace ::REGAL_NAMESPACE_INTERNAL::Logging;
using namespace ::REGAL_NAMESPACE_INTERNAL::Token;

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

// GL_VERSION_1_0

static void REGAL_CALL http_glAccum(GLenum op, GLfloat value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glAccum)(op, value);
#endif
}

static void REGAL_CALL http_glAlphaFunc(GLenum func, GLclampf ref)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glAlphaFunc)(func, ref);
#endif
}

static void REGAL_CALL http_glBegin(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      _context->http.inBeginEnd++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBegin)(mode);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glBitmap(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBitmap)(width, height, xorig, yorig, xmove, ymove, bitmap);
#endif
}

static void REGAL_CALL http_glBlendFunc(GLenum sfactor, GLenum dfactor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendFunc)(sfactor, dfactor);
#endif
}

static void REGAL_CALL http_glCallList(GLuint list)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCallList)(list);
#endif
}

static void REGAL_CALL http_glCallLists(GLsizei n, GLenum type, const GLvoid *lists)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCallLists)(n, type, lists);
#endif
}

static void REGAL_CALL http_glClear(GLbitfield mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClear)(mask);
#endif
}

static void REGAL_CALL http_glClearAccum(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearAccum)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearColor)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glClearDepth(GLclampd depth)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearDepth)(depth);
#endif
}

static void REGAL_CALL http_glClearIndex(GLfloat c)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearIndex)(c);
#endif
}

static void REGAL_CALL http_glClearStencil(GLint s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearStencil)(s);
#endif
}

static void REGAL_CALL http_glClipPlane(GLenum plane, const GLdouble *equation)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClipPlane)(plane, equation);
#endif
}

static void REGAL_CALL http_glColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3b)(red, green, blue);
#endif
}

static void REGAL_CALL http_glColor3bv(const GLbyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3bv)(v);
#endif
}

static void REGAL_CALL http_glColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3d)(red, green, blue);
#endif
}

static void REGAL_CALL http_glColor3dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3dv)(v);
#endif
}

static void REGAL_CALL http_glColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3f)(red, green, blue);
#endif
}

static void REGAL_CALL http_glColor3fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3fv)(v);
#endif
}

static void REGAL_CALL http_glColor3i(GLint red, GLint green, GLint blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3i)(red, green, blue);
#endif
}

static void REGAL_CALL http_glColor3iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3iv)(v);
#endif
}

static void REGAL_CALL http_glColor3s(GLshort red, GLshort green, GLshort blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3s)(red, green, blue);
#endif
}

static void REGAL_CALL http_glColor3sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3sv)(v);
#endif
}

static void REGAL_CALL http_glColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3ub)(red, green, blue);
#endif
}

static void REGAL_CALL http_glColor3ubv(const GLubyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3ubv)(v);
#endif
}

static void REGAL_CALL http_glColor3ui(GLuint red, GLuint green, GLuint blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3ui)(red, green, blue);
#endif
}

static void REGAL_CALL http_glColor3uiv(const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3uiv)(v);
#endif
}

static void REGAL_CALL http_glColor3us(GLushort red, GLushort green, GLushort blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3us)(red, green, blue);
#endif
}

static void REGAL_CALL http_glColor3usv(const GLushort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3usv)(v);
#endif
}

static void REGAL_CALL http_glColor4b(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4b)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glColor4bv(const GLbyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4bv)(v);
#endif
}

static void REGAL_CALL http_glColor4d(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4d)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glColor4dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4dv)(v);
#endif
}

static void REGAL_CALL http_glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4f)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glColor4fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4fv)(v);
#endif
}

static void REGAL_CALL http_glColor4i(GLint red, GLint green, GLint blue, GLint alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4i)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glColor4iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4iv)(v);
#endif
}

static void REGAL_CALL http_glColor4s(GLshort red, GLshort green, GLshort blue, GLshort alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4s)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glColor4sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4sv)(v);
#endif
}

static void REGAL_CALL http_glColor4ub(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4ub)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glColor4ubv(const GLubyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4ubv)(v);
#endif
}

static void REGAL_CALL http_glColor4ui(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4ui)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glColor4uiv(const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4uiv)(v);
#endif
}

static void REGAL_CALL http_glColor4us(GLushort red, GLushort green, GLushort blue, GLushort alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4us)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glColor4usv(const GLushort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4usv)(v);
#endif
}

static void REGAL_CALL http_glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorMask)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glColorMaterial(GLenum face, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorMaterial)(face, mode);
#endif
}

static void REGAL_CALL http_glCopyPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyPixels)(x, y, width, height, type);
#endif
}

static void REGAL_CALL http_glCullFace(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCullFace)(mode);
#endif
}

static void REGAL_CALL http_glDeleteLists(GLuint list, GLsizei range)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteLists)(list, range);
#endif
}

static void REGAL_CALL http_glDepthFunc(GLenum func)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDepthFunc)(func);
#endif
}

static void REGAL_CALL http_glDepthMask(GLboolean flag)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDepthMask)(flag);
#endif
}

static void REGAL_CALL http_glDepthRange(GLclampd zNear, GLclampd zFar)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDepthRange)(zNear, zFar);
#endif
}

static void REGAL_CALL http_glDisable(GLenum cap)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisable)(cap);
#endif
}

static void REGAL_CALL http_glDrawBuffer(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawBuffer)(mode);
#endif
}

static void REGAL_CALL http_glDrawPixels(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawPixels)(width, height, format, type, pixels);
#endif
}

static void REGAL_CALL http_glEdgeFlag(GLboolean flag)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEdgeFlag)(flag);
#endif
}

static void REGAL_CALL http_glEdgeFlagv(const GLboolean *flag)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEdgeFlagv)(flag);
#endif
}

static void REGAL_CALL http_glEnable(GLenum cap)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnable)(cap);
#endif
}

static void REGAL_CALL http_glEnd(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnd)();
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.inBeginEnd--;
      _context->http.YieldToHttpServer( _context, false /*second call, don't update log */ );
      #endif
    }
}

static void REGAL_CALL http_glEndList(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndList)();
#endif
}

static void REGAL_CALL http_glEvalCoord1d(GLdouble u)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEvalCoord1d)(u);
#endif
}

static void REGAL_CALL http_glEvalCoord1dv(const GLdouble *u)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEvalCoord1dv)(u);
#endif
}

static void REGAL_CALL http_glEvalCoord1f(GLfloat u)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEvalCoord1f)(u);
#endif
}

static void REGAL_CALL http_glEvalCoord1fv(const GLfloat *u)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEvalCoord1fv)(u);
#endif
}

static void REGAL_CALL http_glEvalCoord2d(GLdouble u, GLdouble v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEvalCoord2d)(u, v);
#endif
}

static void REGAL_CALL http_glEvalCoord2dv(const GLdouble *u)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEvalCoord2dv)(u);
#endif
}

static void REGAL_CALL http_glEvalCoord2f(GLfloat u, GLfloat v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEvalCoord2f)(u, v);
#endif
}

static void REGAL_CALL http_glEvalCoord2fv(const GLfloat *u)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEvalCoord2fv)(u);
#endif
}

static void REGAL_CALL http_glEvalMesh1(GLenum mode, GLint i1, GLint i2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEvalMesh1)(mode, i1, i2);
#endif
}

static void REGAL_CALL http_glEvalMesh2(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEvalMesh2)(mode, i1, i2, j1, j2);
#endif
}

static void REGAL_CALL http_glEvalPoint1(GLint i)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEvalPoint1)(i);
#endif
}

static void REGAL_CALL http_glEvalPoint2(GLint i, GLint j)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEvalPoint2)(i, j);
#endif
}

static void REGAL_CALL http_glFeedbackBuffer(GLsizei size, GLenum type, GLfloat *buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFeedbackBuffer)(size, type, buffer);
#endif
}

static void REGAL_CALL http_glFinish(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFinish)();
#endif
}

static void REGAL_CALL http_glFlush(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFlush)();
#endif
}

static void REGAL_CALL http_glFogf(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogf)(pname, param);
#endif
}

static void REGAL_CALL http_glFogfv(GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogfv)(pname, params);
#endif
}

static void REGAL_CALL http_glFogi(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogi)(pname, param);
#endif
}

static void REGAL_CALL http_glFogiv(GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogiv)(pname, params);
#endif
}

static void REGAL_CALL http_glFrontFace(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFrontFace)(mode);
#endif
}

static void REGAL_CALL http_glFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFrustum)(left, right, bottom, top, zNear, zFar);
#endif
}

static GLuint REGAL_CALL http_glGenLists(GLsizei range)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGenLists)(range);
#endif
    return ret;
}

static void REGAL_CALL http_glGetBooleanv(GLenum pname, GLboolean *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetBooleanv)(pname, params);
#endif
}

static void REGAL_CALL http_glGetClipPlane(GLenum plane, GLdouble *equation)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetClipPlane)(plane, equation);
#endif
}

static void REGAL_CALL http_glGetDoublev(GLenum pname, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetDoublev)(pname, params);
#endif
}

static GLenum REGAL_CALL http_glGetError(void)
{
    GLenum  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetError)();
#endif
    return ret;
}

static void REGAL_CALL http_glGetFloatv(GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFloatv)(pname, params);
#endif
}

static void REGAL_CALL http_glGetIntegerv(GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetIntegerv)(pname, params);
#endif
}

static void REGAL_CALL http_glGetLightfv(GLenum light, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetLightfv)(light, pname, params);
#endif
}

static void REGAL_CALL http_glGetLightiv(GLenum light, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetLightiv)(light, pname, params);
#endif
}

static void REGAL_CALL http_glGetMapdv(GLenum target, GLenum query, GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMapdv)(target, query, v);
#endif
}

static void REGAL_CALL http_glGetMapfv(GLenum target, GLenum query, GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMapfv)(target, query, v);
#endif
}

static void REGAL_CALL http_glGetMapiv(GLenum target, GLenum query, GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMapiv)(target, query, v);
#endif
}

static void REGAL_CALL http_glGetMaterialfv(GLenum face, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMaterialfv)(face, pname, params);
#endif
}

static void REGAL_CALL http_glGetMaterialiv(GLenum face, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMaterialiv)(face, pname, params);
#endif
}

static void REGAL_CALL http_glGetPixelMapfv(GLenum map, GLfloat *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPixelMapfv)(map, values);
#endif
}

static void REGAL_CALL http_glGetPixelMapuiv(GLenum map, GLuint *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPixelMapuiv)(map, values);
#endif
}

static void REGAL_CALL http_glGetPixelMapusv(GLenum map, GLushort *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPixelMapusv)(map, values);
#endif
}

static void REGAL_CALL http_glGetPolygonStipple(GLubyte *mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPolygonStipple)(mask);
#endif
}

static const GLubyte *REGAL_CALL http_glGetString(GLenum name)
{
    const GLubyte * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetString)(name);
#endif
    return ret;
}

static void REGAL_CALL http_glGetTexEnvfv(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexEnvfv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexEnviv(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexEnviv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexGendv(GLenum coord, GLenum pname, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexGendv)(coord, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexGenfv(GLenum coord, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexGenfv)(coord, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexGeniv(GLenum coord, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexGeniv)(coord, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexImage)(target, level, format, type, pixels);
#endif
}

static void REGAL_CALL http_glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexLevelParameterfv)(target, level, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexLevelParameteriv)(target, level, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexParameterfv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexParameteriv(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexParameteriv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glHint(GLenum target, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glHint)(target, mode);
#endif
}

static void REGAL_CALL http_glIndexMask(GLuint mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexMask)(mask);
#endif
}

static void REGAL_CALL http_glIndexd(GLdouble c)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexd)(c);
#endif
}

static void REGAL_CALL http_glIndexdv(const GLdouble *c)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexdv)(c);
#endif
}

static void REGAL_CALL http_glIndexf(GLfloat c)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexf)(c);
#endif
}

static void REGAL_CALL http_glIndexfv(const GLfloat *c)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexfv)(c);
#endif
}

static void REGAL_CALL http_glIndexi(GLint c)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexi)(c);
#endif
}

static void REGAL_CALL http_glIndexiv(const GLint *c)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexiv)(c);
#endif
}

static void REGAL_CALL http_glIndexs(GLshort c)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexs)(c);
#endif
}

static void REGAL_CALL http_glIndexsv(const GLshort *c)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexsv)(c);
#endif
}

static void REGAL_CALL http_glInitNames(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInitNames)();
#endif
}

static GLboolean REGAL_CALL http_glIsEnabled(GLenum cap)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsEnabled)(cap);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glIsList(GLuint list)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsList)(list);
#endif
    return ret;
}

static void REGAL_CALL http_glLightModelf(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLightModelf)(pname, param);
#endif
}

static void REGAL_CALL http_glLightModelfv(GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLightModelfv)(pname, params);
#endif
}

static void REGAL_CALL http_glLightModeli(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLightModeli)(pname, param);
#endif
}

static void REGAL_CALL http_glLightModeliv(GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLightModeliv)(pname, params);
#endif
}

static void REGAL_CALL http_glLightf(GLenum light, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLightf)(light, pname, param);
#endif
}

static void REGAL_CALL http_glLightfv(GLenum light, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLightfv)(light, pname, params);
#endif
}

static void REGAL_CALL http_glLighti(GLenum light, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLighti)(light, pname, param);
#endif
}

static void REGAL_CALL http_glLightiv(GLenum light, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLightiv)(light, pname, params);
#endif
}

static void REGAL_CALL http_glLineStipple(GLint factor, GLushort pattern)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLineStipple)(factor, pattern);
#endif
}

static void REGAL_CALL http_glLineWidth(GLfloat width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLineWidth)(width);
#endif
}

static void REGAL_CALL http_glListBase(GLuint base)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glListBase)(base);
#endif
}

static void REGAL_CALL http_glLoadIdentity(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLoadIdentity)();
#endif
}

static void REGAL_CALL http_glLoadMatrixd(const GLdouble *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLoadMatrixd)(m);
#endif
}

static void REGAL_CALL http_glLoadMatrixf(const GLfloat *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLoadMatrixf)(m);
#endif
}

static void REGAL_CALL http_glLoadName(GLuint name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLoadName)(name);
#endif
}

static void REGAL_CALL http_glLogicOp(GLenum opcode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLogicOp)(opcode);
#endif
}

static void REGAL_CALL http_glMap1d(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMap1d)(target, u1, u2, stride, order, points);
#endif
}

static void REGAL_CALL http_glMap1f(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMap1f)(target, u1, u2, stride, order, points);
#endif
}

static void REGAL_CALL http_glMap2d(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMap2d)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
#endif
}

static void REGAL_CALL http_glMap2f(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMap2f)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
#endif
}

static void REGAL_CALL http_glMapGrid1d(GLint un, GLdouble u1, GLdouble u2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMapGrid1d)(un, u1, u2);
#endif
}

static void REGAL_CALL http_glMapGrid1f(GLint un, GLfloat u1, GLfloat u2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMapGrid1f)(un, u1, u2);
#endif
}

static void REGAL_CALL http_glMapGrid2d(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMapGrid2d)(un, u1, u2, vn, v1, v2);
#endif
}

static void REGAL_CALL http_glMapGrid2f(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMapGrid2f)(un, u1, u2, vn, v1, v2);
#endif
}

static void REGAL_CALL http_glMaterialf(GLenum face, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMaterialf)(face, pname, param);
#endif
}

static void REGAL_CALL http_glMaterialfv(GLenum face, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMaterialfv)(face, pname, params);
#endif
}

static void REGAL_CALL http_glMateriali(GLenum face, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMateriali)(face, pname, param);
#endif
}

static void REGAL_CALL http_glMaterialiv(GLenum face, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMaterialiv)(face, pname, params);
#endif
}

static void REGAL_CALL http_glMatrixMode(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixMode)(mode);
#endif
}

static void REGAL_CALL http_glMultMatrixd(const GLdouble *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultMatrixd)(m);
#endif
}

static void REGAL_CALL http_glMultMatrixf(const GLfloat *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultMatrixf)(m);
#endif
}

static void REGAL_CALL http_glNewList(GLuint list, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNewList)(list, mode);
#endif
}

static void REGAL_CALL http_glNormal3b(GLbyte nx, GLbyte ny, GLbyte nz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3b)(nx, ny, nz);
#endif
}

static void REGAL_CALL http_glNormal3bv(const GLbyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3bv)(v);
#endif
}

static void REGAL_CALL http_glNormal3d(GLdouble nx, GLdouble ny, GLdouble nz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3d)(nx, ny, nz);
#endif
}

static void REGAL_CALL http_glNormal3dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3dv)(v);
#endif
}

static void REGAL_CALL http_glNormal3f(GLfloat nx, GLfloat ny, GLfloat nz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3f)(nx, ny, nz);
#endif
}

static void REGAL_CALL http_glNormal3fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3fv)(v);
#endif
}

static void REGAL_CALL http_glNormal3i(GLint nx, GLint ny, GLint nz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3i)(nx, ny, nz);
#endif
}

static void REGAL_CALL http_glNormal3iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3iv)(v);
#endif
}

static void REGAL_CALL http_glNormal3s(GLshort nx, GLshort ny, GLshort nz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3s)(nx, ny, nz);
#endif
}

static void REGAL_CALL http_glNormal3sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3sv)(v);
#endif
}

static void REGAL_CALL http_glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glOrtho)(left, right, bottom, top, zNear, zFar);
#endif
}

static void REGAL_CALL http_glPassThrough(GLfloat token)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPassThrough)(token);
#endif
}

static void REGAL_CALL http_glPixelMapfv(GLenum map, GLsizei mapsize, const GLfloat *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelMapfv)(map, mapsize, values);
#endif
}

static void REGAL_CALL http_glPixelMapuiv(GLenum map, GLsizei mapsize, const GLuint *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelMapuiv)(map, mapsize, values);
#endif
}

static void REGAL_CALL http_glPixelMapusv(GLenum map, GLsizei mapsize, const GLushort *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelMapusv)(map, mapsize, values);
#endif
}

static void REGAL_CALL http_glPixelStoref(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelStoref)(pname, param);
#endif
}

static void REGAL_CALL http_glPixelStorei(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelStorei)(pname, param);
#endif
}

static void REGAL_CALL http_glPixelTransferf(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelTransferf)(pname, param);
#endif
}

static void REGAL_CALL http_glPixelTransferi(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelTransferi)(pname, param);
#endif
}

static void REGAL_CALL http_glPixelZoom(GLfloat xfactor, GLfloat yfactor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelZoom)(xfactor, yfactor);
#endif
}

static void REGAL_CALL http_glPointSize(GLfloat size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointSize)(size);
#endif
}

static void REGAL_CALL http_glPolygonMode(GLenum face, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPolygonMode)(face, mode);
#endif
}

static void REGAL_CALL http_glPolygonStipple(const GLubyte *mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPolygonStipple)(mask);
#endif
}

static void REGAL_CALL http_glPopAttrib(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPopAttrib)();
#endif
}

static void REGAL_CALL http_glPopMatrix(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPopMatrix)();
#endif
}

static void REGAL_CALL http_glPopName(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPopName)();
#endif
}

static void REGAL_CALL http_glPushAttrib(GLbitfield mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPushAttrib)(mask);
#endif
}

static void REGAL_CALL http_glPushMatrix(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPushMatrix)();
#endif
}

static void REGAL_CALL http_glPushName(GLuint name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPushName)(name);
#endif
}

static void REGAL_CALL http_glRasterPos2d(GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos2d)(x, y);
#endif
}

static void REGAL_CALL http_glRasterPos2dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos2dv)(v);
#endif
}

static void REGAL_CALL http_glRasterPos2f(GLfloat x, GLfloat y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos2f)(x, y);
#endif
}

static void REGAL_CALL http_glRasterPos2fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos2fv)(v);
#endif
}

static void REGAL_CALL http_glRasterPos2i(GLint x, GLint y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos2i)(x, y);
#endif
}

static void REGAL_CALL http_glRasterPos2iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos2iv)(v);
#endif
}

static void REGAL_CALL http_glRasterPos2s(GLshort x, GLshort y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos2s)(x, y);
#endif
}

static void REGAL_CALL http_glRasterPos2sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos2sv)(v);
#endif
}

static void REGAL_CALL http_glRasterPos3d(GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos3d)(x, y, z);
#endif
}

static void REGAL_CALL http_glRasterPos3dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos3dv)(v);
#endif
}

static void REGAL_CALL http_glRasterPos3f(GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos3f)(x, y, z);
#endif
}

static void REGAL_CALL http_glRasterPos3fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos3fv)(v);
#endif
}

static void REGAL_CALL http_glRasterPos3i(GLint x, GLint y, GLint z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos3i)(x, y, z);
#endif
}

static void REGAL_CALL http_glRasterPos3iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos3iv)(v);
#endif
}

static void REGAL_CALL http_glRasterPos3s(GLshort x, GLshort y, GLshort z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos3s)(x, y, z);
#endif
}

static void REGAL_CALL http_glRasterPos3sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos3sv)(v);
#endif
}

static void REGAL_CALL http_glRasterPos4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos4d)(x, y, z, w);
#endif
}

static void REGAL_CALL http_glRasterPos4dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos4dv)(v);
#endif
}

static void REGAL_CALL http_glRasterPos4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos4f)(x, y, z, w);
#endif
}

static void REGAL_CALL http_glRasterPos4fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos4fv)(v);
#endif
}

static void REGAL_CALL http_glRasterPos4i(GLint x, GLint y, GLint z, GLint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos4i)(x, y, z, w);
#endif
}

static void REGAL_CALL http_glRasterPos4iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos4iv)(v);
#endif
}

static void REGAL_CALL http_glRasterPos4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos4s)(x, y, z, w);
#endif
}

static void REGAL_CALL http_glRasterPos4sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRasterPos4sv)(v);
#endif
}

static void REGAL_CALL http_glReadBuffer(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReadBuffer)(mode);
#endif
}

static void REGAL_CALL http_glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReadPixels)(x, y, width, height, format, type, pixels);
#endif
}

static void REGAL_CALL http_glRectd(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRectd)(x1, y1, x2, y2);
#endif
}

static void REGAL_CALL http_glRectdv(const GLdouble *v1, const GLdouble *v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRectdv)(v1, v2);
#endif
}

static void REGAL_CALL http_glRectf(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRectf)(x1, y1, x2, y2);
#endif
}

static void REGAL_CALL http_glRectfv(const GLfloat *v1, const GLfloat *v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRectfv)(v1, v2);
#endif
}

static void REGAL_CALL http_glRecti(GLint x1, GLint y1, GLint x2, GLint y2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRecti)(x1, y1, x2, y2);
#endif
}

static void REGAL_CALL http_glRectiv(const GLint *v1, const GLint *v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRectiv)(v1, v2);
#endif
}

static void REGAL_CALL http_glRects(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRects)(x1, y1, x2, y2);
#endif
}

static void REGAL_CALL http_glRectsv(const GLshort *v1, const GLshort *v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRectsv)(v1, v2);
#endif
}

static GLint REGAL_CALL http_glRenderMode(GLenum mode)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glRenderMode)(mode);
#endif
    return ret;
}

static void REGAL_CALL http_glRotated(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRotated)(angle, x, y, z);
#endif
}

static void REGAL_CALL http_glRotatef(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRotatef)(angle, x, y, z);
#endif
}

static void REGAL_CALL http_glScaled(GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glScaled)(x, y, z);
#endif
}

static void REGAL_CALL http_glScalef(GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glScalef)(x, y, z);
#endif
}

static void REGAL_CALL http_glScissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glScissor)(x, y, width, height);
#endif
}

static void REGAL_CALL http_glSelectBuffer(GLsizei size, GLuint *buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSelectBuffer)(size, buffer);
#endif
}

static void REGAL_CALL http_glShadeModel(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glShadeModel)(mode);
#endif
}

static void REGAL_CALL http_glStencilFunc(GLenum func, GLint ref, GLuint mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilFunc)(func, ref, mask);
#endif
}

static void REGAL_CALL http_glStencilMask(GLuint mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilMask)(mask);
#endif
}

static void REGAL_CALL http_glStencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilOp)(fail, zfail, zpass);
#endif
}

static void REGAL_CALL http_glTexCoord1d(GLdouble s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord1d)(s);
#endif
}

static void REGAL_CALL http_glTexCoord1dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord1dv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord1f(GLfloat s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord1f)(s);
#endif
}

static void REGAL_CALL http_glTexCoord1fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord1fv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord1i(GLint s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord1i)(s);
#endif
}

static void REGAL_CALL http_glTexCoord1iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord1iv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord1s(GLshort s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord1s)(s);
#endif
}

static void REGAL_CALL http_glTexCoord1sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord1sv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord2d(GLdouble s, GLdouble t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2d)(s, t);
#endif
}

static void REGAL_CALL http_glTexCoord2dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2dv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord2f(GLfloat s, GLfloat t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2f)(s, t);
#endif
}

static void REGAL_CALL http_glTexCoord2fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2fv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord2i(GLint s, GLint t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2i)(s, t);
#endif
}

static void REGAL_CALL http_glTexCoord2iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2iv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord2s(GLshort s, GLshort t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2s)(s, t);
#endif
}

static void REGAL_CALL http_glTexCoord2sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2sv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord3d(GLdouble s, GLdouble t, GLdouble r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord3d)(s, t, r);
#endif
}

static void REGAL_CALL http_glTexCoord3dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord3dv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord3f(GLfloat s, GLfloat t, GLfloat r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord3f)(s, t, r);
#endif
}

static void REGAL_CALL http_glTexCoord3fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord3fv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord3i(GLint s, GLint t, GLint r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord3i)(s, t, r);
#endif
}

static void REGAL_CALL http_glTexCoord3iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord3iv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord3s(GLshort s, GLshort t, GLshort r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord3s)(s, t, r);
#endif
}

static void REGAL_CALL http_glTexCoord3sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord3sv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord4d(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4d)(s, t, r, q);
#endif
}

static void REGAL_CALL http_glTexCoord4dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4dv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord4f(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4f)(s, t, r, q);
#endif
}

static void REGAL_CALL http_glTexCoord4fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4fv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord4i(GLint s, GLint t, GLint r, GLint q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4i)(s, t, r, q);
#endif
}

static void REGAL_CALL http_glTexCoord4iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4iv)(v);
#endif
}

static void REGAL_CALL http_glTexCoord4s(GLshort s, GLshort t, GLshort r, GLshort q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4s)(s, t, r, q);
#endif
}

static void REGAL_CALL http_glTexCoord4sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4sv)(v);
#endif
}

static void REGAL_CALL http_glTexEnvf(GLenum target, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexEnvf)(target, pname, param);
#endif
}

static void REGAL_CALL http_glTexEnvfv(GLenum target, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexEnvfv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glTexEnvi(GLenum target, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexEnvi)(target, pname, param);
#endif
}

static void REGAL_CALL http_glTexEnviv(GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexEnviv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glTexGend(GLenum coord, GLenum pname, GLdouble param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexGend)(coord, pname, param);
#endif
}

static void REGAL_CALL http_glTexGendv(GLenum coord, GLenum pname, const GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexGendv)(coord, pname, params);
#endif
}

static void REGAL_CALL http_glTexGenf(GLenum coord, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexGenf)(coord, pname, param);
#endif
}

static void REGAL_CALL http_glTexGenfv(GLenum coord, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexGenfv)(coord, pname, params);
#endif
}

static void REGAL_CALL http_glTexGeni(GLenum coord, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexGeni)(coord, pname, param);
#endif
}

static void REGAL_CALL http_glTexGeniv(GLenum coord, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexGeniv)(coord, pname, params);
#endif
}

static void REGAL_CALL http_glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexImage1D)(target, level, internalformat, width, border, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexImage2D)(target, level, internalformat, width, height, border, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTexParameterf(GLenum target, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexParameterf)(target, pname, param);
#endif
}

static void REGAL_CALL http_glTexParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexParameterfv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glTexParameteri(GLenum target, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexParameteri)(target, pname, param);
#endif
}

static void REGAL_CALL http_glTexParameteriv(GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexParameteriv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glTranslated(GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTranslated)(x, y, z);
#endif
}

static void REGAL_CALL http_glTranslatef(GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTranslatef)(x, y, z);
#endif
}

static void REGAL_CALL http_glVertex2d(GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex2d)(x, y);
#endif
}

static void REGAL_CALL http_glVertex2dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex2dv)(v);
#endif
}

static void REGAL_CALL http_glVertex2f(GLfloat x, GLfloat y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex2f)(x, y);
#endif
}

static void REGAL_CALL http_glVertex2fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex2fv)(v);
#endif
}

static void REGAL_CALL http_glVertex2i(GLint x, GLint y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex2i)(x, y);
#endif
}

static void REGAL_CALL http_glVertex2iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex2iv)(v);
#endif
}

static void REGAL_CALL http_glVertex2s(GLshort x, GLshort y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex2s)(x, y);
#endif
}

static void REGAL_CALL http_glVertex2sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex2sv)(v);
#endif
}

static void REGAL_CALL http_glVertex3d(GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex3d)(x, y, z);
#endif
}

static void REGAL_CALL http_glVertex3dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex3dv)(v);
#endif
}

static void REGAL_CALL http_glVertex3f(GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex3f)(x, y, z);
#endif
}

static void REGAL_CALL http_glVertex3fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex3fv)(v);
#endif
}

static void REGAL_CALL http_glVertex3i(GLint x, GLint y, GLint z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex3i)(x, y, z);
#endif
}

static void REGAL_CALL http_glVertex3iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex3iv)(v);
#endif
}

static void REGAL_CALL http_glVertex3s(GLshort x, GLshort y, GLshort z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex3s)(x, y, z);
#endif
}

static void REGAL_CALL http_glVertex3sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex3sv)(v);
#endif
}

static void REGAL_CALL http_glVertex4d(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex4d)(x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertex4dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex4dv)(v);
#endif
}

static void REGAL_CALL http_glVertex4f(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex4f)(x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertex4fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex4fv)(v);
#endif
}

static void REGAL_CALL http_glVertex4i(GLint x, GLint y, GLint z, GLint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex4i)(x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertex4iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex4iv)(v);
#endif
}

static void REGAL_CALL http_glVertex4s(GLshort x, GLshort y, GLshort z, GLshort w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex4s)(x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertex4sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex4sv)(v);
#endif
}

static void REGAL_CALL http_glViewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glViewport)(x, y, width, height);
#endif
}

// GL_VERSION_1_1

static GLboolean REGAL_CALL http_glAreTexturesResident(GLsizei n, const GLuint *textures, GLboolean *residences)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glAreTexturesResident)(n, textures, residences);
#endif
    return ret;
}

static void REGAL_CALL http_glArrayElement(GLint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glArrayElement)(index);
#endif
}

static void REGAL_CALL http_glBindTexture(GLenum target, GLuint texture)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      if( texture != 0 ) {
        HttpTextureInfo & hti = _context->http.texture[ texture ];
        RegalAssert( hti.name == 0 || hti.name == texture );
        if( hti.name == 0 ) {
          hti.name = texture;
          hti.target = target;
        }
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindTexture)(target, texture);
#endif
}

static void REGAL_CALL http_glColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorPointer)(size, type, stride, pointer);
#endif
}

static void REGAL_CALL http_glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTexImage1D)(target, level, internalformat, x, y, width, border);
#endif
}

static void REGAL_CALL http_glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTexImage2D)(target, level, internalformat, x, y, width, height, border);
#endif
}

static void REGAL_CALL http_glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTexSubImage1D)(target, level, xoffset, x, y, width);
#endif
}

static void REGAL_CALL http_glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTexSubImage2D)(target, level, xoffset, yoffset, x, y, width, height);
#endif
}

static void REGAL_CALL http_glDeleteTextures(GLsizei n, const GLuint *textures)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      for( int i = 0; i < n; i++ ) {
        _context->http.texture.erase( textures[i] );
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteTextures)(n, textures);
#endif
}

static void REGAL_CALL http_glDisableClientState(GLenum cap)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisableClientState)(cap);
#endif
}

static void REGAL_CALL http_glDrawArrays(GLenum mode, GLint first, GLsizei count)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawArrays)(mode, first, count);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawElements)(mode, count, type, indices);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glEdgeFlagPointer(GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEdgeFlagPointer)(stride, pointer);
#endif
}

static void REGAL_CALL http_glEnableClientState(GLenum cap)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnableClientState)(cap);
#endif
}

static void REGAL_CALL http_glGenTextures(GLsizei n, GLuint *textures)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenTextures)(n, textures);
#endif
}

static void REGAL_CALL http_glGetPointerv(GLenum pname, GLvoid **params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPointerv)(pname, params);
#endif
}

static void REGAL_CALL http_glIndexPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexPointer)(type, stride, pointer);
#endif
}

static void REGAL_CALL http_glIndexub(GLubyte c)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexub)(c);
#endif
}

static void REGAL_CALL http_glIndexubv(const GLubyte *c)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexubv)(c);
#endif
}

static void REGAL_CALL http_glInterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInterleavedArrays)(format, stride, pointer);
#endif
}

static GLboolean REGAL_CALL http_glIsTexture(GLuint texture)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsTexture)(texture);
#endif
    return ret;
}

static void REGAL_CALL http_glNormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalPointer)(type, stride, pointer);
#endif
}

static void REGAL_CALL http_glPolygonOffset(GLfloat factor, GLfloat units)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPolygonOffset)(factor, units);
#endif
}

static void REGAL_CALL http_glPopClientAttrib(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPopClientAttrib)();
#endif
}

static void REGAL_CALL http_glPrioritizeTextures(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPrioritizeTextures)(n, textures, priorities);
#endif
}

static void REGAL_CALL http_glPushClientAttrib(GLbitfield mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPushClientAttrib)(mask);
#endif
}

static void REGAL_CALL http_glTexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoordPointer)(size, type, stride, pointer);
#endif
}

static void REGAL_CALL http_glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexSubImage1D)(target, level, xoffset, width, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, type, pixels);
#endif
}

static void REGAL_CALL http_glVertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexPointer)(size, type, stride, pointer);
#endif
}

// GL_VERSION_1_2

static void REGAL_CALL http_glBlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendColor)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glBlendEquation(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendEquation)(mode);
#endif
}

static void REGAL_CALL http_glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTexSubImage3D)(target, level, xoffset, yoffset, zoffset, x, y, width, height);
#endif
}

static void REGAL_CALL http_glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawRangeElements)(mode, start, end, count, type, indices);
#endif
}

static void REGAL_CALL http_glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexImage3D)(target, level, internalformat, width, height, depth, border, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
#endif
}

// GL_VERSION_1_3

static void REGAL_CALL http_glActiveTexture(GLenum texture)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glActiveTexture)(texture);
#endif
}

static void REGAL_CALL http_glClientActiveTexture(GLenum texture)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClientActiveTexture)(texture);
#endif
}

static void REGAL_CALL http_glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexImage1D)(target, level, internalformat, width, border, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexImage2D)(target, level, internalformat, width, height, border, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexImage3D)(target, level, internalformat, width, height, depth, border, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexSubImage1D)(target, level, xoffset, width, format, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexSubImage2D)(target, level, xoffset, yoffset, width, height, format, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexSubImage3D)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
#endif
}

static void REGAL_CALL http_glGetCompressedTexImage(GLenum target, GLint lod, GLvoid *img)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetCompressedTexImage)(target, lod, img);
#endif
}

static void REGAL_CALL http_glLoadTransposeMatrixd(const GLdouble *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLoadTransposeMatrixd)(m);
#endif
}

static void REGAL_CALL http_glLoadTransposeMatrixf(const GLfloat *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLoadTransposeMatrixf)(m);
#endif
}

static void REGAL_CALL http_glMultTransposeMatrixd(const GLdouble *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultTransposeMatrixd)(m);
#endif
}

static void REGAL_CALL http_glMultTransposeMatrixf(const GLfloat *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultTransposeMatrixf)(m);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1d(GLenum target, GLdouble s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1d)(target, s);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1dv(GLenum target, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1dv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1f(GLenum target, GLfloat s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1f)(target, s);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1fv(GLenum target, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1fv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1i(GLenum target, GLint s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1i)(target, s);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1iv(GLenum target, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1iv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1s(GLenum target, GLshort s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1s)(target, s);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1sv(GLenum target, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1sv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2d(GLenum target, GLdouble s, GLdouble t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2d)(target, s, t);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2dv(GLenum target, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2dv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2f(GLenum target, GLfloat s, GLfloat t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2f)(target, s, t);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2fv(GLenum target, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2fv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2i(GLenum target, GLint s, GLint t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2i)(target, s, t);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2iv(GLenum target, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2iv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2s(GLenum target, GLshort s, GLshort t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2s)(target, s, t);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2sv(GLenum target, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2sv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3d(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3d)(target, s, t, r);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3dv(GLenum target, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3dv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3f(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3f)(target, s, t, r);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3fv(GLenum target, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3fv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3i(GLenum target, GLint s, GLint t, GLint r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3i)(target, s, t, r);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3iv(GLenum target, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3iv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3s(GLenum target, GLshort s, GLshort t, GLshort r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3s)(target, s, t, r);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3sv(GLenum target, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3sv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4d(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4d)(target, s, t, r, q);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4dv(GLenum target, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4dv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4f(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4f)(target, s, t, r, q);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4fv(GLenum target, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4fv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4i(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4i)(target, s, t, r, q);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4iv(GLenum target, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4iv)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4s(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4s)(target, s, t, r, q);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4sv(GLenum target, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4sv)(target, v);
#endif
}

static void REGAL_CALL http_glSampleCoverage(GLclampf value, GLboolean invert)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSampleCoverage)(value, invert);
#endif
}

// GL_VERSION_1_4

static void REGAL_CALL http_glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendFuncSeparate)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
#endif
}

static void REGAL_CALL http_glFogCoordPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoordPointer)(type, stride, pointer);
#endif
}

static void REGAL_CALL http_glFogCoordd(GLdouble coord)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoordd)(coord);
#endif
}

static void REGAL_CALL http_glFogCoorddv(const GLdouble *coord)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoorddv)(coord);
#endif
}

static void REGAL_CALL http_glFogCoordf(GLfloat coord)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoordf)(coord);
#endif
}

static void REGAL_CALL http_glFogCoordfv(const GLfloat *coord)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoordfv)(coord);
#endif
}

static void REGAL_CALL http_glMultiDrawArrays(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiDrawArrays)(mode, first, count, primcount);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glMultiDrawElements(GLenum mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiDrawElements)(mode, count, type, indices, primcount);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glPointParameterf(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameterf)(pname, param);
#endif
}

static void REGAL_CALL http_glPointParameterfv(GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameterfv)(pname, params);
#endif
}

static void REGAL_CALL http_glPointParameteri(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameteri)(pname, param);
#endif
}

static void REGAL_CALL http_glPointParameteriv(GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameteriv)(pname, params);
#endif
}

static void REGAL_CALL http_glSecondaryColor3b(GLbyte red, GLbyte green, GLbyte blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3b)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3bv(const GLbyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3bv)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3d(GLdouble red, GLdouble green, GLdouble blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3d)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3dv(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3dv)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3f(GLfloat red, GLfloat green, GLfloat blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3f)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3fv(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3fv)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3i(GLint red, GLint green, GLint blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3i)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3iv(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3iv)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3s(GLshort red, GLshort green, GLshort blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3s)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3sv(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3sv)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3ub(GLubyte red, GLubyte green, GLubyte blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3ub)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3ubv(const GLubyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3ubv)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3ui(GLuint red, GLuint green, GLuint blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3ui)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3uiv(const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3uiv)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3us(GLushort red, GLushort green, GLushort blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3us)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3usv(const GLushort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3usv)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColorPointer)(size, type, stride, pointer);
#endif
}

static void REGAL_CALL http_glWindowPos2d(GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2d)(x, y);
#endif
}

static void REGAL_CALL http_glWindowPos2dv(const GLdouble *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2dv)(p);
#endif
}

static void REGAL_CALL http_glWindowPos2f(GLfloat x, GLfloat y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2f)(x, y);
#endif
}

static void REGAL_CALL http_glWindowPos2fv(const GLfloat *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2fv)(p);
#endif
}

static void REGAL_CALL http_glWindowPos2i(GLint x, GLint y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2i)(x, y);
#endif
}

static void REGAL_CALL http_glWindowPos2iv(const GLint *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2iv)(p);
#endif
}

static void REGAL_CALL http_glWindowPos2s(GLshort x, GLshort y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2s)(x, y);
#endif
}

static void REGAL_CALL http_glWindowPos2sv(const GLshort *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2sv)(p);
#endif
}

static void REGAL_CALL http_glWindowPos3d(GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3d)(x, y, z);
#endif
}

static void REGAL_CALL http_glWindowPos3dv(const GLdouble *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3dv)(p);
#endif
}

static void REGAL_CALL http_glWindowPos3f(GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3f)(x, y, z);
#endif
}

static void REGAL_CALL http_glWindowPos3fv(const GLfloat *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3fv)(p);
#endif
}

static void REGAL_CALL http_glWindowPos3i(GLint x, GLint y, GLint z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3i)(x, y, z);
#endif
}

static void REGAL_CALL http_glWindowPos3iv(const GLint *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3iv)(p);
#endif
}

static void REGAL_CALL http_glWindowPos3s(GLshort x, GLshort y, GLshort z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3s)(x, y, z);
#endif
}

static void REGAL_CALL http_glWindowPos3sv(const GLshort *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3sv)(p);
#endif
}

// GL_VERSION_1_5

static void REGAL_CALL http_glBeginQuery(GLenum target, GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginQuery)(target, id);
#endif
}

static void REGAL_CALL http_glBindBuffer(GLenum target, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindBuffer)(target, buffer);
#endif
}

static void REGAL_CALL http_glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBufferData)(target, size, data, usage);
#endif
}

static void REGAL_CALL http_glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBufferSubData)(target, offset, size, data);
#endif
}

static void REGAL_CALL http_glDeleteBuffers(GLsizei n, const GLuint *buffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteBuffers)(n, buffers);
#endif
}

static void REGAL_CALL http_glDeleteQueries(GLsizei n, const GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteQueries)(n, ids);
#endif
}

static void REGAL_CALL http_glEndQuery(GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndQuery)(target);
#endif
}

static void REGAL_CALL http_glGenBuffers(GLsizei n, GLuint *buffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenBuffers)(n, buffers);
#endif
}

static void REGAL_CALL http_glGenQueries(GLsizei n, GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenQueries)(n, ids);
#endif
}

static void REGAL_CALL http_glGetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetBufferParameteriv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetBufferPointerv(GLenum target, GLenum pname, GLvoid **params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetBufferPointerv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetBufferSubData)(target, offset, size, data);
#endif
}

static void REGAL_CALL http_glGetQueryObjectiv(GLuint id, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjectiv)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjectuiv)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetQueryiv(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryiv)(target, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsBuffer(GLuint buffer)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsBuffer)(buffer);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glIsQuery(GLuint id)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsQuery)(id);
#endif
    return ret;
}

static GLvoid *REGAL_CALL http_glMapBuffer(GLenum target, GLenum access)
{
    GLvoid * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glMapBuffer)(target, access);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glUnmapBuffer(GLenum target)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glUnmapBuffer)(target);
#endif
    return ret;
}

// GL_VERSION_2_0

static void REGAL_CALL http_glAttachShader(GLuint program, GLuint shader)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glAttachShader)(program, shader);
#endif
}

static void REGAL_CALL http_glBindAttribLocation(GLuint program, GLuint index, const GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindAttribLocation)(program, index, name);
#endif
}

static void REGAL_CALL http_glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendEquationSeparate)(modeRGB, modeAlpha);
#endif
}

static void REGAL_CALL http_glCompileShader(GLuint shader)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompileShader)(shader);
#endif
}

static GLuint REGAL_CALL http_glCreateProgram(void)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glCreateProgram)();
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.program.insert( ret );
      #endif
    }
    return ret;
}

static GLuint REGAL_CALL http_glCreateShader(GLenum type)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glCreateShader)(type);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.shader.insert( ret );
      #endif
    }
    return ret;
}

static void REGAL_CALL http_glDeleteProgram(GLuint program)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteProgram)(program);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.program.erase( program );
      #endif
    }
}

static void REGAL_CALL http_glDeleteShader(GLuint shader)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteShader)(shader);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.shader.erase( shader );
      #endif
    }
}

static void REGAL_CALL http_glDetachShader(GLuint program, GLuint shader)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDetachShader)(program, shader);
#endif
}

static void REGAL_CALL http_glDisableVertexAttribArray(GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisableVertexAttribArray)(index);
#endif
}

static void REGAL_CALL http_glDrawBuffers(GLsizei n, const GLenum *bufs)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawBuffers)(n, bufs);
#endif
}

static void REGAL_CALL http_glEnableVertexAttribArray(GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnableVertexAttribArray)(index);
#endif
}

static void REGAL_CALL http_glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetActiveAttrib)(program, index, bufSize, length, size, type, name);
#endif
}

static void REGAL_CALL http_glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetActiveUniform)(program, index, bufSize, length, size, type, name);
#endif
}

static void REGAL_CALL http_glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetAttachedShaders)(program, maxCount, count, shaders);
#endif
}

static GLint REGAL_CALL http_glGetAttribLocation(GLuint program, const GLchar *name)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetAttribLocation)(program, name);
#endif
    return ret;
}

static void REGAL_CALL http_glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramInfoLog)(program, bufSize, length, infoLog);
#endif
}

static void REGAL_CALL http_glGetProgramiv(GLuint program, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramiv)(program, pname, params);
#endif
}

static void REGAL_CALL http_glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetShaderInfoLog)(shader, bufSize, length, infoLog);
#endif
}

static void REGAL_CALL http_glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetShaderSource)(shader, bufSize, length, source);
#endif
}

static void REGAL_CALL http_glGetShaderiv(GLuint shader, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetShaderiv)(shader, pname, params);
#endif
}

static GLint REGAL_CALL http_glGetUniformLocation(GLuint program, const GLchar *name)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetUniformLocation)(program, name);
#endif
    return ret;
}

static void REGAL_CALL http_glGetUniformfv(GLuint program, GLint location, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetUniformfv)(program, location, params);
#endif
}

static void REGAL_CALL http_glGetUniformiv(GLuint program, GLint location, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetUniformiv)(program, location, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribPointerv)(index, pname, pointer);
#endif
}

static void REGAL_CALL http_glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribdv)(index, pname, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribfv)(index, pname, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribiv)(index, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsProgram(GLuint program)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsProgram)(program);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glIsShader(GLuint shader)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsShader)(shader);
#endif
    return ret;
}

static void REGAL_CALL http_glLinkProgram(GLuint program)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLinkProgram)(program);
#endif
}

static void REGAL_CALL http_glShaderSource(GLuint shader, GLsizei count, const GLchar * const *string, const GLint *length)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glShaderSource)(shader, count, string, length);
#endif
}

static void REGAL_CALL http_glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilFuncSeparate)(face, func, ref, mask);
#endif
}

static void REGAL_CALL http_glStencilMaskSeparate(GLenum face, GLuint mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilMaskSeparate)(face, mask);
#endif
}

static void REGAL_CALL http_glStencilOpSeparate(GLenum face, GLenum fail, GLenum zfail, GLenum zpass)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilOpSeparate)(face, fail, zfail, zpass);
#endif
}

static void REGAL_CALL http_glUniform1f(GLint location, GLfloat v0)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1f)(location, v0);
#endif
}

static void REGAL_CALL http_glUniform1fv(GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1fv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform1i(GLint location, GLint v0)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1i)(location, v0);
#endif
}

static void REGAL_CALL http_glUniform1iv(GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1iv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform2f(GLint location, GLfloat v0, GLfloat v1)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2f)(location, v0, v1);
#endif
}

static void REGAL_CALL http_glUniform2fv(GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2fv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform2i(GLint location, GLint v0, GLint v1)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2i)(location, v0, v1);
#endif
}

static void REGAL_CALL http_glUniform2iv(GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2iv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3f)(location, v0, v1, v2);
#endif
}

static void REGAL_CALL http_glUniform3fv(GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3fv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3i)(location, v0, v1, v2);
#endif
}

static void REGAL_CALL http_glUniform3iv(GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3iv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4f)(location, v0, v1, v2, v3);
#endif
}

static void REGAL_CALL http_glUniform4fv(GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4fv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4i)(location, v0, v1, v2, v3);
#endif
}

static void REGAL_CALL http_glUniform4iv(GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4iv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix2fv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix3fv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix4fv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUseProgram(GLuint program)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUseProgram)(program);
#endif
}

static void REGAL_CALL http_glValidateProgram(GLuint program)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glValidateProgram)(program);
#endif
}

static void REGAL_CALL http_glVertexAttrib1d(GLuint index, GLdouble x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1d)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttrib1dv(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1dv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib1f(GLuint index, GLfloat x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1f)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttrib1fv(GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1fv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib1s(GLuint index, GLshort x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1s)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttrib1sv(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1sv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2d)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttrib2dv(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2dv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2f)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttrib2fv(GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2fv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib2s(GLuint index, GLshort x, GLshort y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2s)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttrib2sv(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2sv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3d)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttrib3dv(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3dv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3f)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttrib3fv(GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3fv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3s)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttrib3sv(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3sv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4Nbv(GLuint index, const GLbyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4Nbv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4Niv(GLuint index, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4Niv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4Nsv(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4Nsv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4Nub)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttrib4Nubv(GLuint index, const GLubyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4Nubv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4Nuiv(GLuint index, const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4Nuiv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4Nusv(GLuint index, const GLushort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4Nusv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4bv(GLuint index, const GLbyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4bv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4d)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttrib4dv(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4dv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4f)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttrib4fv(GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4fv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4iv(GLuint index, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4iv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4s)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttrib4sv(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4sv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4ubv(GLuint index, const GLubyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4ubv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4uiv(GLuint index, const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4uiv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4usv(GLuint index, const GLushort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4usv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribPointer)(index, size, type, normalized, stride, pointer);
#endif
}

// GL_VERSION_2_1

static void REGAL_CALL http_glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix2x3fv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix2x4fv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix3x2fv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix3x4fv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix4x2fv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix4x3fv)(location, count, transpose, value);
#endif
}

// GL_VERSION_3_0

static void REGAL_CALL http_glBeginConditionalRender(GLuint id, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginConditionalRender)(id, mode);
#endif
}

static void REGAL_CALL http_glBeginTransformFeedback(GLenum primitiveMode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginTransformFeedback)(primitiveMode);
#endif
}

static void REGAL_CALL http_glBindFragDataLocation(GLuint program, GLuint color, const GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindFragDataLocation)(program, color, name);
#endif
}

static void REGAL_CALL http_glClampColor(GLenum target, GLenum clamp)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClampColor)(target, clamp);
#endif
}

static void REGAL_CALL http_glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearBufferfi)(buffer, drawbuffer, depth, stencil);
#endif
}

static void REGAL_CALL http_glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearBufferfv)(buffer, drawbuffer, value);
#endif
}

static void REGAL_CALL http_glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearBufferiv)(buffer, drawbuffer, value);
#endif
}

static void REGAL_CALL http_glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearBufferuiv)(buffer, drawbuffer, value);
#endif
}

static void REGAL_CALL http_glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorMaski)(index, r, g, b, a);
#endif
}

static void REGAL_CALL http_glDisablei(GLenum cap, GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisablei)(cap, index);
#endif
}

static void REGAL_CALL http_glEnablei(GLenum cap, GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnablei)(cap, index);
#endif
}

static void REGAL_CALL http_glEndConditionalRender(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndConditionalRender)();
#endif
}

static void REGAL_CALL http_glEndTransformFeedback(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndTransformFeedback)();
#endif
}

static void REGAL_CALL http_glGetBooleani_v(GLenum target, GLuint index, GLboolean *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetBooleani_v)(target, index, data);
#endif
}

static GLint REGAL_CALL http_glGetFragDataLocation(GLuint program, const GLchar *name)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetFragDataLocation)(program, name);
#endif
    return ret;
}

static const GLubyte *REGAL_CALL http_glGetStringi(GLenum name, GLuint index)
{
    const GLubyte * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetStringi)(name, index);
#endif
    return ret;
}

static void REGAL_CALL http_glGetTexParameterIiv(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexParameterIiv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexParameterIuiv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTransformFeedbackVarying)(program, index, bufSize, length, size, type, name);
#endif
}

static void REGAL_CALL http_glGetUniformuiv(GLuint program, GLint location, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetUniformuiv)(program, location, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribIiv)(index, pname, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribIuiv)(index, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsEnabledi(GLenum target, GLuint index)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsEnabledi)(target, index);
#endif
    return ret;
}

static void REGAL_CALL http_glTexParameterIiv(GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexParameterIiv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glTexParameterIuiv(GLenum target, GLenum pname, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexParameterIuiv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar * const *varyings, GLenum bufferMode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTransformFeedbackVaryings)(program, count, varyings, bufferMode);
#endif
}

static void REGAL_CALL http_glUniform1ui(GLint location, GLuint v0)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1ui)(location, v0);
#endif
}

static void REGAL_CALL http_glUniform1uiv(GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1uiv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform2ui(GLint location, GLuint v0, GLuint v1)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2ui)(location, v0, v1);
#endif
}

static void REGAL_CALL http_glUniform2uiv(GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2uiv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3ui)(location, v0, v1, v2);
#endif
}

static void REGAL_CALL http_glUniform3uiv(GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3uiv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4ui)(location, v0, v1, v2, v3);
#endif
}

static void REGAL_CALL http_glUniform4uiv(GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4uiv)(location, count, value);
#endif
}

static void REGAL_CALL http_glVertexAttribI1i(GLuint index, GLint x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI1i)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttribI1iv(GLuint index, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI1iv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI1ui(GLuint index, GLuint x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI1ui)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttribI1uiv(GLuint index, const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI1uiv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI2i(GLuint index, GLint x, GLint y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI2i)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttribI2iv(GLuint index, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI2iv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI2ui(GLuint index, GLuint x, GLuint y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI2ui)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttribI2uiv(GLuint index, const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI2uiv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI3i)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttribI3iv(GLuint index, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI3iv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI3ui)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttribI3uiv(GLuint index, const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI3uiv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI4bv(GLuint index, const GLbyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4bv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4i)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttribI4iv(GLuint index, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4iv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI4sv(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4sv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI4ubv(GLuint index, const GLubyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4ubv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4ui)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttribI4uiv(GLuint index, const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4uiv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI4usv(GLuint index, const GLushort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4usv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribIPointer)(index, size, type, stride, pointer);
#endif
}

// GL_VERSION_3_1

static void REGAL_CALL http_glDrawArraysInstanced(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawArraysInstanced)(mode, start, count, primcount);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawElementsInstanced)(mode, count, type, indices, primcount);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glPrimitiveRestartIndex(GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPrimitiveRestartIndex)(index);
#endif
}

static void REGAL_CALL http_glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexBuffer)(target, internalformat, buffer);
#endif
}

// GL_VERSION_3_2

static void REGAL_CALL http_glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTexture)(target, attachment, texture, level);
#endif
}

static void REGAL_CALL http_glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64 *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetBufferParameteri64v)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetInteger64i_v(GLenum target, GLuint index, GLint64 *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetInteger64i_v)(target, index, data);
#endif
}

// GL_VERSION_3_3

static void REGAL_CALL http_glVertexAttribDivisor(GLuint index, GLuint divisor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribDivisor)(index, divisor);
#endif
}

// GL_VERSION_4_0

static void REGAL_CALL http_glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendEquationSeparatei)(buf, modeRGB, modeAlpha);
#endif
}

static void REGAL_CALL http_glBlendEquationi(GLuint buf, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendEquationi)(buf, mode);
#endif
}

static void REGAL_CALL http_glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendFuncSeparatei)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
#endif
}

static void REGAL_CALL http_glBlendFunci(GLuint buf, GLenum src, GLenum dst)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendFunci)(buf, src, dst);
#endif
}

// GL_3DFX_tbuffer

static void REGAL_CALL http_glTbufferMask3DFX(GLuint mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTbufferMask3DFX)(mask);
#endif
}

// GL_AMD_debug_output

static void REGAL_CALL http_glDebugMessageCallbackAMD(GLDEBUGPROCAMD callback, void *userParam)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDebugMessageCallbackAMD)(callback, userParam);
#endif
}

static void REGAL_CALL http_glDebugMessageEnableAMD(GLenum category, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDebugMessageEnableAMD)(category, severity, count, ids, enabled);
#endif
}

static void REGAL_CALL http_glDebugMessageInsertAMD(GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar *buf)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDebugMessageInsertAMD)(category, severity, id, length, buf);
#endif
}

static GLuint REGAL_CALL http_glGetDebugMessageLogAMD(GLuint count, GLsizei bufsize, GLenum *categories, GLuint *severities, GLuint *ids, GLsizei *lengths, GLchar *message)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetDebugMessageLogAMD)(count, bufsize, categories, severities, ids, lengths, message);
#endif
    return ret;
}

// GL_AMD_draw_buffers_blend

static void REGAL_CALL http_glBlendEquationIndexedAMD(GLuint buf, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendEquationIndexedAMD)(buf, mode);
#endif
}

static void REGAL_CALL http_glBlendEquationSeparateIndexedAMD(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendEquationSeparateIndexedAMD)(buf, modeRGB, modeAlpha);
#endif
}

static void REGAL_CALL http_glBlendFuncIndexedAMD(GLuint buf, GLenum src, GLenum dst)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendFuncIndexedAMD)(buf, src, dst);
#endif
}

static void REGAL_CALL http_glBlendFuncSeparateIndexedAMD(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendFuncSeparateIndexedAMD)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
#endif
}

// GL_AMD_interleaved_elements

static void REGAL_CALL http_glVertexAttribParameteriAMD(GLuint index, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribParameteriAMD)(index, pname, param);
#endif
}

// GL_AMD_multi_draw_indirect

static void REGAL_CALL http_glMultiDrawArraysIndirectAMD(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiDrawArraysIndirectAMD)(mode, indirect, primcount, stride);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glMultiDrawElementsIndirectAMD(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiDrawElementsIndirectAMD)(mode, type, indirect, primcount, stride);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

// GL_AMD_name_gen_delete

static void REGAL_CALL http_glDeleteNamesAMD(GLenum identifier, GLuint num, const GLuint *names)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteNamesAMD)(identifier, num, names);
#endif
}

static void REGAL_CALL http_glGenNamesAMD(GLenum identifier, GLuint num, GLuint *names)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenNamesAMD)(identifier, num, names);
#endif
}

static GLboolean REGAL_CALL http_glIsNameAMD(GLenum identifier, GLuint name)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsNameAMD)(identifier, name);
#endif
    return ret;
}

// GL_AMD_performance_monitor

static void REGAL_CALL http_glBeginPerfMonitorAMD(GLuint monitor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginPerfMonitorAMD)(monitor);
#endif
}

static void REGAL_CALL http_glDeletePerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeletePerfMonitorsAMD)(n, monitors);
#endif
}

static void REGAL_CALL http_glEndPerfMonitorAMD(GLuint monitor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndPerfMonitorAMD)(monitor);
#endif
}

static void REGAL_CALL http_glGenPerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenPerfMonitorsAMD)(n, monitors);
#endif
}

static void REGAL_CALL http_glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPerfMonitorCounterDataAMD)(monitor, pname, dataSize, data, bytesWritten);
#endif
}

static void REGAL_CALL http_glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPerfMonitorCounterInfoAMD)(group, counter, pname, data);
#endif
}

static void REGAL_CALL http_glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPerfMonitorCounterStringAMD)(group, counter, bufSize, length, counterString);
#endif
}

static void REGAL_CALL http_glGetPerfMonitorCountersAMD(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPerfMonitorCountersAMD)(group, numCounters, maxActiveCounters, countersSize, counters);
#endif
}

static void REGAL_CALL http_glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPerfMonitorGroupStringAMD)(group, bufSize, length, groupString);
#endif
}

static void REGAL_CALL http_glGetPerfMonitorGroupsAMD(GLint *numGroups, GLsizei groupsSize, GLuint *groups)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPerfMonitorGroupsAMD)(numGroups, groupsSize, groups);
#endif
}

static void REGAL_CALL http_glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSelectPerfMonitorCountersAMD)(monitor, enable, group, numCounters, counterList);
#endif
}

// GL_AMD_sample_positions

static void REGAL_CALL http_glSetMultisamplefvAMD(GLenum pname, GLuint index, const GLfloat *val)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSetMultisamplefvAMD)(pname, index, val);
#endif
}

// GL_AMD_sparse_texture

static void REGAL_CALL http_glTexStorageSparseAMD(GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexStorageSparseAMD)(target, internalFormat, width, height, depth, layers, flags);
#endif
}

static void REGAL_CALL http_glTextureStorageSparseAMD(GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureStorageSparseAMD)(texture, target, internalFormat, width, height, depth, layers, flags);
#endif
}

// GL_AMD_stencil_operation_extended

static void REGAL_CALL http_glStencilOpValueAMD(GLenum face, GLuint value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilOpValueAMD)(face, value);
#endif
}

// GL_AMD_vertex_shader_tessellator

static void REGAL_CALL http_glTessellationFactorAMD(GLfloat factor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTessellationFactorAMD)(factor);
#endif
}

static void REGAL_CALL http_glTessellationModeAMD(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTessellationModeAMD)(mode);
#endif
}

// GL_ANGLE_framebuffer_blit

static void REGAL_CALL http_glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlitFramebufferANGLE)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
#endif
}

// GL_ANGLE_framebuffer_multisample

static void REGAL_CALL http_glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRenderbufferStorageMultisampleANGLE)(target, samples, internalformat, width, height);
#endif
}

// GL_ANGLE_instanced_arrays

static void REGAL_CALL http_glDrawArraysInstancedANGLE(GLenum mode, GLint first, GLsizei count, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawArraysInstancedANGLE)(mode, first, count, primcount);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glDrawElementsInstancedANGLE(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawElementsInstancedANGLE)(mode, count, type, indices, primcount);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glVertexAttribDivisorANGLE(GLuint index, GLuint divisor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribDivisorANGLE)(index, divisor);
#endif
}

// GL_ANGLE_timer_query

static void REGAL_CALL http_glBeginQueryANGLE(GLenum target, GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginQueryANGLE)(target, id);
#endif
}

static void REGAL_CALL http_glDeleteQueriesANGLE(GLsizei n, const GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteQueriesANGLE)(n, ids);
#endif
}

static void REGAL_CALL http_glEndQueryANGLE(GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndQueryANGLE)(target);
#endif
}

static void REGAL_CALL http_glGenQueriesANGLE(GLsizei n, GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenQueriesANGLE)(n, ids);
#endif
}

static void REGAL_CALL http_glGetQueryObjecti64vANGLE(GLuint id, GLenum pname, GLint64 *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjecti64vANGLE)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetQueryObjectivANGLE(GLuint id, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjectivANGLE)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetQueryObjectui64vANGLE(GLuint id, GLenum pname, GLuint64 *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjectui64vANGLE)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetQueryObjectuivANGLE(GLuint id, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjectuivANGLE)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetQueryivANGLE(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryivANGLE)(target, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsQueryANGLE(GLuint id)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsQueryANGLE)(id);
#endif
    return ret;
}

static void REGAL_CALL http_glQueryCounterANGLE(GLuint id, GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glQueryCounterANGLE)(id, target);
#endif
}

// GL_ANGLE_translated_shader_source

static void REGAL_CALL http_glGetTranslatedShaderSourceANGLE(GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *source)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTranslatedShaderSourceANGLE)(shader, bufsize, length, source);
#endif
}

// GL_APPLE_copy_texture_levels

static void REGAL_CALL http_glCopyTextureLevelsAPPLE(GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTextureLevelsAPPLE)(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
#endif
}

// GL_APPLE_element_array

static void REGAL_CALL http_glDrawElementArrayAPPLE(GLenum mode, GLint first, GLsizei count)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawElementArrayAPPLE)(mode, first, count);
#endif
}

static void REGAL_CALL http_glDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawRangeElementArrayAPPLE)(mode, start, end, first, count);
#endif
}

static void REGAL_CALL http_glElementPointerAPPLE(GLenum type, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glElementPointerAPPLE)(type, pointer);
#endif
}

static void REGAL_CALL http_glMultiDrawElementArrayAPPLE(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiDrawElementArrayAPPLE)(mode, first, count, primcount);
#endif
}

static void REGAL_CALL http_glMultiDrawRangeElementArrayAPPLE(GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiDrawRangeElementArrayAPPLE)(mode, start, end, first, count, primcount);
#endif
}

// GL_APPLE_fence

static void REGAL_CALL http_glDeleteFencesAPPLE(GLsizei n, const GLuint *fences)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteFencesAPPLE)(n, fences);
#endif
}

static void REGAL_CALL http_glFinishFenceAPPLE(GLuint fence)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFinishFenceAPPLE)(fence);
#endif
}

static void REGAL_CALL http_glFinishObjectAPPLE(GLenum object, GLint name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFinishObjectAPPLE)(object, name);
#endif
}

static void REGAL_CALL http_glGenFencesAPPLE(GLsizei n, GLuint *fences)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenFencesAPPLE)(n, fences);
#endif
}

static GLboolean REGAL_CALL http_glIsFenceAPPLE(GLuint fence)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsFenceAPPLE)(fence);
#endif
    return ret;
}

static void REGAL_CALL http_glSetFenceAPPLE(GLuint fence)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSetFenceAPPLE)(fence);
#endif
}

static GLboolean REGAL_CALL http_glTestFenceAPPLE(GLuint fence)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glTestFenceAPPLE)(fence);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glTestObjectAPPLE(GLenum object, GLuint name)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glTestObjectAPPLE)(object, name);
#endif
    return ret;
}

// GL_APPLE_flush_buffer_range

static void REGAL_CALL http_glBufferParameteriAPPLE(GLenum target, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBufferParameteriAPPLE)(target, pname, param);
#endif
}

static void REGAL_CALL http_glFlushMappedBufferRangeAPPLE(GLenum target, GLintptr offset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFlushMappedBufferRangeAPPLE)(target, offset, size);
#endif
}

// GL_APPLE_flush_render

static void REGAL_CALL http_glFinishRenderAPPLE(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFinishRenderAPPLE)();
#endif
}

static void REGAL_CALL http_glFlushRenderAPPLE(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFlushRenderAPPLE)();
#endif
}

static void REGAL_CALL http_glSwapAPPLE(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSwapAPPLE)();
#endif
}

// GL_APPLE_framebuffer_multisample

static void REGAL_CALL http_glRenderbufferStorageMultisampleAPPLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRenderbufferStorageMultisampleAPPLE)(target, samples, internalformat, width, height);
#endif
}

static void REGAL_CALL http_glResolveMultisampleFramebufferAPPLE(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glResolveMultisampleFramebufferAPPLE)();
#endif
}

// GL_APPLE_object_purgeable

static void REGAL_CALL http_glGetObjectParameterivAPPLE(GLenum objectType, GLuint name, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetObjectParameterivAPPLE)(objectType, name, pname, params);
#endif
}

static GLenum REGAL_CALL http_glObjectPurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
    GLenum  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glObjectPurgeableAPPLE)(objectType, name, option);
#endif
    return ret;
}

static GLenum REGAL_CALL http_glObjectUnpurgeableAPPLE(GLenum objectType, GLuint name, GLenum option)
{
    GLenum  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glObjectUnpurgeableAPPLE)(objectType, name, option);
#endif
    return ret;
}

// GL_APPLE_sync

static GLenum REGAL_CALL http_glClientWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
    GLenum  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glClientWaitSyncAPPLE)(sync, flags, timeout);
#endif
    return ret;
}

static void REGAL_CALL http_glDeleteSyncAPPLE(GLsync sync)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteSyncAPPLE)(sync);
#endif
}

static GLsync REGAL_CALL http_glFenceSyncAPPLE(GLenum condition, GLbitfield flags)
{
    GLsync  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glFenceSyncAPPLE)(condition, flags);
#endif
    return ret;
}

static void REGAL_CALL http_glGetInteger64vAPPLE(GLenum pname, GLint64 *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetInteger64vAPPLE)(pname, params);
#endif
}

static void REGAL_CALL http_glGetSyncivAPPLE(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetSyncivAPPLE)(sync, pname, bufSize, length, values);
#endif
}

static GLboolean REGAL_CALL http_glIsSyncAPPLE(GLsync sync)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsSyncAPPLE)(sync);
#endif
    return ret;
}

static void REGAL_CALL http_glWaitSyncAPPLE(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWaitSyncAPPLE)(sync, flags, timeout);
#endif
}

// GL_APPLE_texture_range

static void REGAL_CALL http_glGetTexParameterPointervAPPLE(GLenum target, GLenum pname, GLvoid **params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexParameterPointervAPPLE)(target, pname, params);
#endif
}

static void REGAL_CALL http_glTextureRangeAPPLE(GLenum target, GLsizei length, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureRangeAPPLE)(target, length, pointer);
#endif
}

// GL_APPLE_vertex_array_object

static void REGAL_CALL http_glBindVertexArrayAPPLE(GLuint array)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindVertexArrayAPPLE)(array);
#endif
}

static void REGAL_CALL http_glDeleteVertexArraysAPPLE(GLsizei n, const GLuint *arrays)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteVertexArraysAPPLE)(n, arrays);
#endif
}

static void REGAL_CALL http_glGenVertexArraysAPPLE(GLsizei n, GLuint *arrays)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenVertexArraysAPPLE)(n, arrays);
#endif
}

static GLboolean REGAL_CALL http_glIsVertexArrayAPPLE(GLuint array)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsVertexArrayAPPLE)(array);
#endif
    return ret;
}

// GL_APPLE_vertex_array_range

static void REGAL_CALL http_glFlushVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFlushVertexArrayRangeAPPLE)(length, pointer);
#endif
}

static void REGAL_CALL http_glVertexArrayParameteriAPPLE(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayParameteriAPPLE)(pname, param);
#endif
}

static void REGAL_CALL http_glVertexArrayRangeAPPLE(GLsizei length, GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayRangeAPPLE)(length, pointer);
#endif
}

// GL_APPLE_vertex_program_evaluators

static void REGAL_CALL http_glDisableVertexAttribAPPLE(GLuint index, GLenum pname)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisableVertexAttribAPPLE)(index, pname);
#endif
}

static void REGAL_CALL http_glEnableVertexAttribAPPLE(GLuint index, GLenum pname)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnableVertexAttribAPPLE)(index, pname);
#endif
}

static GLboolean REGAL_CALL http_glIsVertexAttribEnabledAPPLE(GLuint index, GLenum pname)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsVertexAttribEnabledAPPLE)(index, pname);
#endif
    return ret;
}

static void REGAL_CALL http_glMapVertexAttrib1dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMapVertexAttrib1dAPPLE)(index, size, u1, u2, stride, order, points);
#endif
}

static void REGAL_CALL http_glMapVertexAttrib1fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMapVertexAttrib1fAPPLE)(index, size, u1, u2, stride, order, points);
#endif
}

static void REGAL_CALL http_glMapVertexAttrib2dAPPLE(GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMapVertexAttrib2dAPPLE)(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
#endif
}

static void REGAL_CALL http_glMapVertexAttrib2fAPPLE(GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMapVertexAttrib2fAPPLE)(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
#endif
}

// GL_ARB_ES2_compatibility

static void REGAL_CALL http_glClearDepthf(GLclampf d)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearDepthf)(d);
#endif
}

static void REGAL_CALL http_glDepthRangef(GLclampf n, GLclampf f)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDepthRangef)(n, f);
#endif
}

static void REGAL_CALL http_glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetShaderPrecisionFormat)(shadertype, precisiontype, range, precision);
#endif
}

static void REGAL_CALL http_glReleaseShaderCompiler(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReleaseShaderCompiler)();
#endif
}

static void REGAL_CALL http_glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glShaderBinary)(count, shaders, binaryformat, binary, length);
#endif
}

// GL_ARB_ES3_1_compatibility

static void REGAL_CALL http_glMemoryBarrierByRegion(GLbitfield barriers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMemoryBarrierByRegion)(barriers);
#endif
}

// GL_ARB_base_instance

static void REGAL_CALL http_glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawArraysInstancedBaseInstance)(mode, first, count, primcount, baseinstance);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLuint baseinstance)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawElementsInstancedBaseInstance)(mode, count, type, indices, primcount, baseinstance);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawElementsInstancedBaseVertexBaseInstance)(mode, count, type, indices, primcount, basevertex, baseinstance);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

// GL_ARB_bindless_texture

static GLuint64 REGAL_CALL http_glGetImageHandleARB(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format)
{
    GLuint64  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetImageHandleARB)(texture, level, layered, layer, format);
#endif
    return ret;
}

static GLuint64 REGAL_CALL http_glGetTextureHandleARB(GLuint texture)
{
    GLuint64  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetTextureHandleARB)(texture);
#endif
    return ret;
}

static GLuint64 REGAL_CALL http_glGetTextureSamplerHandleARB(GLuint texture, GLuint sampler)
{
    GLuint64  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetTextureSamplerHandleARB)(texture, sampler);
#endif
    return ret;
}

static void REGAL_CALL http_glGetVertexAttribLui64vARB(GLuint index, GLenum pname, GLuint64EXT *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribLui64vARB)(index, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsImageHandleResidentARB(GLuint64 handle)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsImageHandleResidentARB)(handle);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glIsTextureHandleResidentARB(GLuint64 handle)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsTextureHandleResidentARB)(handle);
#endif
    return ret;
}

static void REGAL_CALL http_glMakeImageHandleNonResidentARB(GLuint64 handle)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMakeImageHandleNonResidentARB)(handle);
#endif
}

static void REGAL_CALL http_glMakeImageHandleResidentARB(GLuint64 handle, GLenum access)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMakeImageHandleResidentARB)(handle, access);
#endif
}

static void REGAL_CALL http_glMakeTextureHandleNonResidentARB(GLuint64 handle)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMakeTextureHandleNonResidentARB)(handle);
#endif
}

static void REGAL_CALL http_glMakeTextureHandleResidentARB(GLuint64 handle)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMakeTextureHandleResidentARB)(handle);
#endif
}

static void REGAL_CALL http_glProgramUniformHandleui64ARB(GLuint program, GLint location, GLuint64 value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformHandleui64ARB)(program, location, value);
#endif
}

static void REGAL_CALL http_glProgramUniformHandleui64vARB(GLuint program, GLint location, GLsizei count, const GLuint64 *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformHandleui64vARB)(program, location, count, values);
#endif
}

static void REGAL_CALL http_glUniformHandleui64ARB(GLint location, GLuint64 value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformHandleui64ARB)(location, value);
#endif
}

static void REGAL_CALL http_glUniformHandleui64vARB(GLint location, GLsizei count, const GLuint64 *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformHandleui64vARB)(location, count, value);
#endif
}

static void REGAL_CALL http_glVertexAttribL1ui64ARB(GLuint index, GLuint64EXT x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL1ui64ARB)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttribL1ui64vARB(GLuint index, const GLuint64EXT *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL1ui64vARB)(index, v);
#endif
}

// GL_ARB_blend_func_extended

static void REGAL_CALL http_glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindFragDataLocationIndexed)(program, colorNumber, index, name);
#endif
}

static GLint REGAL_CALL http_glGetFragDataIndex(GLuint program, const GLchar *name)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetFragDataIndex)(program, name);
#endif
    return ret;
}

// GL_ARB_buffer_storage

static void REGAL_CALL http_glBufferStorage(GLenum target, GLsizeiptr size, const GLvoid *data, GLbitfield flags)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBufferStorage)(target, size, data, flags);
#endif
}

static void REGAL_CALL http_glNamedBufferStorageEXT(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLbitfield flags)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedBufferStorageEXT)(buffer, size, data, flags);
#endif
}

// GL_ARB_cl_event

static GLsync REGAL_CALL http_glCreateSyncFromCLeventARB(cl_context context, cl_event event, GLbitfield flags)
{
    GLsync  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glCreateSyncFromCLeventARB)(context, event, flags);
#endif
    return ret;
}

// GL_ARB_clear_buffer_object

static void REGAL_CALL http_glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearBufferData)(target, internalformat, format, type, data);
#endif
}

static void REGAL_CALL http_glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearBufferSubData)(target, internalformat, offset, size, format, type, data);
#endif
}

static void REGAL_CALL http_glClearNamedBufferDataEXT(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearNamedBufferDataEXT)(buffer, internalformat, format, type, data);
#endif
}

static void REGAL_CALL http_glClearNamedBufferSubDataEXT(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearNamedBufferSubDataEXT)(buffer, internalformat, offset, size, format, type, data);
#endif
}

// GL_ARB_clear_texture

static void REGAL_CALL http_glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearTexImage)(texture, level, format, type, data);
#endif
}

static void REGAL_CALL http_glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearTexSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
#endif
}

// GL_ARB_clip_control

static void REGAL_CALL http_glClipControl(GLenum origin, GLenum depth)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClipControl)(origin, depth);
#endif
}

// GL_ARB_color_buffer_float

static void REGAL_CALL http_glClampColorARB(GLenum target, GLenum clamp)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClampColorARB)(target, clamp);
#endif
}

// GL_ARB_compute_shader

static void REGAL_CALL http_glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDispatchCompute)(num_groups_x, num_groups_y, num_groups_z);
#endif
}

static void REGAL_CALL http_glDispatchComputeIndirect(GLintptr indirect)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDispatchComputeIndirect)(indirect);
#endif
}

// GL_ARB_compute_variable_group_size

static void REGAL_CALL http_glDispatchComputeGroupSizeARB(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDispatchComputeGroupSizeARB)(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
#endif
}

// GL_ARB_copy_buffer

static void REGAL_CALL http_glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyBufferSubData)(readtarget, writetarget, readoffset, writeoffset, size);
#endif
}

// GL_ARB_copy_image

static void REGAL_CALL http_glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyImageSubData)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
#endif
}

// GL_ARB_debug_output

static void REGAL_CALL http_glDebugMessageCallbackARB(GLDEBUGPROCARB callback, const void *userParam)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDebugMessageCallbackARB)(callback, userParam);
#endif
}

static void REGAL_CALL http_glDebugMessageControlARB(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDebugMessageControlARB)(source, type, severity, count, ids, enabled);
#endif
}

static void REGAL_CALL http_glDebugMessageInsertARB(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDebugMessageInsertARB)(source, type, id, severity, length, buf);
#endif
}

static GLuint REGAL_CALL http_glGetDebugMessageLogARB(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetDebugMessageLogARB)(count, bufsize, sources, types, ids, severities, lengths, messageLog);
#endif
    return ret;
}

// GL_ARB_direct_state_access

static void REGAL_CALL http_glBindTextureUnit(GLuint unit, GLuint texture)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindTextureUnit)(unit, texture);
#endif
}

static void REGAL_CALL http_glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlitNamedFramebuffer)(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
#endif
}

static GLenum REGAL_CALL http_glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target)
{
    GLenum  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glCheckNamedFramebufferStatus)(framebuffer, target);
#endif
    return ret;
}

static void REGAL_CALL http_glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearNamedBufferData)(buffer, internalformat, format, type, data);
#endif
}

static void REGAL_CALL http_glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearNamedBufferSubData)(buffer, internalformat, offset, size, format, type, data);
#endif
}

static void REGAL_CALL http_glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, GLfloat depth, GLint stencil)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearNamedFramebufferfi)(framebuffer, buffer, depth, stencil);
#endif
}

static void REGAL_CALL http_glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearNamedFramebufferfv)(framebuffer, buffer, drawbuffer, value);
#endif
}

static void REGAL_CALL http_glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearNamedFramebufferiv)(framebuffer, buffer, drawbuffer, value);
#endif
}

static void REGAL_CALL http_glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearNamedFramebufferuiv)(framebuffer, buffer, drawbuffer, value);
#endif
}

static void REGAL_CALL http_glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTextureSubImage1D)(texture, level, xoffset, width, format, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTextureSubImage2D)(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTextureSubImage3D)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
#endif
}

static void REGAL_CALL http_glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyNamedBufferSubData)(readBuffer, writeBuffer, readOffset, writeOffset, size);
#endif
}

static void REGAL_CALL http_glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTextureSubImage1D)(texture, level, xoffset, x, y, width);
#endif
}

static void REGAL_CALL http_glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTextureSubImage2D)(texture, level, xoffset, yoffset, x, y, width, height);
#endif
}

static void REGAL_CALL http_glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTextureSubImage3D)(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
#endif
}

static void REGAL_CALL http_glCreateBuffers(GLsizei n, GLuint *buffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCreateBuffers)(n, buffers);
#endif
}

static void REGAL_CALL http_glCreateFramebuffers(GLsizei n, GLuint *framebuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCreateFramebuffers)(n, framebuffers);
#endif
}

static void REGAL_CALL http_glCreateProgramPipelines(GLsizei n, GLuint *pipelines)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCreateProgramPipelines)(n, pipelines);
#endif
}

static void REGAL_CALL http_glCreateQueries(GLenum target, GLsizei n, GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCreateQueries)(target, n, ids);
#endif
}

static void REGAL_CALL http_glCreateRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCreateRenderbuffers)(n, renderbuffers);
#endif
}

static void REGAL_CALL http_glCreateSamplers(GLsizei n, GLuint *samplers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCreateSamplers)(n, samplers);
#endif
}

static void REGAL_CALL http_glCreateTextures(GLenum target, GLsizei n, GLuint *textures)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCreateTextures)(target, n, textures);
#endif
}

static void REGAL_CALL http_glCreateTransformFeedbacks(GLsizei n, GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCreateTransformFeedbacks)(n, ids);
#endif
}

static void REGAL_CALL http_glCreateVertexArrays(GLsizei n, GLuint *arrays)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCreateVertexArrays)(n, arrays);
#endif
}

static void REGAL_CALL http_glDisableVertexArrayAttrib(GLuint vaobj, GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisableVertexArrayAttrib)(vaobj, index);
#endif
}

static void REGAL_CALL http_glEnableVertexArrayAttrib(GLuint vaobj, GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnableVertexArrayAttrib)(vaobj, index);
#endif
}

static void REGAL_CALL http_glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFlushMappedNamedBufferRange)(buffer, offset, length);
#endif
}

static void REGAL_CALL http_glGenerateTextureMipmap(GLuint texture)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenerateTextureMipmap)(texture);
#endif
}

static void REGAL_CALL http_glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetCompressedTextureImage)(texture, level, bufSize, pixels);
#endif
}

static void REGAL_CALL http_glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64 *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedBufferParameteri64v)(buffer, pname, params);
#endif
}

static void REGAL_CALL http_glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedBufferParameteriv)(buffer, pname, params);
#endif
}

static void REGAL_CALL http_glGetNamedBufferPointerv(GLuint buffer, GLenum pname, GLvoid **params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedBufferPointerv)(buffer, pname, params);
#endif
}

static void REGAL_CALL http_glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedBufferSubData)(buffer, offset, size, data);
#endif
}

static void REGAL_CALL http_glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedFramebufferAttachmentParameteriv)(framebuffer, attachment, pname, params);
#endif
}

static void REGAL_CALL http_glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedFramebufferParameteriv)(framebuffer, pname, param);
#endif
}

static void REGAL_CALL http_glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedRenderbufferParameteriv)(renderbuffer, pname, params);
#endif
}

static void REGAL_CALL http_glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureImage)(texture, level, format, type, bufSize, pixels);
#endif
}

static void REGAL_CALL http_glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureLevelParameterfv)(texture, level, pname, params);
#endif
}

static void REGAL_CALL http_glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureLevelParameteriv)(texture, level, pname, params);
#endif
}

static void REGAL_CALL http_glGetTextureParameterIiv(GLuint texture, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureParameterIiv)(texture, pname, params);
#endif
}

static void REGAL_CALL http_glGetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureParameterIuiv)(texture, pname, params);
#endif
}

static void REGAL_CALL http_glGetTextureParameterfv(GLuint texture, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureParameterfv)(texture, pname, params);
#endif
}

static void REGAL_CALL http_glGetTextureParameteriv(GLuint texture, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureParameteriv)(texture, pname, params);
#endif
}

static void REGAL_CALL http_glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64 *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTransformFeedbacki64_v)(xfb, pname, index, param);
#endif
}

static void REGAL_CALL http_glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTransformFeedbacki_v)(xfb, pname, index, param);
#endif
}

static void REGAL_CALL http_glGetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTransformFeedbackiv)(xfb, pname, param);
#endif
}

static void REGAL_CALL http_glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexArrayIndexed64iv)(vaobj, index, pname, param);
#endif
}

static void REGAL_CALL http_glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexArrayIndexediv)(vaobj, index, pname, param);
#endif
}

static void REGAL_CALL http_glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexArrayiv)(vaobj, pname, param);
#endif
}

static void REGAL_CALL http_glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInvalidateNamedFramebufferData)(framebuffer, numAttachments, attachments);
#endif
}

static void REGAL_CALL http_glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInvalidateNamedFramebufferSubData)(framebuffer, numAttachments, attachments, x, y, width, height);
#endif
}

static GLvoid *REGAL_CALL http_glMapNamedBuffer(GLuint buffer, GLenum access)
{
    GLvoid * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glMapNamedBuffer)(buffer, access);
#endif
    return ret;
}

static GLvoid *REGAL_CALL http_glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
    GLvoid * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glMapNamedBufferRange)(buffer, offset, length, access);
#endif
    return ret;
}

static void REGAL_CALL http_glNamedBufferData(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedBufferData)(buffer, size, data, usage);
#endif
}

static void REGAL_CALL http_glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLbitfield flags)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedBufferStorage)(buffer, size, data, flags);
#endif
}

static void REGAL_CALL http_glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedBufferSubData)(buffer, offset, size, data);
#endif
}

static void REGAL_CALL http_glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferDrawBuffer)(framebuffer, mode);
#endif
}

static void REGAL_CALL http_glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum *bufs)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferDrawBuffers)(framebuffer, n, bufs);
#endif
}

static void REGAL_CALL http_glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferParameteri)(framebuffer, pname, param);
#endif
}

static void REGAL_CALL http_glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferReadBuffer)(framebuffer, mode);
#endif
}

static void REGAL_CALL http_glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferRenderbuffer)(framebuffer, attachment, renderbuffertarget, renderbuffer);
#endif
}

static void REGAL_CALL http_glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferTexture)(framebuffer, attachment, texture, level);
#endif
}

static void REGAL_CALL http_glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferTextureLayer)(framebuffer, attachment, texture, level, layer);
#endif
}

static void REGAL_CALL http_glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedRenderbufferStorage)(renderbuffer, internalformat, width, height);
#endif
}

static void REGAL_CALL http_glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedRenderbufferStorageMultisample)(renderbuffer, samples, internalformat, width, height);
#endif
}

static void REGAL_CALL http_glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureBuffer)(texture, internalformat, buffer);
#endif
}

static void REGAL_CALL http_glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureBufferRange)(texture, internalformat, buffer, offset, size);
#endif
}

static void REGAL_CALL http_glTextureParameterIiv(GLuint texture, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureParameterIiv)(texture, pname, params);
#endif
}

static void REGAL_CALL http_glTextureParameterIuiv(GLuint texture, GLenum pname, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureParameterIuiv)(texture, pname, params);
#endif
}

static void REGAL_CALL http_glTextureParameterf(GLuint texture, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureParameterf)(texture, pname, param);
#endif
}

static void REGAL_CALL http_glTextureParameterfv(GLuint texture, GLenum pname, const GLfloat *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureParameterfv)(texture, pname, param);
#endif
}

static void REGAL_CALL http_glTextureParameteri(GLuint texture, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureParameteri)(texture, pname, param);
#endif
}

static void REGAL_CALL http_glTextureParameteriv(GLuint texture, GLenum pname, const GLint *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureParameteriv)(texture, pname, param);
#endif
}

static void REGAL_CALL http_glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureStorage1D)(texture, levels, internalformat, width);
#endif
}

static void REGAL_CALL http_glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureStorage2D)(texture, levels, internalformat, width, height);
#endif
}

static void REGAL_CALL http_glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureStorage2DMultisample)(texture, samples, internalformat, width, height, fixedsamplelocations);
#endif
}

static void REGAL_CALL http_glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureStorage3D)(texture, levels, internalformat, width, height, depth);
#endif
}

static void REGAL_CALL http_glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureStorage3DMultisample)(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
#endif
}

static void REGAL_CALL http_glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureSubImage1D)(texture, level, xoffset, width, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureSubImage2D)(texture, level, xoffset, yoffset, width, height, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureSubImage3D)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTransformFeedbackBufferBase)(xfb, index, buffer);
#endif
}

static void REGAL_CALL http_glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTransformFeedbackBufferRange)(xfb, index, buffer, offset, size);
#endif
}

static GLboolean REGAL_CALL http_glUnmapNamedBuffer(GLuint buffer)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glUnmapNamedBuffer)(buffer);
#endif
    return ret;
}

static void REGAL_CALL http_glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayAttribBinding)(vaobj, attribindex, bindingindex);
#endif
}

static void REGAL_CALL http_glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayAttribFormat)(vaobj, attribindex, size, type, normalized, relativeoffset);
#endif
}

static void REGAL_CALL http_glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayAttribIFormat)(vaobj, attribindex, size, type, relativeoffset);
#endif
}

static void REGAL_CALL http_glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayAttribLFormat)(vaobj, attribindex, size, type, relativeoffset);
#endif
}

static void REGAL_CALL http_glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayBindingDivisor)(vaobj, bindingindex, divisor);
#endif
}

static void REGAL_CALL http_glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayElementBuffer)(vaobj, buffer);
#endif
}

static void REGAL_CALL http_glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayVertexBuffer)(vaobj, bindingindex, buffer, offset, stride);
#endif
}

static void REGAL_CALL http_glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayVertexBuffers)(vaobj, first, count, buffers, offsets, strides);
#endif
}

// GL_ARB_draw_buffers

static void REGAL_CALL http_glDrawBuffersARB(GLsizei n, const GLenum *bufs)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawBuffersARB)(n, bufs);
#endif
}

// GL_ARB_draw_buffers_blend

static void REGAL_CALL http_glBlendEquationSeparateiARB(GLuint buf, GLenum modeRGB, GLenum modeAlpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendEquationSeparateiARB)(buf, modeRGB, modeAlpha);
#endif
}

static void REGAL_CALL http_glBlendEquationiARB(GLuint buf, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendEquationiARB)(buf, mode);
#endif
}

static void REGAL_CALL http_glBlendFuncSeparateiARB(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendFuncSeparateiARB)(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
#endif
}

static void REGAL_CALL http_glBlendFunciARB(GLuint buf, GLenum src, GLenum dst)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendFunciARB)(buf, src, dst);
#endif
}

// GL_ARB_draw_elements_base_vertex

static void REGAL_CALL http_glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawElementsBaseVertex)(mode, count, type, indices, basevertex);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount, GLint basevertex)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawElementsInstancedBaseVertex)(mode, count, type, indices, primcount, basevertex);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawRangeElementsBaseVertex)(mode, start, end, count, type, indices, basevertex);
#endif
}

static void REGAL_CALL http_glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, const GLint *basevertex)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiDrawElementsBaseVertex)(mode, count, type, indices, primcount, basevertex);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

// GL_ARB_draw_indirect

static void REGAL_CALL http_glDrawArraysIndirect(GLenum mode, const GLvoid *indirect)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawArraysIndirect)(mode, indirect);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawElementsIndirect)(mode, type, indirect);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

// GL_ARB_draw_instanced

static void REGAL_CALL http_glDrawArraysInstancedARB(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawArraysInstancedARB)(mode, start, count, primcount);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glDrawElementsInstancedARB(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawElementsInstancedARB)(mode, count, type, indices, primcount);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

// GL_ARB_framebuffer_no_attachments

static void REGAL_CALL http_glFramebufferParameteri(GLenum target, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferParameteri)(target, pname, param);
#endif
}

static void REGAL_CALL http_glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFramebufferParameteriv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetNamedFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedFramebufferParameterivEXT)(framebuffer, pname, params);
#endif
}

static void REGAL_CALL http_glNamedFramebufferParameteriEXT(GLuint framebuffer, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferParameteriEXT)(framebuffer, pname, param);
#endif
}

// GL_ARB_framebuffer_object

static void REGAL_CALL http_glBindFramebuffer(GLenum target, GLuint framebuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.fbo[ framebuffer ] = HttpFboInfo( framebuffer );
      _context->http.count.fbo++;
      if( _context->http.runState == RS_NextFbo ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindFramebuffer)(target, framebuffer);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastFbo = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glBindRenderbuffer(GLenum target, GLuint renderbuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindRenderbuffer)(target, renderbuffer);
#endif
}

static void REGAL_CALL http_glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlitFramebuffer)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
#endif
}

static GLenum REGAL_CALL http_glCheckFramebufferStatus(GLenum target)
{
    GLenum  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glCheckFramebufferStatus)(target);
#endif
    return ret;
}

static void REGAL_CALL http_glDeleteFramebuffers(GLsizei n, const GLuint *framebuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteFramebuffers)(n, framebuffers);
#endif
}

static void REGAL_CALL http_glDeleteRenderbuffers(GLsizei n, const GLuint *renderbuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteRenderbuffers)(n, renderbuffers);
#endif
}

static void REGAL_CALL http_glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferRenderbuffer)(target, attachment, renderbuffertarget, renderbuffer);
#endif
}

static void REGAL_CALL http_glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTexture1D)(target, attachment, textarget, texture, level);
#endif
}

static void REGAL_CALL http_glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTexture2D)(target, attachment, textarget, texture, level);
#endif
}

static void REGAL_CALL http_glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTexture3D)(target, attachment, textarget, texture, level, layer);
#endif
}

static void REGAL_CALL http_glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTextureLayer)(target, attachment, texture, level, layer);
#endif
}

static void REGAL_CALL http_glGenFramebuffers(GLsizei n, GLuint *framebuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenFramebuffers)(n, framebuffers);
#endif
}

static void REGAL_CALL http_glGenRenderbuffers(GLsizei n, GLuint *renderbuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenRenderbuffers)(n, renderbuffers);
#endif
}

static void REGAL_CALL http_glGenerateMipmap(GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenerateMipmap)(target);
#endif
}

static void REGAL_CALL http_glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFramebufferAttachmentParameteriv)(target, attachment, pname, params);
#endif
}

static void REGAL_CALL http_glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetRenderbufferParameteriv)(target, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsFramebuffer(GLuint framebuffer)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsFramebuffer)(framebuffer);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glIsRenderbuffer(GLuint renderbuffer)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsRenderbuffer)(renderbuffer);
#endif
    return ret;
}

static void REGAL_CALL http_glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRenderbufferStorage)(target, internalformat, width, height);
#endif
}

static void REGAL_CALL http_glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRenderbufferStorageMultisample)(target, samples, internalformat, width, height);
#endif
}

// GL_ARB_geometry_shader4

static void REGAL_CALL http_glFramebufferTextureARB(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTextureARB)(target, attachment, texture, level);
#endif
}

static void REGAL_CALL http_glFramebufferTextureFaceARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTextureFaceARB)(target, attachment, texture, level, face);
#endif
}

static void REGAL_CALL http_glFramebufferTextureLayerARB(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTextureLayerARB)(target, attachment, texture, level, layer);
#endif
}

static void REGAL_CALL http_glProgramParameteriARB(GLuint program, GLenum pname, GLint value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramParameteriARB)(program, pname, value);
#endif
}

// GL_ARB_get_program_binary

static void REGAL_CALL http_glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramBinary)(program, bufSize, length, binaryFormat, binary);
#endif
}

static void REGAL_CALL http_glProgramBinary(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramBinary)(program, binaryFormat, binary, length);
#endif
}

static void REGAL_CALL http_glProgramParameteri(GLuint program, GLenum pname, GLint value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramParameteri)(program, pname, value);
#endif
}

// GL_ARB_get_texture_sub_image

static void REGAL_CALL http_glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetCompressedTextureSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
#endif
}

static void REGAL_CALL http_glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
#endif
}

// GL_ARB_gpu_shader_fp64

static void REGAL_CALL http_glGetUniformdv(GLuint program, GLint location, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetUniformdv)(program, location, params);
#endif
}

static void REGAL_CALL http_glUniform1d(GLint location, GLdouble x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1d)(location, x);
#endif
}

static void REGAL_CALL http_glUniform1dv(GLint location, GLsizei count, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1dv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform2d(GLint location, GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2d)(location, x, y);
#endif
}

static void REGAL_CALL http_glUniform2dv(GLint location, GLsizei count, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2dv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3d)(location, x, y, z);
#endif
}

static void REGAL_CALL http_glUniform3dv(GLint location, GLsizei count, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3dv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4d)(location, x, y, z, w);
#endif
}

static void REGAL_CALL http_glUniform4dv(GLint location, GLsizei count, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4dv)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix2dv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix2x3dv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix2x4dv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix3dv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix3x2dv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix3x4dv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix4dv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix4x2dv)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix4x3dv)(location, count, transpose, value);
#endif
}

// GL_ARB_imaging

static void REGAL_CALL http_glColorSubTable(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorSubTable)(target, start, count, format, type, data);
#endif
}

static void REGAL_CALL http_glColorTable(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorTable)(target, internalformat, width, format, type, table);
#endif
}

static void REGAL_CALL http_glColorTableParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorTableParameterfv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glColorTableParameteriv(GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorTableParameteriv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glConvolutionFilter1D(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glConvolutionFilter1D)(target, internalformat, width, format, type, image);
#endif
}

static void REGAL_CALL http_glConvolutionFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glConvolutionFilter2D)(target, internalformat, width, height, format, type, image);
#endif
}

static void REGAL_CALL http_glConvolutionParameterf(GLenum target, GLenum pname, GLfloat params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glConvolutionParameterf)(target, pname, params);
#endif
}

static void REGAL_CALL http_glConvolutionParameterfv(GLenum target, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glConvolutionParameterfv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glConvolutionParameteri(GLenum target, GLenum pname, GLint params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glConvolutionParameteri)(target, pname, params);
#endif
}

static void REGAL_CALL http_glConvolutionParameteriv(GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glConvolutionParameteriv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glCopyColorSubTable(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyColorSubTable)(target, start, x, y, width);
#endif
}

static void REGAL_CALL http_glCopyColorTable(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyColorTable)(target, internalformat, x, y, width);
#endif
}

static void REGAL_CALL http_glCopyConvolutionFilter1D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyConvolutionFilter1D)(target, internalformat, x, y, width);
#endif
}

static void REGAL_CALL http_glCopyConvolutionFilter2D(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyConvolutionFilter2D)(target, internalformat, x, y, width, height);
#endif
}

static void REGAL_CALL http_glGetColorTable(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetColorTable)(target, format, type, table);
#endif
}

static void REGAL_CALL http_glGetColorTableParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetColorTableParameterfv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetColorTableParameteriv(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetColorTableParameteriv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetConvolutionFilter(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetConvolutionFilter)(target, format, type, image);
#endif
}

static void REGAL_CALL http_glGetConvolutionParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetConvolutionParameterfv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetConvolutionParameteriv(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetConvolutionParameteriv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetHistogram)(target, reset, format, type, values);
#endif
}

static void REGAL_CALL http_glGetHistogramParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetHistogramParameterfv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetHistogramParameteriv(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetHistogramParameteriv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetMinmax(GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMinmax)(target, reset, format, types, values);
#endif
}

static void REGAL_CALL http_glGetMinmaxParameterfv(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMinmaxParameterfv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetMinmaxParameteriv(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMinmaxParameteriv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetSeparableFilter(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetSeparableFilter)(target, format, type, row, column, span);
#endif
}

static void REGAL_CALL http_glHistogram(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glHistogram)(target, width, internalformat, sink);
#endif
}

static void REGAL_CALL http_glMinmax(GLenum target, GLenum internalformat, GLboolean sink)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMinmax)(target, internalformat, sink);
#endif
}

static void REGAL_CALL http_glResetHistogram(GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glResetHistogram)(target);
#endif
}

static void REGAL_CALL http_glResetMinmax(GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glResetMinmax)(target);
#endif
}

static void REGAL_CALL http_glSeparableFilter2D(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSeparableFilter2D)(target, internalformat, width, height, format, type, row, column);
#endif
}

// GL_ARB_indirect_parameters

static void REGAL_CALL http_glMultiDrawArraysIndirectCountARB(GLenum mode, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiDrawArraysIndirectCountARB)(mode, indirect, drawcount, maxdrawcount, stride);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glMultiDrawElementsIndirectCountARB(GLenum mode, GLenum type, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiDrawElementsIndirectCountARB)(mode, type, indirect, drawcount, maxdrawcount, stride);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

// GL_ARB_instanced_arrays

static void REGAL_CALL http_glVertexAttribDivisorARB(GLuint index, GLuint divisor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribDivisorARB)(index, divisor);
#endif
}

// GL_ARB_internalformat_query

static void REGAL_CALL http_glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetInternalformativ)(target, internalformat, pname, bufSize, params);
#endif
}

// GL_ARB_internalformat_query2

static void REGAL_CALL http_glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetInternalformati64v)(target, internalformat, pname, bufSize, params);
#endif
}

// GL_ARB_invalidate_subdata

static void REGAL_CALL http_glInvalidateBufferData(GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInvalidateBufferData)(buffer);
#endif
}

static void REGAL_CALL http_glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInvalidateBufferSubData)(buffer, offset, length);
#endif
}

static void REGAL_CALL http_glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInvalidateFramebuffer)(target, numAttachments, attachments);
#endif
}

static void REGAL_CALL http_glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInvalidateSubFramebuffer)(target, numAttachments, attachments, x, y, width, height);
#endif
}

static void REGAL_CALL http_glInvalidateTexImage(GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInvalidateTexImage)(texture, level);
#endif
}

static void REGAL_CALL http_glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInvalidateTexSubImage)(texture, level, xoffset, yoffset, zoffset, width, height, depth);
#endif
}

// GL_ARB_map_buffer_range

static void REGAL_CALL http_glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFlushMappedBufferRange)(target, offset, length);
#endif
}

static GLvoid *REGAL_CALL http_glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
    GLvoid * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glMapBufferRange)(target, offset, length, access);
#endif
    return ret;
}

// GL_ARB_matrix_palette

static void REGAL_CALL http_glCurrentPaletteMatrixARB(GLint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCurrentPaletteMatrixARB)(index);
#endif
}

static void REGAL_CALL http_glMatrixIndexPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixIndexPointerARB)(size, type, stride, pointer);
#endif
}

static void REGAL_CALL http_glMatrixIndexubvARB(GLint size, const GLubyte *indices)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixIndexubvARB)(size, indices);
#endif
}

static void REGAL_CALL http_glMatrixIndexuivARB(GLint size, const GLuint *indices)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixIndexuivARB)(size, indices);
#endif
}

static void REGAL_CALL http_glMatrixIndexusvARB(GLint size, const GLushort *indices)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixIndexusvARB)(size, indices);
#endif
}

// GL_ARB_multi_bind

static void REGAL_CALL http_glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint *buffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindBuffersBase)(target, first, count, buffers);
#endif
}

static void REGAL_CALL http_glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindBuffersRange)(target, first, count, buffers, offsets, sizes);
#endif
}

static void REGAL_CALL http_glBindImageTextures(GLuint first, GLsizei count, const GLuint *textures)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindImageTextures)(first, count, textures);
#endif
}

static void REGAL_CALL http_glBindSamplers(GLuint first, GLsizei count, const GLuint *samplers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindSamplers)(first, count, samplers);
#endif
}

static void REGAL_CALL http_glBindTextures(GLuint first, GLsizei count, const GLuint *textures)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      if( textures != NULL ) {
        for( int i = 0; i < count; i++ ) {
          if( textures[i] != 0 ) {
            HttpTextureInfo & hti = _context->http.texture[ textures[i] ];
            RegalAssert( hti.name == 0 || hti.name == textures[i] );
            if( hti.name == 0 ) {
              hti.name = textures[i];
              hti.target = first;
            }
          }
        }
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindTextures)(first, count, textures);
#endif
}

static void REGAL_CALL http_glBindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindVertexBuffers)(first, count, buffers, offsets, strides);
#endif
}

// GL_ARB_multi_draw_indirect

static void REGAL_CALL http_glMultiDrawArraysIndirect(GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiDrawArraysIndirect)(mode, indirect, primcount, stride);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glMultiDrawElementsIndirect(GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiDrawElementsIndirect)(mode, type, indirect, primcount, stride);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

// GL_ARB_multisample

static void REGAL_CALL http_glSampleCoverageARB(GLclampf value, GLboolean invert)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSampleCoverageARB)(value, invert);
#endif
}

// GL_ARB_multitexture

static void REGAL_CALL http_glActiveTextureARB(GLenum texture)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glActiveTextureARB)(texture);
#endif
}

static void REGAL_CALL http_glClientActiveTextureARB(GLenum texture)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClientActiveTextureARB)(texture);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1dARB(GLenum target, GLdouble s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1dARB)(target, s);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1dvARB(GLenum target, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1dvARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1fARB(GLenum target, GLfloat s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1fARB)(target, s);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1fvARB(GLenum target, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1fvARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1iARB(GLenum target, GLint s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1iARB)(target, s);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1ivARB(GLenum target, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1ivARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1sARB(GLenum target, GLshort s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1sARB)(target, s);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1svARB(GLenum target, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1svARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2dARB(GLenum target, GLdouble s, GLdouble t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2dARB)(target, s, t);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2dvARB(GLenum target, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2dvARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2fARB(GLenum target, GLfloat s, GLfloat t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2fARB)(target, s, t);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2fvARB(GLenum target, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2fvARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2iARB(GLenum target, GLint s, GLint t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2iARB)(target, s, t);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2ivARB(GLenum target, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2ivARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2sARB(GLenum target, GLshort s, GLshort t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2sARB)(target, s, t);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2svARB(GLenum target, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2svARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3dARB)(target, s, t, r);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3dvARB(GLenum target, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3dvARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3fARB)(target, s, t, r);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3fvARB(GLenum target, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3fvARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3iARB(GLenum target, GLint s, GLint t, GLint r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3iARB)(target, s, t, r);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3ivARB(GLenum target, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3ivARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3sARB(GLenum target, GLshort s, GLshort t, GLshort r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3sARB)(target, s, t, r);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3svARB(GLenum target, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3svARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4dARB(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4dARB)(target, s, t, r, q);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4dvARB(GLenum target, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4dvARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4fARB(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4fARB)(target, s, t, r, q);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4fvARB(GLenum target, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4fvARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4iARB(GLenum target, GLint s, GLint t, GLint r, GLint q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4iARB)(target, s, t, r, q);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4ivARB(GLenum target, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4ivARB)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4sARB(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4sARB)(target, s, t, r, q);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4svARB(GLenum target, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4svARB)(target, v);
#endif
}

// GL_ARB_occlusion_query

static void REGAL_CALL http_glBeginQueryARB(GLenum target, GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginQueryARB)(target, id);
#endif
}

static void REGAL_CALL http_glDeleteQueriesARB(GLsizei n, const GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteQueriesARB)(n, ids);
#endif
}

static void REGAL_CALL http_glEndQueryARB(GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndQueryARB)(target);
#endif
}

static void REGAL_CALL http_glGenQueriesARB(GLsizei n, GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenQueriesARB)(n, ids);
#endif
}

static void REGAL_CALL http_glGetQueryObjectivARB(GLuint id, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjectivARB)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetQueryObjectuivARB(GLuint id, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjectuivARB)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetQueryivARB(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryivARB)(target, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsQueryARB(GLuint id)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsQueryARB)(id);
#endif
    return ret;
}

// GL_ARB_point_parameters

static void REGAL_CALL http_glPointParameterfARB(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameterfARB)(pname, param);
#endif
}

static void REGAL_CALL http_glPointParameterfvARB(GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameterfvARB)(pname, params);
#endif
}

// GL_ARB_program_interface_query

static void REGAL_CALL http_glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramInterfaceiv)(program, programInterface, pname, params);
#endif
}

static GLuint REGAL_CALL http_glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar *name)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetProgramResourceIndex)(program, programInterface, name);
#endif
    return ret;
}

static GLint REGAL_CALL http_glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar *name)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetProgramResourceLocation)(program, programInterface, name);
#endif
    return ret;
}

static GLint REGAL_CALL http_glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar *name)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetProgramResourceLocationIndex)(program, programInterface, name);
#endif
    return ret;
}

static void REGAL_CALL http_glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramResourceName)(program, programInterface, index, bufSize, length, name);
#endif
}

static void REGAL_CALL http_glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei bufSize, GLsizei *length, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramResourceiv)(program, programInterface, index, propCount, props, bufSize, length, params);
#endif
}

// GL_ARB_provoking_vertex

static void REGAL_CALL http_glProvokingVertex(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProvokingVertex)(mode);
#endif
}

// GL_ARB_robustness

static GLenum REGAL_CALL http_glGetGraphicsResetStatusARB(void)
{
    GLenum  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetGraphicsResetStatusARB)();
#endif
    return ret;
}

static void REGAL_CALL http_glGetnColorTableARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *table)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnColorTableARB)(target, format, type, bufSize, table);
#endif
}

static void REGAL_CALL http_glGetnCompressedTexImageARB(GLenum target, GLint lod, GLsizei bufSize, GLvoid *img)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnCompressedTexImageARB)(target, lod, bufSize, img);
#endif
}

static void REGAL_CALL http_glGetnConvolutionFilterARB(GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *image)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnConvolutionFilterARB)(target, format, type, bufSize, image);
#endif
}

static void REGAL_CALL http_glGetnHistogramARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnHistogramARB)(target, reset, format, type, bufSize, values);
#endif
}

static void REGAL_CALL http_glGetnMapdvARB(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnMapdvARB)(target, query, bufSize, v);
#endif
}

static void REGAL_CALL http_glGetnMapfvARB(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnMapfvARB)(target, query, bufSize, v);
#endif
}

static void REGAL_CALL http_glGetnMapivARB(GLenum target, GLenum query, GLsizei bufSize, GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnMapivARB)(target, query, bufSize, v);
#endif
}

static void REGAL_CALL http_glGetnMinmaxARB(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnMinmaxARB)(target, reset, format, type, bufSize, values);
#endif
}

static void REGAL_CALL http_glGetnPixelMapfvARB(GLenum map, GLsizei bufSize, GLfloat *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnPixelMapfvARB)(map, bufSize, values);
#endif
}

static void REGAL_CALL http_glGetnPixelMapuivARB(GLenum map, GLsizei bufSize, GLuint *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnPixelMapuivARB)(map, bufSize, values);
#endif
}

static void REGAL_CALL http_glGetnPixelMapusvARB(GLenum map, GLsizei bufSize, GLushort *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnPixelMapusvARB)(map, bufSize, values);
#endif
}

static void REGAL_CALL http_glGetnPolygonStippleARB(GLsizei bufSize, GLubyte *pattern)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnPolygonStippleARB)(bufSize, pattern);
#endif
}

static void REGAL_CALL http_glGetnSeparableFilterARB(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *row, GLsizei columnBufSize, GLvoid *column, GLvoid *span)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnSeparableFilterARB)(target, format, type, rowBufSize, row, columnBufSize, column, span);
#endif
}

static void REGAL_CALL http_glGetnTexImageARB(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnTexImageARB)(target, level, format, type, bufSize, img);
#endif
}

static void REGAL_CALL http_glGetnUniformdvARB(GLuint program, GLint location, GLsizei bufSize, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnUniformdvARB)(program, location, bufSize, params);
#endif
}

static void REGAL_CALL http_glGetnUniformfvARB(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnUniformfvARB)(program, location, bufSize, params);
#endif
}

static void REGAL_CALL http_glGetnUniformivARB(GLuint program, GLint location, GLsizei bufSize, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnUniformivARB)(program, location, bufSize, params);
#endif
}

static void REGAL_CALL http_glGetnUniformuivARB(GLuint program, GLint location, GLsizei bufSize, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnUniformuivARB)(program, location, bufSize, params);
#endif
}

static void REGAL_CALL http_glReadnPixelsARB(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReadnPixelsARB)(x, y, width, height, format, type, bufSize, data);
#endif
}

// GL_ARB_sample_shading

static void REGAL_CALL http_glMinSampleShading(GLclampf value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMinSampleShading)(value);
#endif
}

static void REGAL_CALL http_glMinSampleShadingARB(GLclampf value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMinSampleShadingARB)(value);
#endif
}

// GL_ARB_sampler_objects

static void REGAL_CALL http_glBindSampler(GLuint unit, GLuint sampler)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindSampler)(unit, sampler);
#endif
}

static void REGAL_CALL http_glDeleteSamplers(GLsizei count, const GLuint *samplers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteSamplers)(count, samplers);
#endif
}

static void REGAL_CALL http_glGenSamplers(GLsizei count, GLuint *samplers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenSamplers)(count, samplers);
#endif
}

static void REGAL_CALL http_glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetSamplerParameterIiv)(sampler, pname, params);
#endif
}

static void REGAL_CALL http_glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetSamplerParameterIuiv)(sampler, pname, params);
#endif
}

static void REGAL_CALL http_glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetSamplerParameterfv)(sampler, pname, params);
#endif
}

static void REGAL_CALL http_glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetSamplerParameteriv)(sampler, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsSampler(GLuint sampler)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsSampler)(sampler);
#endif
    return ret;
}

static void REGAL_CALL http_glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSamplerParameterIiv)(sampler, pname, params);
#endif
}

static void REGAL_CALL http_glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSamplerParameterIuiv)(sampler, pname, params);
#endif
}

static void REGAL_CALL http_glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSamplerParameterf)(sampler, pname, param);
#endif
}

static void REGAL_CALL http_glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSamplerParameterfv)(sampler, pname, params);
#endif
}

static void REGAL_CALL http_glSamplerParameteri(GLuint sampler, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSamplerParameteri)(sampler, pname, param);
#endif
}

static void REGAL_CALL http_glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSamplerParameteriv)(sampler, pname, params);
#endif
}

// GL_ARB_separate_shader_objects

static void REGAL_CALL http_glActiveShaderProgram(GLuint pipeline, GLuint program)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glActiveShaderProgram)(pipeline, program);
#endif
}

static void REGAL_CALL http_glBindProgramPipeline(GLuint pipeline)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindProgramPipeline)(pipeline);
#endif
}

static GLuint REGAL_CALL http_glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar * const *strings)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glCreateShaderProgramv)(type, count, strings);
#endif
    return ret;
}

static void REGAL_CALL http_glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteProgramPipelines)(n, pipelines);
#endif
}

static void REGAL_CALL http_glGenProgramPipelines(GLsizei n, GLuint *pipelines)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenProgramPipelines)(n, pipelines);
#endif
}

static void REGAL_CALL http_glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramPipelineInfoLog)(pipeline, bufSize, length, infoLog);
#endif
}

static void REGAL_CALL http_glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramPipelineiv)(pipeline, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsProgramPipeline(GLuint pipeline)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsProgramPipeline)(pipeline);
#endif
    return ret;
}

static void REGAL_CALL http_glProgramUniform1d(GLuint program, GLint location, GLdouble x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1d)(program, location, x);
#endif
}

static void REGAL_CALL http_glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1dv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform1f(GLuint program, GLint location, GLfloat x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1f)(program, location, x);
#endif
}

static void REGAL_CALL http_glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1fv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform1i(GLuint program, GLint location, GLint x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1i)(program, location, x);
#endif
}

static void REGAL_CALL http_glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1iv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform1ui(GLuint program, GLint location, GLuint v0)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1ui)(program, location, v0);
#endif
}

static void REGAL_CALL http_glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1uiv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform2d(GLuint program, GLint location, GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2d)(program, location, x, y);
#endif
}

static void REGAL_CALL http_glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2dv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform2f(GLuint program, GLint location, GLfloat x, GLfloat y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2f)(program, location, x, y);
#endif
}

static void REGAL_CALL http_glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2fv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform2i(GLuint program, GLint location, GLint x, GLint y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2i)(program, location, x, y);
#endif
}

static void REGAL_CALL http_glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2iv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform2ui(GLuint program, GLint location, GLuint x, GLuint y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2ui)(program, location, x, y);
#endif
}

static void REGAL_CALL http_glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2uiv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform3d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3d)(program, location, x, y, z);
#endif
}

static void REGAL_CALL http_glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3dv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform3f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3f)(program, location, x, y, z);
#endif
}

static void REGAL_CALL http_glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3fv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform3i(GLuint program, GLint location, GLint x, GLint y, GLint z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3i)(program, location, x, y, z);
#endif
}

static void REGAL_CALL http_glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3iv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform3ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3ui)(program, location, x, y, z);
#endif
}

static void REGAL_CALL http_glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3uiv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform4d(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4d)(program, location, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4dv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform4f(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4f)(program, location, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4fv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform4i(GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4i)(program, location, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4iv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform4ui(GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4ui)(program, location, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4uiv)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix2dv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix2fv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix2x3dv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix2x3fv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix2x4dv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix2x4fv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix3dv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix3fv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix3x2dv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix3x2fv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix3x4dv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix3x4fv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix4dv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix4fv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix4x2dv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix4x2fv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix4x3dv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix4x3fv)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUseProgramStages)(pipeline, stages, program);
#endif
}

static void REGAL_CALL http_glValidateProgramPipeline(GLuint pipeline)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glValidateProgramPipeline)(pipeline);
#endif
}

// GL_ARB_shader_atomic_counters

static void REGAL_CALL http_glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetActiveAtomicCounterBufferiv)(program, bufferIndex, pname, params);
#endif
}

// GL_ARB_shader_image_load_store

static void REGAL_CALL http_glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindImageTexture)(unit, texture, level, layered, layer, access, format);
#endif
}

static void REGAL_CALL http_glMemoryBarrier(GLbitfield barriers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMemoryBarrier)(barriers);
#endif
}

// GL_ARB_shader_objects

static void REGAL_CALL http_glAttachObjectARB(GLhandleARB containerObj, GLhandleARB obj)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glAttachObjectARB)(containerObj, obj);
#endif
}

static void REGAL_CALL http_glCompileShaderARB(GLhandleARB shaderObj)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompileShaderARB)(shaderObj);
#endif
}

static GLhandleARB REGAL_CALL http_glCreateProgramObjectARB(void)
{
    GLhandleARB  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glCreateProgramObjectARB)();
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.program.insert( ret );
      #endif
    }
    return ret;
}

static GLhandleARB REGAL_CALL http_glCreateShaderObjectARB(GLenum shaderType)
{
    GLhandleARB  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glCreateShaderObjectARB)(shaderType);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.shader.insert( ret );
      #endif
    }
    return ret;
}

static void REGAL_CALL http_glDeleteObjectARB(GLhandleARB obj)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteObjectARB)(obj);
#endif
}

static void REGAL_CALL http_glDetachObjectARB(GLhandleARB containerObj, GLhandleARB attachedObj)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDetachObjectARB)(containerObj, attachedObj);
#endif
}

static void REGAL_CALL http_glGetActiveUniformARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetActiveUniformARB)(programObj, index, maxLength, length, size, type, name);
#endif
}

static void REGAL_CALL http_glGetAttachedObjectsARB(GLhandleARB containerObj, GLsizei maxCount, GLsizei *count, GLhandleARB *obj)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetAttachedObjectsARB)(containerObj, maxCount, count, obj);
#endif
}

static GLhandleARB REGAL_CALL http_glGetHandleARB(GLenum pname)
{
    GLhandleARB  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetHandleARB)(pname);
#endif
    return ret;
}

static void REGAL_CALL http_glGetInfoLogARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *infoLog)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetInfoLogARB)(obj, maxLength, length, infoLog);
#endif
}

static void REGAL_CALL http_glGetObjectParameterfvARB(GLhandleARB obj, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetObjectParameterfvARB)(obj, pname, params);
#endif
}

static void REGAL_CALL http_glGetObjectParameterivARB(GLhandleARB obj, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetObjectParameterivARB)(obj, pname, params);
#endif
}

static void REGAL_CALL http_glGetShaderSourceARB(GLhandleARB obj, GLsizei maxLength, GLsizei *length, GLcharARB *source)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetShaderSourceARB)(obj, maxLength, length, source);
#endif
}

static GLint REGAL_CALL http_glGetUniformLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetUniformLocationARB)(programObj, name);
#endif
    return ret;
}

static void REGAL_CALL http_glGetUniformfvARB(GLhandleARB programObj, GLint location, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetUniformfvARB)(programObj, location, params);
#endif
}

static void REGAL_CALL http_glGetUniformivARB(GLhandleARB programObj, GLint location, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetUniformivARB)(programObj, location, params);
#endif
}

static void REGAL_CALL http_glLinkProgramARB(GLhandleARB programObj)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLinkProgramARB)(programObj);
#endif
}

static void REGAL_CALL http_glShaderSourceARB(GLhandleARB shaderObj, GLsizei count, const GLcharARB ** const string, const GLint *length)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glShaderSourceARB)(shaderObj, count, string, length);
#endif
}

static void REGAL_CALL http_glUniform1fARB(GLint location, GLfloat v0)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1fARB)(location, v0);
#endif
}

static void REGAL_CALL http_glUniform1fvARB(GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1fvARB)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform1iARB(GLint location, GLint v0)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1iARB)(location, v0);
#endif
}

static void REGAL_CALL http_glUniform1ivARB(GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1ivARB)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform2fARB(GLint location, GLfloat v0, GLfloat v1)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2fARB)(location, v0, v1);
#endif
}

static void REGAL_CALL http_glUniform2fvARB(GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2fvARB)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform2iARB(GLint location, GLint v0, GLint v1)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2iARB)(location, v0, v1);
#endif
}

static void REGAL_CALL http_glUniform2ivARB(GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2ivARB)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform3fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3fARB)(location, v0, v1, v2);
#endif
}

static void REGAL_CALL http_glUniform3fvARB(GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3fvARB)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform3iARB(GLint location, GLint v0, GLint v1, GLint v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3iARB)(location, v0, v1, v2);
#endif
}

static void REGAL_CALL http_glUniform3ivARB(GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3ivARB)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform4fARB(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4fARB)(location, v0, v1, v2, v3);
#endif
}

static void REGAL_CALL http_glUniform4fvARB(GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4fvARB)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform4iARB(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4iARB)(location, v0, v1, v2, v3);
#endif
}

static void REGAL_CALL http_glUniform4ivARB(GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4ivARB)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix2fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix2fvARB)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix3fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix3fvARB)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix4fvARB(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix4fvARB)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUseProgramObjectARB(GLhandleARB programObj)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUseProgramObjectARB)(programObj);
#endif
}

static void REGAL_CALL http_glValidateProgramARB(GLhandleARB programObj)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glValidateProgramARB)(programObj);
#endif
}

// GL_ARB_shader_storage_buffer_object

static void REGAL_CALL http_glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glShaderStorageBlockBinding)(program, storageBlockIndex, storageBlockBinding);
#endif
}

// GL_ARB_shader_subroutine

static void REGAL_CALL http_glGetActiveSubroutineName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetActiveSubroutineName)(program, shaderType, index, bufSize, length, name);
#endif
}

static void REGAL_CALL http_glGetActiveSubroutineUniformName(GLuint program, GLenum shaderType, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetActiveSubroutineUniformName)(program, shaderType, index, bufSize, length, name);
#endif
}

static void REGAL_CALL http_glGetActiveSubroutineUniformiv(GLuint program, GLenum shaderType, GLuint index, GLenum pname, GLint *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetActiveSubroutineUniformiv)(program, shaderType, index, pname, values);
#endif
}

static void REGAL_CALL http_glGetProgramStageiv(GLuint program, GLenum shaderType, GLenum pname, GLint *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramStageiv)(program, shaderType, pname, values);
#endif
}

static void REGAL_CALL http_glGetProgramSubroutineParameteruivNV(GLenum target, GLuint index, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramSubroutineParameteruivNV)(target, index, params);
#endif
}

static GLuint REGAL_CALL http_glGetSubroutineIndex(GLuint program, GLenum shaderType, const GLchar *name)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetSubroutineIndex)(program, shaderType, name);
#endif
    return ret;
}

static GLint REGAL_CALL http_glGetSubroutineUniformLocation(GLuint program, GLenum shaderType, const GLchar *name)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetSubroutineUniformLocation)(program, shaderType, name);
#endif
    return ret;
}

static void REGAL_CALL http_glGetUniformSubroutineuiv(GLenum shaderType, GLint location, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetUniformSubroutineuiv)(shaderType, location, params);
#endif
}

static void REGAL_CALL http_glProgramSubroutineParametersuivNV(GLenum target, GLsizei count, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramSubroutineParametersuivNV)(target, count, params);
#endif
}

static void REGAL_CALL http_glUniformSubroutinesuiv(GLenum shaderType, GLsizei count, const GLuint *indices)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformSubroutinesuiv)(shaderType, count, indices);
#endif
}

// GL_ARB_shading_language_include

static void REGAL_CALL http_glCompileShaderIncludeARB(GLuint shader, GLsizei count, const GLchar * const *path, const GLint *length)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompileShaderIncludeARB)(shader, count, path, length);
#endif
}

static void REGAL_CALL http_glDeleteNamedStringARB(GLint namelen, const GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteNamedStringARB)(namelen, name);
#endif
}

static void REGAL_CALL http_glGetNamedStringARB(GLint namelen, const GLchar *name, GLsizei bufSize, GLint *stringlen, GLchar *string)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedStringARB)(namelen, name, bufSize, stringlen, string);
#endif
}

static void REGAL_CALL http_glGetNamedStringivARB(GLint namelen, const GLchar *name, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedStringivARB)(namelen, name, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsNamedStringARB(GLint namelen, const GLchar *name)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsNamedStringARB)(namelen, name);
#endif
    return ret;
}

static void REGAL_CALL http_glNamedStringARB(GLenum type, GLint namelen, const GLchar *name, GLint stringlen, const GLchar *string)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedStringARB)(type, namelen, name, stringlen, string);
#endif
}

// GL_ARB_sparse_buffer

static void REGAL_CALL http_glBufferPageCommitmentARB(GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBufferPageCommitmentARB)(target, offset, size, commit);
#endif
}

// GL_ARB_sparse_texture

static void REGAL_CALL http_glTexPageCommitmentARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexPageCommitmentARB)(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
#endif
}

static void REGAL_CALL http_glTexturePageCommitmentEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexturePageCommitmentEXT)(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
#endif
}

// GL_ARB_sync

static GLenum REGAL_CALL http_glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
    GLenum  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glClientWaitSync)(sync, flags, timeout);
#endif
    return ret;
}

static void REGAL_CALL http_glDeleteSync(GLsync sync)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteSync)(sync);
#endif
}

static GLsync REGAL_CALL http_glFenceSync(GLenum condition, GLbitfield flags)
{
    GLsync  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glFenceSync)(condition, flags);
#endif
    return ret;
}

static void REGAL_CALL http_glGetInteger64v(GLenum pname, GLint64 *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetInteger64v)(pname, params);
#endif
}

static void REGAL_CALL http_glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetSynciv)(sync, pname, bufSize, length, values);
#endif
}

static GLboolean REGAL_CALL http_glIsSync(GLsync sync)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsSync)(sync);
#endif
    return ret;
}

static void REGAL_CALL http_glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWaitSync)(sync, flags, timeout);
#endif
}

// GL_ARB_tessellation_shader

static void REGAL_CALL http_glPatchParameterfv(GLenum pname, const GLfloat *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPatchParameterfv)(pname, values);
#endif
}

static void REGAL_CALL http_glPatchParameteri(GLenum pname, GLint value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPatchParameteri)(pname, value);
#endif
}

// GL_ARB_texture_barrier

static void REGAL_CALL http_glTextureBarrier(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureBarrier)();
#endif
}

// GL_ARB_texture_buffer_object

static void REGAL_CALL http_glTexBufferARB(GLenum target, GLenum internalformat, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexBufferARB)(target, internalformat, buffer);
#endif
}

// GL_ARB_texture_buffer_range

static void REGAL_CALL http_glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexBufferRange)(target, internalformat, buffer, offset, size);
#endif
}

static void REGAL_CALL http_glTextureBufferRangeEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureBufferRangeEXT)(texture, target, internalformat, buffer, offset, size);
#endif
}

// GL_ARB_texture_compression

static void REGAL_CALL http_glCompressedTexImage1DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexImage1DARB)(target, level, internalformat, width, border, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTexImage2DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexImage2DARB)(target, level, internalformat, width, height, border, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTexImage3DARB(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexImage3DARB)(target, level, internalformat, width, height, depth, border, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTexSubImage1DARB(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexSubImage1DARB)(target, level, xoffset, width, format, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTexSubImage2DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexSubImage2DARB)(target, level, xoffset, yoffset, width, height, format, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTexSubImage3DARB(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexSubImage3DARB)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
#endif
}

static void REGAL_CALL http_glGetCompressedTexImageARB(GLenum target, GLint lod, GLvoid *img)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetCompressedTexImageARB)(target, lod, img);
#endif
}

// GL_ARB_texture_multisample

static void REGAL_CALL http_glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultisamplefv)(pname, index, val);
#endif
}

static void REGAL_CALL http_glSampleMaski(GLuint index, GLbitfield mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSampleMaski)(index, mask);
#endif
}

static void REGAL_CALL http_glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexImage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations);
#endif
}

static void REGAL_CALL http_glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexImage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations);
#endif
}

// GL_ARB_texture_storage

static void REGAL_CALL http_glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexStorage1D)(target, levels, internalformat, width);
#endif
}

static void REGAL_CALL http_glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexStorage2D)(target, levels, internalformat, width, height);
#endif
}

static void REGAL_CALL http_glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexStorage3D)(target, levels, internalformat, width, height, depth);
#endif
}

static void REGAL_CALL http_glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureStorage1DEXT)(texture, target, levels, internalformat, width);
#endif
}

static void REGAL_CALL http_glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureStorage2DEXT)(texture, target, levels, internalformat, width, height);
#endif
}

static void REGAL_CALL http_glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureStorage3DEXT)(texture, target, levels, internalformat, width, height, depth);
#endif
}

// GL_ARB_texture_storage_multisample

static void REGAL_CALL http_glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexStorage2DMultisample)(target, samples, internalformat, width, height, fixedsamplelocations);
#endif
}

static void REGAL_CALL http_glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexStorage3DMultisample)(target, samples, internalformat, width, height, depth, fixedsamplelocations);
#endif
}

static void REGAL_CALL http_glTextureStorage2DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureStorage2DMultisampleEXT)(texture, target, samples, internalformat, width, height, fixedsamplelocations);
#endif
}

static void REGAL_CALL http_glTextureStorage3DMultisampleEXT(GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureStorage3DMultisampleEXT)(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
#endif
}

// GL_ARB_texture_view

static void REGAL_CALL http_glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureView)(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
#endif
}

// GL_ARB_timer_query

static void REGAL_CALL http_glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjecti64v)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjectui64v)(id, pname, params);
#endif
}

static void REGAL_CALL http_glQueryCounter(GLuint id, GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glQueryCounter)(id, target);
#endif
}

// GL_ARB_transform_feedback2

static void REGAL_CALL http_glBindTransformFeedback(GLenum target, GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindTransformFeedback)(target, id);
#endif
}

static void REGAL_CALL http_glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteTransformFeedbacks)(n, ids);
#endif
}

static void REGAL_CALL http_glDrawTransformFeedback(GLenum mode, GLuint name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawTransformFeedback)(mode, name);
#endif
}

static void REGAL_CALL http_glGenTransformFeedbacks(GLsizei n, GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenTransformFeedbacks)(n, ids);
#endif
}

static GLboolean REGAL_CALL http_glIsTransformFeedback(GLuint id)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsTransformFeedback)(id);
#endif
    return ret;
}

static void REGAL_CALL http_glPauseTransformFeedback(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPauseTransformFeedback)();
#endif
}

static void REGAL_CALL http_glResumeTransformFeedback(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glResumeTransformFeedback)();
#endif
}

// GL_ARB_transform_feedback3

static void REGAL_CALL http_glBeginQueryIndexed(GLenum target, GLuint index, GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginQueryIndexed)(target, index, id);
#endif
}

static void REGAL_CALL http_glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawTransformFeedbackStream)(mode, id, stream);
#endif
}

static void REGAL_CALL http_glEndQueryIndexed(GLenum target, GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndQueryIndexed)(target, index);
#endif
}

static void REGAL_CALL http_glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryIndexediv)(target, index, pname, params);
#endif
}

// GL_ARB_transform_feedback_instanced

static void REGAL_CALL http_glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawTransformFeedbackInstanced)(mode, id, primcount);
#endif
}

static void REGAL_CALL http_glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawTransformFeedbackStreamInstanced)(mode, id, stream, primcount);
#endif
}

// GL_ARB_transpose_matrix

static void REGAL_CALL http_glLoadTransposeMatrixdARB(const GLdouble *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLoadTransposeMatrixdARB)(m);
#endif
}

static void REGAL_CALL http_glLoadTransposeMatrixfARB(const GLfloat *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLoadTransposeMatrixfARB)(m);
#endif
}

static void REGAL_CALL http_glMultTransposeMatrixdARB(const GLdouble *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultTransposeMatrixdARB)(m);
#endif
}

static void REGAL_CALL http_glMultTransposeMatrixfARB(const GLfloat *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultTransposeMatrixfARB)(m);
#endif
}

// GL_ARB_uniform_buffer_object

static void REGAL_CALL http_glBindBufferBase(GLenum target, GLuint index, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindBufferBase)(target, index, buffer);
#endif
}

static void REGAL_CALL http_glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindBufferRange)(target, index, buffer, offset, size);
#endif
}

static void REGAL_CALL http_glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetActiveUniformBlockName)(program, uniformBlockIndex, bufSize, length, uniformBlockName);
#endif
}

static void REGAL_CALL http_glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetActiveUniformBlockiv)(program, uniformBlockIndex, pname, params);
#endif
}

static void REGAL_CALL http_glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetActiveUniformName)(program, uniformIndex, bufSize, length, uniformName);
#endif
}

static void REGAL_CALL http_glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetActiveUniformsiv)(program, uniformCount, uniformIndices, pname, params);
#endif
}

static void REGAL_CALL http_glGetIntegeri_v(GLenum target, GLuint index, GLint *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetIntegeri_v)(target, index, data);
#endif
}

static GLuint REGAL_CALL http_glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetUniformBlockIndex)(program, uniformBlockName);
#endif
    return ret;
}

static void REGAL_CALL http_glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar * const *uniformNames, GLuint *uniformIndices)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetUniformIndices)(program, uniformCount, uniformNames, uniformIndices);
#endif
}

static void REGAL_CALL http_glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformBlockBinding)(program, uniformBlockIndex, uniformBlockBinding);
#endif
}

// GL_ARB_vertex_array_object

static void REGAL_CALL http_glBindVertexArray(GLuint array)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindVertexArray)(array);
#endif
}

static void REGAL_CALL http_glDeleteVertexArrays(GLsizei n, const GLuint *arrays)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteVertexArrays)(n, arrays);
#endif
}

static void REGAL_CALL http_glGenVertexArrays(GLsizei n, GLuint *arrays)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenVertexArrays)(n, arrays);
#endif
}

static GLboolean REGAL_CALL http_glIsVertexArray(GLuint array)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsVertexArray)(array);
#endif
    return ret;
}

// GL_ARB_vertex_attrib_64bit

static void REGAL_CALL http_glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribLdv)(index, pname, params);
#endif
}

static void REGAL_CALL http_glVertexAttribL1d(GLuint index, GLdouble x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL1d)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttribL1dv(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL1dv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL2d)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttribL2dv(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL2dv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL3d)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttribL3dv(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL3dv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL4d)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttribL4dv(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL4dv)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribLPointer)(index, size, type, stride, pointer);
#endif
}

// GL_ARB_vertex_attrib_binding

static void REGAL_CALL http_glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindVertexBuffer)(bindingindex, buffer, offset, stride);
#endif
}

static void REGAL_CALL http_glVertexArrayBindVertexBufferEXT(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayBindVertexBufferEXT)(vaobj, bindingindex, buffer, offset, stride);
#endif
}

static void REGAL_CALL http_glVertexArrayVertexAttribBindingEXT(GLuint vaobj, GLuint attribindex, GLuint bindingindex)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayVertexAttribBindingEXT)(vaobj, attribindex, bindingindex);
#endif
}

static void REGAL_CALL http_glVertexArrayVertexAttribFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayVertexAttribFormatEXT)(vaobj, attribindex, size, type, normalized, relativeoffset);
#endif
}

static void REGAL_CALL http_glVertexArrayVertexAttribIFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayVertexAttribIFormatEXT)(vaobj, attribindex, size, type, relativeoffset);
#endif
}

static void REGAL_CALL http_glVertexArrayVertexAttribLFormatEXT(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayVertexAttribLFormatEXT)(vaobj, attribindex, size, type, relativeoffset);
#endif
}

static void REGAL_CALL http_glVertexArrayVertexBindingDivisorEXT(GLuint vaobj, GLuint bindingindex, GLuint divisor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayVertexBindingDivisorEXT)(vaobj, bindingindex, divisor);
#endif
}

static void REGAL_CALL http_glVertexAttribBinding(GLuint attribindex, GLuint bindingindex)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribBinding)(attribindex, bindingindex);
#endif
}

static void REGAL_CALL http_glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribFormat)(attribindex, size, type, normalized, relativeoffset);
#endif
}

static void REGAL_CALL http_glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribIFormat)(attribindex, size, type, relativeoffset);
#endif
}

static void REGAL_CALL http_glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribLFormat)(attribindex, size, type, relativeoffset);
#endif
}

static void REGAL_CALL http_glVertexBindingDivisor(GLuint bindingindex, GLuint divisor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexBindingDivisor)(bindingindex, divisor);
#endif
}

// GL_ARB_vertex_blend

static void REGAL_CALL http_glVertexBlendARB(GLint count)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexBlendARB)(count);
#endif
}

static void REGAL_CALL http_glWeightPointerARB(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWeightPointerARB)(size, type, stride, pointer);
#endif
}

static void REGAL_CALL http_glWeightbvARB(GLint size, const GLbyte *weights)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWeightbvARB)(size, weights);
#endif
}

static void REGAL_CALL http_glWeightdvARB(GLint size, const GLdouble *weights)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWeightdvARB)(size, weights);
#endif
}

static void REGAL_CALL http_glWeightfvARB(GLint size, const GLfloat *weights)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWeightfvARB)(size, weights);
#endif
}

static void REGAL_CALL http_glWeightivARB(GLint size, const GLint *weights)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWeightivARB)(size, weights);
#endif
}

static void REGAL_CALL http_glWeightsvARB(GLint size, const GLshort *weights)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWeightsvARB)(size, weights);
#endif
}

static void REGAL_CALL http_glWeightubvARB(GLint size, const GLubyte *weights)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWeightubvARB)(size, weights);
#endif
}

static void REGAL_CALL http_glWeightuivARB(GLint size, const GLuint *weights)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWeightuivARB)(size, weights);
#endif
}

static void REGAL_CALL http_glWeightusvARB(GLint size, const GLushort *weights)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWeightusvARB)(size, weights);
#endif
}

// GL_ARB_vertex_buffer_object

static void REGAL_CALL http_glBindBufferARB(GLenum target, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindBufferARB)(target, buffer);
#endif
}

static void REGAL_CALL http_glBufferDataARB(GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBufferDataARB)(target, size, data, usage);
#endif
}

static void REGAL_CALL http_glBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBufferSubDataARB)(target, offset, size, data);
#endif
}

static void REGAL_CALL http_glDeleteBuffersARB(GLsizei n, const GLuint *buffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteBuffersARB)(n, buffers);
#endif
}

static void REGAL_CALL http_glGenBuffersARB(GLsizei n, GLuint *buffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenBuffersARB)(n, buffers);
#endif
}

static void REGAL_CALL http_glGetBufferParameterivARB(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetBufferParameterivARB)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetBufferPointervARB(GLenum target, GLenum pname, GLvoid **params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetBufferPointervARB)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetBufferSubDataARB(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetBufferSubDataARB)(target, offset, size, data);
#endif
}

static GLboolean REGAL_CALL http_glIsBufferARB(GLuint buffer)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsBufferARB)(buffer);
#endif
    return ret;
}

static GLvoid *REGAL_CALL http_glMapBufferARB(GLenum target, GLenum access)
{
    GLvoid * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glMapBufferARB)(target, access);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glUnmapBufferARB(GLenum target)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glUnmapBufferARB)(target);
#endif
    return ret;
}

// GL_ARB_vertex_program

static void REGAL_CALL http_glBindProgramARB(GLenum target, GLuint program)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindProgramARB)(target, program);
#endif
}

static void REGAL_CALL http_glDeleteProgramsARB(GLsizei n, const GLuint *programs)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteProgramsARB)(n, programs);
#endif
}

static void REGAL_CALL http_glDisableVertexAttribArrayARB(GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisableVertexAttribArrayARB)(index);
#endif
}

static void REGAL_CALL http_glEnableVertexAttribArrayARB(GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnableVertexAttribArrayARB)(index);
#endif
}

static void REGAL_CALL http_glGenProgramsARB(GLsizei n, GLuint *programs)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenProgramsARB)(n, programs);
#endif
}

static void REGAL_CALL http_glGetProgramEnvParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramEnvParameterdvARB)(target, index, params);
#endif
}

static void REGAL_CALL http_glGetProgramEnvParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramEnvParameterfvARB)(target, index, params);
#endif
}

static void REGAL_CALL http_glGetProgramLocalParameterdvARB(GLenum target, GLuint index, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramLocalParameterdvARB)(target, index, params);
#endif
}

static void REGAL_CALL http_glGetProgramLocalParameterfvARB(GLenum target, GLuint index, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramLocalParameterfvARB)(target, index, params);
#endif
}

static void REGAL_CALL http_glGetProgramStringARB(GLenum target, GLenum pname, GLvoid *string)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramStringARB)(target, pname, string);
#endif
}

static void REGAL_CALL http_glGetProgramivARB(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramivARB)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribPointervARB(GLuint index, GLenum pname, GLvoid **pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribPointervARB)(index, pname, pointer);
#endif
}

static void REGAL_CALL http_glGetVertexAttribdvARB(GLuint index, GLenum pname, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribdvARB)(index, pname, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribfvARB(GLuint index, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribfvARB)(index, pname, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribivARB(GLuint index, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribivARB)(index, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsProgramARB(GLuint program)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsProgramARB)(program);
#endif
    return ret;
}

static void REGAL_CALL http_glProgramEnvParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramEnvParameter4dARB)(target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramEnvParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramEnvParameter4dvARB)(target, index, params);
#endif
}

static void REGAL_CALL http_glProgramEnvParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramEnvParameter4fARB)(target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramEnvParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramEnvParameter4fvARB)(target, index, params);
#endif
}

static void REGAL_CALL http_glProgramLocalParameter4dARB(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramLocalParameter4dARB)(target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramLocalParameter4dvARB(GLenum target, GLuint index, const GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramLocalParameter4dvARB)(target, index, params);
#endif
}

static void REGAL_CALL http_glProgramLocalParameter4fARB(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramLocalParameter4fARB)(target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramLocalParameter4fvARB(GLenum target, GLuint index, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramLocalParameter4fvARB)(target, index, params);
#endif
}

static void REGAL_CALL http_glProgramStringARB(GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramStringARB)(target, format, len, string);
#endif
}

static void REGAL_CALL http_glVertexAttrib1dARB(GLuint index, GLdouble x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1dARB)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttrib1dvARB(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1dvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib1fARB(GLuint index, GLfloat x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1fARB)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttrib1fvARB(GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1fvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib1sARB(GLuint index, GLshort x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1sARB)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttrib1svARB(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1svARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib2dARB(GLuint index, GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2dARB)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttrib2dvARB(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2dvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib2fARB(GLuint index, GLfloat x, GLfloat y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2fARB)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttrib2fvARB(GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2fvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib2sARB(GLuint index, GLshort x, GLshort y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2sARB)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttrib2svARB(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2svARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib3dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3dARB)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttrib3dvARB(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3dvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib3fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3fARB)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttrib3fvARB(GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3fvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib3sARB(GLuint index, GLshort x, GLshort y, GLshort z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3sARB)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttrib3svARB(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3svARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4NbvARB(GLuint index, const GLbyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4NbvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4NivARB(GLuint index, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4NivARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4NsvARB(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4NsvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4NubARB(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4NubARB)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttrib4NubvARB(GLuint index, const GLubyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4NubvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4NuivARB(GLuint index, const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4NuivARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4NusvARB(GLuint index, const GLushort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4NusvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4bvARB(GLuint index, const GLbyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4bvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4dARB(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4dARB)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttrib4dvARB(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4dvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4fARB(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4fARB)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttrib4fvARB(GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4fvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4ivARB(GLuint index, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4ivARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4sARB(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4sARB)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttrib4svARB(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4svARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4ubvARB(GLuint index, const GLubyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4ubvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4uivARB(GLuint index, const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4uivARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4usvARB(GLuint index, const GLushort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4usvARB)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribPointerARB(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribPointerARB)(index, size, type, normalized, stride, pointer);
#endif
}

// GL_ARB_vertex_shader

static void REGAL_CALL http_glBindAttribLocationARB(GLhandleARB programObj, GLuint index, const GLcharARB *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindAttribLocationARB)(programObj, index, name);
#endif
}

static void REGAL_CALL http_glGetActiveAttribARB(GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei *length, GLint *size, GLenum *type, GLcharARB *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetActiveAttribARB)(programObj, index, maxLength, length, size, type, name);
#endif
}

static GLint REGAL_CALL http_glGetAttribLocationARB(GLhandleARB programObj, const GLcharARB *name)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetAttribLocationARB)(programObj, name);
#endif
    return ret;
}

// GL_ARB_vertex_type_2_10_10_10_rev

static void REGAL_CALL http_glColorP3ui(GLenum type, GLuint color)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorP3ui)(type, color);
#endif
}

static void REGAL_CALL http_glColorP3uiv(GLenum type, const GLuint *color)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorP3uiv)(type, color);
#endif
}

static void REGAL_CALL http_glColorP4ui(GLenum type, GLuint color)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorP4ui)(type, color);
#endif
}

static void REGAL_CALL http_glColorP4uiv(GLenum type, const GLuint *color)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorP4uiv)(type, color);
#endif
}

static void REGAL_CALL http_glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoordP1ui)(texture, type, coords);
#endif
}

static void REGAL_CALL http_glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoordP1uiv)(texture, type, coords);
#endif
}

static void REGAL_CALL http_glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoordP2ui)(texture, type, coords);
#endif
}

static void REGAL_CALL http_glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoordP2uiv)(texture, type, coords);
#endif
}

static void REGAL_CALL http_glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoordP3ui)(texture, type, coords);
#endif
}

static void REGAL_CALL http_glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoordP3uiv)(texture, type, coords);
#endif
}

static void REGAL_CALL http_glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoordP4ui)(texture, type, coords);
#endif
}

static void REGAL_CALL http_glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoordP4uiv)(texture, type, coords);
#endif
}

static void REGAL_CALL http_glNormalP3ui(GLenum type, GLuint coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalP3ui)(type, coords);
#endif
}

static void REGAL_CALL http_glNormalP3uiv(GLenum type, const GLuint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalP3uiv)(type, coords);
#endif
}

static void REGAL_CALL http_glSecondaryColorP3ui(GLenum type, GLuint color)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColorP3ui)(type, color);
#endif
}

static void REGAL_CALL http_glSecondaryColorP3uiv(GLenum type, const GLuint *color)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColorP3uiv)(type, color);
#endif
}

static void REGAL_CALL http_glTexCoordP1ui(GLenum type, GLuint coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoordP1ui)(type, coords);
#endif
}

static void REGAL_CALL http_glTexCoordP1uiv(GLenum type, const GLuint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoordP1uiv)(type, coords);
#endif
}

static void REGAL_CALL http_glTexCoordP2ui(GLenum type, GLuint coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoordP2ui)(type, coords);
#endif
}

static void REGAL_CALL http_glTexCoordP2uiv(GLenum type, const GLuint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoordP2uiv)(type, coords);
#endif
}

static void REGAL_CALL http_glTexCoordP3ui(GLenum type, GLuint coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoordP3ui)(type, coords);
#endif
}

static void REGAL_CALL http_glTexCoordP3uiv(GLenum type, const GLuint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoordP3uiv)(type, coords);
#endif
}

static void REGAL_CALL http_glTexCoordP4ui(GLenum type, GLuint coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoordP4ui)(type, coords);
#endif
}

static void REGAL_CALL http_glTexCoordP4uiv(GLenum type, const GLuint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoordP4uiv)(type, coords);
#endif
}

static void REGAL_CALL http_glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribP1ui)(index, type, normalized, value);
#endif
}

static void REGAL_CALL http_glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribP1uiv)(index, type, normalized, value);
#endif
}

static void REGAL_CALL http_glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribP2ui)(index, type, normalized, value);
#endif
}

static void REGAL_CALL http_glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribP2uiv)(index, type, normalized, value);
#endif
}

static void REGAL_CALL http_glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribP3ui)(index, type, normalized, value);
#endif
}

static void REGAL_CALL http_glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribP3uiv)(index, type, normalized, value);
#endif
}

static void REGAL_CALL http_glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribP4ui)(index, type, normalized, value);
#endif
}

static void REGAL_CALL http_glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribP4uiv)(index, type, normalized, value);
#endif
}

static void REGAL_CALL http_glVertexP2ui(GLenum type, GLuint coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexP2ui)(type, coords);
#endif
}

static void REGAL_CALL http_glVertexP2uiv(GLenum type, const GLuint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexP2uiv)(type, coords);
#endif
}

static void REGAL_CALL http_glVertexP3ui(GLenum type, GLuint coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexP3ui)(type, coords);
#endif
}

static void REGAL_CALL http_glVertexP3uiv(GLenum type, const GLuint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexP3uiv)(type, coords);
#endif
}

static void REGAL_CALL http_glVertexP4ui(GLenum type, GLuint coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexP4ui)(type, coords);
#endif
}

static void REGAL_CALL http_glVertexP4uiv(GLenum type, const GLuint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexP4uiv)(type, coords);
#endif
}

// GL_ARB_viewport_array

static void REGAL_CALL http_glDepthRangeArrayv(GLuint first, GLsizei count, const GLclampd *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDepthRangeArrayv)(first, count, v);
#endif
}

static void REGAL_CALL http_glDepthRangeIndexed(GLuint index, GLclampd n, GLclampd f)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDepthRangeIndexed)(index, n, f);
#endif
}

static void REGAL_CALL http_glGetDoublei_v(GLenum target, GLuint index, GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetDoublei_v)(target, index, v);
#endif
}

static void REGAL_CALL http_glGetFloati_v(GLenum target, GLuint index, GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFloati_v)(target, index, v);
#endif
}

static void REGAL_CALL http_glScissorArrayv(GLuint first, GLsizei count, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glScissorArrayv)(first, count, v);
#endif
}

static void REGAL_CALL http_glScissorIndexed(GLuint index, GLint left, GLint bottom, GLint width, GLint height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glScissorIndexed)(index, left, bottom, width, height);
#endif
}

static void REGAL_CALL http_glScissorIndexedv(GLuint index, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glScissorIndexedv)(index, v);
#endif
}

static void REGAL_CALL http_glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glViewportArrayv)(first, count, v);
#endif
}

static void REGAL_CALL http_glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glViewportIndexedf)(index, x, y, w, h);
#endif
}

static void REGAL_CALL http_glViewportIndexedfv(GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glViewportIndexedfv)(index, v);
#endif
}

// GL_ARB_window_pos

static void REGAL_CALL http_glWindowPos2dARB(GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2dARB)(x, y);
#endif
}

static void REGAL_CALL http_glWindowPos2dvARB(const GLdouble *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2dvARB)(p);
#endif
}

static void REGAL_CALL http_glWindowPos2fARB(GLfloat x, GLfloat y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2fARB)(x, y);
#endif
}

static void REGAL_CALL http_glWindowPos2fvARB(const GLfloat *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2fvARB)(p);
#endif
}

static void REGAL_CALL http_glWindowPos2iARB(GLint x, GLint y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2iARB)(x, y);
#endif
}

static void REGAL_CALL http_glWindowPos2ivARB(const GLint *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2ivARB)(p);
#endif
}

static void REGAL_CALL http_glWindowPos2sARB(GLshort x, GLshort y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2sARB)(x, y);
#endif
}

static void REGAL_CALL http_glWindowPos2svARB(const GLshort *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2svARB)(p);
#endif
}

static void REGAL_CALL http_glWindowPos3dARB(GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3dARB)(x, y, z);
#endif
}

static void REGAL_CALL http_glWindowPos3dvARB(const GLdouble *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3dvARB)(p);
#endif
}

static void REGAL_CALL http_glWindowPos3fARB(GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3fARB)(x, y, z);
#endif
}

static void REGAL_CALL http_glWindowPos3fvARB(const GLfloat *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3fvARB)(p);
#endif
}

static void REGAL_CALL http_glWindowPos3iARB(GLint x, GLint y, GLint z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3iARB)(x, y, z);
#endif
}

static void REGAL_CALL http_glWindowPos3ivARB(const GLint *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3ivARB)(p);
#endif
}

static void REGAL_CALL http_glWindowPos3sARB(GLshort x, GLshort y, GLshort z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3sARB)(x, y, z);
#endif
}

static void REGAL_CALL http_glWindowPos3svARB(const GLshort *p)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3svARB)(p);
#endif
}

// GL_ATI_draw_buffers

static void REGAL_CALL http_glDrawBuffersATI(GLsizei n, const GLenum *bufs)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawBuffersATI)(n, bufs);
#endif
}

// GL_ATI_element_array

static void REGAL_CALL http_glDrawElementArrayATI(GLenum mode, GLsizei count)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawElementArrayATI)(mode, count);
#endif
}

static void REGAL_CALL http_glDrawRangeElementArrayATI(GLenum mode, GLuint start, GLuint end, GLsizei count)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawRangeElementArrayATI)(mode, start, end, count);
#endif
}

static void REGAL_CALL http_glElementPointerATI(GLenum type, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glElementPointerATI)(type, pointer);
#endif
}

// GL_ATI_envmap_bumpmap

static void REGAL_CALL http_glGetTexBumpParameterfvATI(GLenum pname, GLfloat *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexBumpParameterfvATI)(pname, param);
#endif
}

static void REGAL_CALL http_glGetTexBumpParameterivATI(GLenum pname, GLint *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexBumpParameterivATI)(pname, param);
#endif
}

static void REGAL_CALL http_glTexBumpParameterfvATI(GLenum pname, const GLfloat *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexBumpParameterfvATI)(pname, param);
#endif
}

static void REGAL_CALL http_glTexBumpParameterivATI(GLenum pname, const GLint *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexBumpParameterivATI)(pname, param);
#endif
}

// GL_ATI_fragment_shader

static void REGAL_CALL http_glAlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glAlphaFragmentOp1ATI)(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
#endif
}

static void REGAL_CALL http_glAlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glAlphaFragmentOp2ATI)(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
#endif
}

static void REGAL_CALL http_glAlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glAlphaFragmentOp3ATI)(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
#endif
}

static void REGAL_CALL http_glBeginFragmentShaderATI(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginFragmentShaderATI)();
#endif
}

static void REGAL_CALL http_glBindFragmentShaderATI(GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindFragmentShaderATI)(id);
#endif
}

static void REGAL_CALL http_glColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorFragmentOp1ATI)(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
#endif
}

static void REGAL_CALL http_glColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorFragmentOp2ATI)(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
#endif
}

static void REGAL_CALL http_glColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorFragmentOp3ATI)(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
#endif
}

static void REGAL_CALL http_glDeleteFragmentShaderATI(GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteFragmentShaderATI)(id);
#endif
}

static void REGAL_CALL http_glEndFragmentShaderATI(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndFragmentShaderATI)();
#endif
}

static GLuint REGAL_CALL http_glGenFragmentShadersATI(GLuint range)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGenFragmentShadersATI)(range);
#endif
    return ret;
}

static void REGAL_CALL http_glPassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPassTexCoordATI)(dst, coord, swizzle);
#endif
}

static void REGAL_CALL http_glSampleMapATI(GLuint dst, GLuint interp, GLenum swizzle)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSampleMapATI)(dst, interp, swizzle);
#endif
}

static void REGAL_CALL http_glSetFragmentShaderConstantATI(GLuint dst, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSetFragmentShaderConstantATI)(dst, value);
#endif
}

// GL_ATI_map_object_buffer

static GLvoid *REGAL_CALL http_glMapObjectBufferATI(GLuint buffer)
{
    GLvoid * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glMapObjectBufferATI)(buffer);
#endif
    return ret;
}

static void REGAL_CALL http_glUnmapObjectBufferATI(GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUnmapObjectBufferATI)(buffer);
#endif
}

// GL_ATI_pn_triangles

static void REGAL_CALL http_glPNTrianglesfATI(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPNTrianglesfATI)(pname, param);
#endif
}

static void REGAL_CALL http_glPNTrianglesiATI(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPNTrianglesiATI)(pname, param);
#endif
}

// GL_ATI_separate_stencil

static void REGAL_CALL http_glStencilFuncSeparateATI(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilFuncSeparateATI)(frontfunc, backfunc, ref, mask);
#endif
}

static void REGAL_CALL http_glStencilOpSeparateATI(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilOpSeparateATI)(face, sfail, dpfail, dppass);
#endif
}

// GL_ATI_vertex_array_object

static void REGAL_CALL http_glArrayObjectATI(GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glArrayObjectATI)(array, size, type, stride, buffer, offset);
#endif
}

static void REGAL_CALL http_glFreeObjectBufferATI(GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFreeObjectBufferATI)(buffer);
#endif
}

static void REGAL_CALL http_glGetArrayObjectfvATI(GLenum array, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetArrayObjectfvATI)(array, pname, params);
#endif
}

static void REGAL_CALL http_glGetArrayObjectivATI(GLenum array, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetArrayObjectivATI)(array, pname, params);
#endif
}

static void REGAL_CALL http_glGetObjectBufferfvATI(GLuint buffer, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetObjectBufferfvATI)(buffer, pname, params);
#endif
}

static void REGAL_CALL http_glGetObjectBufferivATI(GLuint buffer, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetObjectBufferivATI)(buffer, pname, params);
#endif
}

static void REGAL_CALL http_glGetVariantArrayObjectfvATI(GLuint id, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVariantArrayObjectfvATI)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetVariantArrayObjectivATI(GLuint id, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVariantArrayObjectivATI)(id, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsObjectBufferATI(GLuint buffer)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsObjectBufferATI)(buffer);
#endif
    return ret;
}

static GLuint REGAL_CALL http_glNewObjectBufferATI(GLsizei size, const GLvoid *pointer, GLenum usage)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glNewObjectBufferATI)(size, pointer, usage);
#endif
    return ret;
}

static void REGAL_CALL http_glUpdateObjectBufferATI(GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUpdateObjectBufferATI)(buffer, offset, size, pointer, preserve);
#endif
}

static void REGAL_CALL http_glVariantArrayObjectATI(GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVariantArrayObjectATI)(id, type, stride, buffer, offset);
#endif
}

// GL_ATI_vertex_attrib_array_object

static void REGAL_CALL http_glGetVertexAttribArrayObjectfvATI(GLuint index, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribArrayObjectfvATI)(index, pname, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribArrayObjectivATI(GLuint index, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribArrayObjectivATI)(index, pname, params);
#endif
}

static void REGAL_CALL http_glVertexAttribArrayObjectATI(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribArrayObjectATI)(index, size, type, normalized, stride, buffer, offset);
#endif
}

// GL_ATI_vertex_streams

static void REGAL_CALL http_glClientActiveVertexStreamATI(GLenum stream)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClientActiveVertexStreamATI)(stream);
#endif
}

static void REGAL_CALL http_glNormalStream3bATI(GLenum stream, GLbyte x, GLbyte y, GLbyte z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalStream3bATI)(stream, x, y, z);
#endif
}

static void REGAL_CALL http_glNormalStream3bvATI(GLenum stream, const GLbyte *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalStream3bvATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glNormalStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalStream3dATI)(stream, x, y, z);
#endif
}

static void REGAL_CALL http_glNormalStream3dvATI(GLenum stream, const GLdouble *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalStream3dvATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glNormalStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalStream3fATI)(stream, x, y, z);
#endif
}

static void REGAL_CALL http_glNormalStream3fvATI(GLenum stream, const GLfloat *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalStream3fvATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glNormalStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalStream3iATI)(stream, x, y, z);
#endif
}

static void REGAL_CALL http_glNormalStream3ivATI(GLenum stream, const GLint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalStream3ivATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glNormalStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalStream3sATI)(stream, x, y, z);
#endif
}

static void REGAL_CALL http_glNormalStream3svATI(GLenum stream, const GLshort *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalStream3svATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexBlendEnvfATI(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexBlendEnvfATI)(pname, param);
#endif
}

static void REGAL_CALL http_glVertexBlendEnviATI(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexBlendEnviATI)(pname, param);
#endif
}

static void REGAL_CALL http_glVertexStream1dATI(GLenum stream, GLdouble x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream1dATI)(stream, x);
#endif
}

static void REGAL_CALL http_glVertexStream1dvATI(GLenum stream, const GLdouble *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream1dvATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream1fATI(GLenum stream, GLfloat x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream1fATI)(stream, x);
#endif
}

static void REGAL_CALL http_glVertexStream1fvATI(GLenum stream, const GLfloat *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream1fvATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream1iATI(GLenum stream, GLint x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream1iATI)(stream, x);
#endif
}

static void REGAL_CALL http_glVertexStream1ivATI(GLenum stream, const GLint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream1ivATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream1sATI(GLenum stream, GLshort x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream1sATI)(stream, x);
#endif
}

static void REGAL_CALL http_glVertexStream1svATI(GLenum stream, const GLshort *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream1svATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream2dATI(GLenum stream, GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream2dATI)(stream, x, y);
#endif
}

static void REGAL_CALL http_glVertexStream2dvATI(GLenum stream, const GLdouble *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream2dvATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream2fATI(GLenum stream, GLfloat x, GLfloat y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream2fATI)(stream, x, y);
#endif
}

static void REGAL_CALL http_glVertexStream2fvATI(GLenum stream, const GLfloat *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream2fvATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream2iATI(GLenum stream, GLint x, GLint y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream2iATI)(stream, x, y);
#endif
}

static void REGAL_CALL http_glVertexStream2ivATI(GLenum stream, const GLint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream2ivATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream2sATI(GLenum stream, GLshort x, GLshort y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream2sATI)(stream, x, y);
#endif
}

static void REGAL_CALL http_glVertexStream2svATI(GLenum stream, const GLshort *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream2svATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream3dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream3dATI)(stream, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexStream3dvATI(GLenum stream, const GLdouble *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream3dvATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream3fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream3fATI)(stream, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexStream3fvATI(GLenum stream, const GLfloat *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream3fvATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream3iATI(GLenum stream, GLint x, GLint y, GLint z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream3iATI)(stream, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexStream3ivATI(GLenum stream, const GLint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream3ivATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream3sATI(GLenum stream, GLshort x, GLshort y, GLshort z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream3sATI)(stream, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexStream3svATI(GLenum stream, const GLshort *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream3svATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream4dATI(GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream4dATI)(stream, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexStream4dvATI(GLenum stream, const GLdouble *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream4dvATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream4fATI(GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream4fATI)(stream, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexStream4fvATI(GLenum stream, const GLfloat *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream4fvATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream4iATI(GLenum stream, GLint x, GLint y, GLint z, GLint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream4iATI)(stream, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexStream4ivATI(GLenum stream, const GLint *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream4ivATI)(stream, coords);
#endif
}

static void REGAL_CALL http_glVertexStream4sATI(GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream4sATI)(stream, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexStream4svATI(GLenum stream, const GLshort *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexStream4svATI)(stream, coords);
#endif
}

// GL_EXT_bindable_uniform

static GLint REGAL_CALL http_glGetUniformBufferSizeEXT(GLuint program, GLint location)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetUniformBufferSizeEXT)(program, location);
#endif
    return ret;
}

static GLintptr REGAL_CALL http_glGetUniformOffsetEXT(GLuint program, GLint location)
{
    GLintptr  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetUniformOffsetEXT)(program, location);
#endif
    return ret;
}

static void REGAL_CALL http_glUniformBufferEXT(GLuint program, GLint location, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformBufferEXT)(program, location, buffer);
#endif
}

// GL_EXT_blend_color

static void REGAL_CALL http_glBlendColorEXT(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendColorEXT)(red, green, blue, alpha);
#endif
}

// GL_EXT_blend_equation_separate

static void REGAL_CALL http_glBlendEquationSeparateEXT(GLenum modeRGB, GLenum modeAlpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendEquationSeparateEXT)(modeRGB, modeAlpha);
#endif
}

// GL_EXT_blend_func_separate

static void REGAL_CALL http_glBlendFuncSeparateEXT(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendFuncSeparateEXT)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
#endif
}

// GL_EXT_blend_minmax

static void REGAL_CALL http_glBlendEquationEXT(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendEquationEXT)(mode);
#endif
}

// GL_EXT_color_subtable

static void REGAL_CALL http_glColorSubTableEXT(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *table)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorSubTableEXT)(target, start, count, format, type, table);
#endif
}

static void REGAL_CALL http_glCopyColorSubTableEXT(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyColorSubTableEXT)(target, start, x, y, width);
#endif
}

// GL_EXT_compiled_vertex_array

static void REGAL_CALL http_glLockArraysEXT(GLint first, GLsizei count)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLockArraysEXT)(first, count);
#endif
}

static void REGAL_CALL http_glUnlockArraysEXT(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUnlockArraysEXT)();
#endif
}

// GL_EXT_convolution

static void REGAL_CALL http_glConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glConvolutionFilter1DEXT)(target, internalformat, width, format, type, image);
#endif
}

static void REGAL_CALL http_glConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glConvolutionFilter2DEXT)(target, internalformat, width, height, format, type, image);
#endif
}

static void REGAL_CALL http_glConvolutionParameterfEXT(GLenum target, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glConvolutionParameterfEXT)(target, pname, param);
#endif
}

static void REGAL_CALL http_glConvolutionParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glConvolutionParameterfvEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glConvolutionParameteriEXT(GLenum target, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glConvolutionParameteriEXT)(target, pname, param);
#endif
}

static void REGAL_CALL http_glConvolutionParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glConvolutionParameterivEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glCopyConvolutionFilter1DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyConvolutionFilter1DEXT)(target, internalformat, x, y, width);
#endif
}

static void REGAL_CALL http_glCopyConvolutionFilter2DEXT(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyConvolutionFilter2DEXT)(target, internalformat, x, y, width, height);
#endif
}

static void REGAL_CALL http_glGetConvolutionFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *image)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetConvolutionFilterEXT)(target, format, type, image);
#endif
}

static void REGAL_CALL http_glGetConvolutionParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetConvolutionParameterfvEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetConvolutionParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetConvolutionParameterivEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetSeparableFilterEXT(GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetSeparableFilterEXT)(target, format, type, row, column, span);
#endif
}

static void REGAL_CALL http_glSeparableFilter2DEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSeparableFilter2DEXT)(target, internalformat, width, height, format, type, row, column);
#endif
}

// GL_EXT_coordinate_frame

static void REGAL_CALL http_glBinormal3bEXT(GLbyte bx, GLbyte by, GLbyte bz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBinormal3bEXT)(bx, by, bz);
#endif
}

static void REGAL_CALL http_glBinormal3bvEXT(const GLbyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBinormal3bvEXT)(v);
#endif
}

static void REGAL_CALL http_glBinormal3dEXT(GLdouble bx, GLdouble by, GLdouble bz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBinormal3dEXT)(bx, by, bz);
#endif
}

static void REGAL_CALL http_glBinormal3dvEXT(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBinormal3dvEXT)(v);
#endif
}

static void REGAL_CALL http_glBinormal3fEXT(GLfloat bx, GLfloat by, GLfloat bz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBinormal3fEXT)(bx, by, bz);
#endif
}

static void REGAL_CALL http_glBinormal3fvEXT(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBinormal3fvEXT)(v);
#endif
}

static void REGAL_CALL http_glBinormal3iEXT(GLint bx, GLint by, GLint bz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBinormal3iEXT)(bx, by, bz);
#endif
}

static void REGAL_CALL http_glBinormal3ivEXT(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBinormal3ivEXT)(v);
#endif
}

static void REGAL_CALL http_glBinormal3sEXT(GLshort bx, GLshort by, GLshort bz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBinormal3sEXT)(bx, by, bz);
#endif
}

static void REGAL_CALL http_glBinormal3svEXT(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBinormal3svEXT)(v);
#endif
}

static void REGAL_CALL http_glBinormalPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBinormalPointerEXT)(type, stride, pointer);
#endif
}

static void REGAL_CALL http_glTangent3bEXT(GLbyte tx, GLbyte ty, GLbyte tz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTangent3bEXT)(tx, ty, tz);
#endif
}

static void REGAL_CALL http_glTangent3bvEXT(const GLbyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTangent3bvEXT)(v);
#endif
}

static void REGAL_CALL http_glTangent3dEXT(GLdouble tx, GLdouble ty, GLdouble tz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTangent3dEXT)(tx, ty, tz);
#endif
}

static void REGAL_CALL http_glTangent3dvEXT(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTangent3dvEXT)(v);
#endif
}

static void REGAL_CALL http_glTangent3fEXT(GLfloat tx, GLfloat ty, GLfloat tz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTangent3fEXT)(tx, ty, tz);
#endif
}

static void REGAL_CALL http_glTangent3fvEXT(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTangent3fvEXT)(v);
#endif
}

static void REGAL_CALL http_glTangent3iEXT(GLint tx, GLint ty, GLint tz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTangent3iEXT)(tx, ty, tz);
#endif
}

static void REGAL_CALL http_glTangent3ivEXT(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTangent3ivEXT)(v);
#endif
}

static void REGAL_CALL http_glTangent3sEXT(GLshort tx, GLshort ty, GLshort tz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTangent3sEXT)(tx, ty, tz);
#endif
}

static void REGAL_CALL http_glTangent3svEXT(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTangent3svEXT)(v);
#endif
}

static void REGAL_CALL http_glTangentPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTangentPointerEXT)(type, stride, pointer);
#endif
}

// GL_EXT_copy_texture

static void REGAL_CALL http_glCopyTexImage1DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTexImage1DEXT)(target, level, internalformat, x, y, width, border);
#endif
}

static void REGAL_CALL http_glCopyTexImage2DEXT(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTexImage2DEXT)(target, level, internalformat, x, y, width, height, border);
#endif
}

static void REGAL_CALL http_glCopyTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTexSubImage1DEXT)(target, level, xoffset, x, y, width);
#endif
}

static void REGAL_CALL http_glCopyTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTexSubImage2DEXT)(target, level, xoffset, yoffset, x, y, width, height);
#endif
}

static void REGAL_CALL http_glCopyTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTexSubImage3DEXT)(target, level, xoffset, yoffset, zoffset, x, y, width, height);
#endif
}

// GL_EXT_cull_vertex

static void REGAL_CALL http_glCullParameterdvEXT(GLenum pname, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCullParameterdvEXT)(pname, params);
#endif
}

static void REGAL_CALL http_glCullParameterfvEXT(GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCullParameterfvEXT)(pname, params);
#endif
}

// GL_EXT_debug_label

static void REGAL_CALL http_glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetObjectLabelEXT)(type, object, bufSize, length, label);
#endif
}

static void REGAL_CALL http_glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar *label)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLabelObjectEXT)(type, object, length, label);
#endif
}

// GL_EXT_debug_marker

static void REGAL_CALL http_glInsertEventMarkerEXT(GLsizei length, const GLchar *marker)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInsertEventMarkerEXT)(length, marker);
#endif
}

static void REGAL_CALL http_glPopGroupMarkerEXT(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPopGroupMarkerEXT)();
#endif
    if( _context ) {
      #if REGAL_HTTP
      DispatchHttpState &h = _context->http;
      if( h.runState == RS_StepOutOfGroup || h.runState == RS_NextGroup ) {
        h.runState = RS_Pause;
      }
      if( h.runState == RS_StepOverGroup && h.debugGroupStackDepth == h.stepOverGroupDepth ) {
        h.runState = RS_Pause;
      }
      h.debugGroupStackDepth--;
      #endif
    }
}

static void REGAL_CALL http_glPushGroupMarkerEXT(GLsizei length, const GLchar *marker)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.group++;
      if( _context->http.runState == RS_NextGroup ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.debugGroupStackDepth++;
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPushGroupMarkerEXT)(length, marker);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastGroup = _context->http.count.call;
      #endif
    }
}

// GL_EXT_depth_bounds_test

static void REGAL_CALL http_glDepthBoundsEXT(GLclampd zmin, GLclampd zmax)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDepthBoundsEXT)(zmin, zmax);
#endif
}

// GL_EXT_direct_state_access

static void REGAL_CALL http_glBindMultiTextureEXT(GLenum texunit, GLenum target, GLuint texture)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      if( texture != 0 ) {
        HttpTextureInfo & hti = _context->http.texture[ texture ];
        RegalAssert( hti.name == 0 || hti.name == texture );
        if( hti.name == 0 ) {
          hti.name = texture;
          hti.target = target;
        }
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindMultiTextureEXT)(texunit, target, texture);
#endif
}

static GLenum REGAL_CALL http_glCheckNamedFramebufferStatusEXT(GLuint framebuffer, GLenum target)
{
    GLenum  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glCheckNamedFramebufferStatusEXT)(framebuffer, target);
#endif
    return ret;
}

static void REGAL_CALL http_glClientAttribDefaultEXT(GLbitfield mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClientAttribDefaultEXT)(mask);
#endif
}

static void REGAL_CALL http_glCompressedMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedMultiTexImage1DEXT)(texunit, target, level, internalformat, width, border, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedMultiTexImage2DEXT)(texunit, target, level, internalformat, width, height, border, imageSize, bits);
#endif
}

static void REGAL_CALL http_glCompressedMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedMultiTexImage3DEXT)(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
#endif
}

static void REGAL_CALL http_glCompressedMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedMultiTexSubImage1DEXT)(texunit, target, level, xoffset, width, format, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedMultiTexSubImage2DEXT)(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedMultiTexSubImage3DEXT)(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTextureImage1DEXT)(texture, target, level, internalformat, width, border, imageSize, bits);
#endif
}

static void REGAL_CALL http_glCompressedTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTextureImage2DEXT)(texture, target, level, internalformat, width, height, border, imageSize, bits);
#endif
}

static void REGAL_CALL http_glCompressedTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTextureImage3DEXT)(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
#endif
}

static void REGAL_CALL http_glCompressedTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTextureSubImage1DEXT)(texture, target, level, xoffset, width, format, imageSize, bits);
#endif
}

static void REGAL_CALL http_glCompressedTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTextureSubImage2DEXT)(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
#endif
}

static void REGAL_CALL http_glCompressedTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTextureSubImage3DEXT)(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
#endif
}

static void REGAL_CALL http_glCopyMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyMultiTexImage1DEXT)(texunit, target, level, internalformat, x, y, width, border);
#endif
}

static void REGAL_CALL http_glCopyMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyMultiTexImage2DEXT)(texunit, target, level, internalformat, x, y, width, height, border);
#endif
}

static void REGAL_CALL http_glCopyMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyMultiTexSubImage1DEXT)(texunit, target, level, xoffset, x, y, width);
#endif
}

static void REGAL_CALL http_glCopyMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyMultiTexSubImage2DEXT)(texunit, target, level, xoffset, yoffset, x, y, width, height);
#endif
}

static void REGAL_CALL http_glCopyMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyMultiTexSubImage3DEXT)(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
#endif
}

static void REGAL_CALL http_glCopyTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTextureImage1DEXT)(texture, target, level, internalformat, x, y, width, border);
#endif
}

static void REGAL_CALL http_glCopyTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTextureImage2DEXT)(texture, target, level, internalformat, x, y, width, height, border);
#endif
}

static void REGAL_CALL http_glCopyTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTextureSubImage1DEXT)(texture, target, level, xoffset, x, y, width);
#endif
}

static void REGAL_CALL http_glCopyTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTextureSubImage2DEXT)(texture, target, level, xoffset, yoffset, x, y, width, height);
#endif
}

static void REGAL_CALL http_glCopyTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTextureSubImage3DEXT)(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
#endif
}

static void REGAL_CALL http_glDisableClientStateIndexedEXT(GLenum array, GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisableClientStateIndexedEXT)(array, index);
#endif
}

static void REGAL_CALL http_glDisableClientStateiEXT(GLenum array, GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisableClientStateiEXT)(array, index);
#endif
}

static void REGAL_CALL http_glDisableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisableVertexArrayAttribEXT)(vaobj, array);
#endif
}

static void REGAL_CALL http_glDisableVertexArrayEXT(GLuint vaobj, GLenum array)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisableVertexArrayEXT)(vaobj, array);
#endif
}

static void REGAL_CALL http_glEnableClientStateIndexedEXT(GLenum array, GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnableClientStateIndexedEXT)(array, index);
#endif
}

static void REGAL_CALL http_glEnableClientStateiEXT(GLenum array, GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnableClientStateiEXT)(array, index);
#endif
}

static void REGAL_CALL http_glEnableVertexArrayAttribEXT(GLuint vaobj, GLenum array)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnableVertexArrayAttribEXT)(vaobj, array);
#endif
}

static void REGAL_CALL http_glEnableVertexArrayEXT(GLuint vaobj, GLenum array)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnableVertexArrayEXT)(vaobj, array);
#endif
}

static void REGAL_CALL http_glFlushMappedNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFlushMappedNamedBufferRangeEXT)(buffer, offset, length);
#endif
}

static void REGAL_CALL http_glFramebufferDrawBufferEXT(GLuint framebuffer, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferDrawBufferEXT)(framebuffer, mode);
#endif
}

static void REGAL_CALL http_glFramebufferDrawBuffersEXT(GLuint framebuffer, GLsizei n, const GLenum *bufs)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferDrawBuffersEXT)(framebuffer, n, bufs);
#endif
}

static void REGAL_CALL http_glFramebufferReadBufferEXT(GLuint framebuffer, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferReadBufferEXT)(framebuffer, mode);
#endif
}

static void REGAL_CALL http_glGenerateMultiTexMipmapEXT(GLenum texunit, GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenerateMultiTexMipmapEXT)(texunit, target);
#endif
}

static void REGAL_CALL http_glGenerateTextureMipmapEXT(GLuint texture, GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenerateTextureMipmapEXT)(texture, target);
#endif
}

static void REGAL_CALL http_glGetCompressedMultiTexImageEXT(GLenum texunit, GLenum target, GLint lod, GLvoid *img)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetCompressedMultiTexImageEXT)(texunit, target, lod, img);
#endif
}

static void REGAL_CALL http_glGetCompressedTextureImageEXT(GLuint texture, GLenum target, GLint lod, GLvoid *img)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetCompressedTextureImageEXT)(texture, target, lod, img);
#endif
}

static void REGAL_CALL http_glGetDoubleIndexedvEXT(GLenum target, GLuint index, GLdouble *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetDoubleIndexedvEXT)(target, index, data);
#endif
}

static void REGAL_CALL http_glGetDoublei_vEXT(GLenum target, GLuint index, GLdouble *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetDoublei_vEXT)(target, index, data);
#endif
}

static void REGAL_CALL http_glGetFloatIndexedvEXT(GLenum target, GLuint index, GLfloat *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFloatIndexedvEXT)(target, index, data);
#endif
}

static void REGAL_CALL http_glGetFloati_vEXT(GLenum target, GLuint index, GLfloat *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFloati_vEXT)(target, index, data);
#endif
}

static void REGAL_CALL http_glGetFramebufferParameterivEXT(GLuint framebuffer, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFramebufferParameterivEXT)(framebuffer, pname, params);
#endif
}

static void REGAL_CALL http_glGetMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultiTexEnvfvEXT)(texunit, target, pname, params);
#endif
}

static void REGAL_CALL http_glGetMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultiTexEnvivEXT)(texunit, target, pname, params);
#endif
}

static void REGAL_CALL http_glGetMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultiTexGendvEXT)(texunit, coord, pname, params);
#endif
}

static void REGAL_CALL http_glGetMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultiTexGenfvEXT)(texunit, coord, pname, params);
#endif
}

static void REGAL_CALL http_glGetMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultiTexGenivEXT)(texunit, coord, pname, params);
#endif
}

static void REGAL_CALL http_glGetMultiTexImageEXT(GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultiTexImageEXT)(texunit, target, level, format, type, pixels);
#endif
}

static void REGAL_CALL http_glGetMultiTexLevelParameterfvEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultiTexLevelParameterfvEXT)(texunit, target, level, pname, params);
#endif
}

static void REGAL_CALL http_glGetMultiTexLevelParameterivEXT(GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultiTexLevelParameterivEXT)(texunit, target, level, pname, params);
#endif
}

static void REGAL_CALL http_glGetMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultiTexParameterIivEXT)(texunit, target, pname, params);
#endif
}

static void REGAL_CALL http_glGetMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultiTexParameterIuivEXT)(texunit, target, pname, params);
#endif
}

static void REGAL_CALL http_glGetMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultiTexParameterfvEXT)(texunit, target, pname, params);
#endif
}

static void REGAL_CALL http_glGetMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultiTexParameterivEXT)(texunit, target, pname, params);
#endif
}

static void REGAL_CALL http_glGetNamedBufferParameterivEXT(GLuint buffer, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedBufferParameterivEXT)(buffer, pname, params);
#endif
}

static void REGAL_CALL http_glGetNamedBufferPointervEXT(GLuint buffer, GLenum pname, GLvoid **params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedBufferPointervEXT)(buffer, pname, params);
#endif
}

static void REGAL_CALL http_glGetNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedBufferSubDataEXT)(buffer, offset, size, data);
#endif
}

static void REGAL_CALL http_glGetNamedFramebufferAttachmentParameterivEXT(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedFramebufferAttachmentParameterivEXT)(framebuffer, attachment, pname, params);
#endif
}

static void REGAL_CALL http_glGetNamedProgramLocalParameterIivEXT(GLuint program, GLenum target, GLuint index, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedProgramLocalParameterIivEXT)(program, target, index, params);
#endif
}

static void REGAL_CALL http_glGetNamedProgramLocalParameterIuivEXT(GLuint program, GLenum target, GLuint index, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedProgramLocalParameterIuivEXT)(program, target, index, params);
#endif
}

static void REGAL_CALL http_glGetNamedProgramLocalParameterdvEXT(GLuint program, GLenum target, GLuint index, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedProgramLocalParameterdvEXT)(program, target, index, params);
#endif
}

static void REGAL_CALL http_glGetNamedProgramLocalParameterfvEXT(GLuint program, GLenum target, GLuint index, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedProgramLocalParameterfvEXT)(program, target, index, params);
#endif
}

static void REGAL_CALL http_glGetNamedProgramStringEXT(GLuint program, GLenum target, GLenum pname, GLvoid *string)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedProgramStringEXT)(program, target, pname, string);
#endif
}

static void REGAL_CALL http_glGetNamedProgramivEXT(GLuint program, GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedProgramivEXT)(program, target, pname, params);
#endif
}

static void REGAL_CALL http_glGetNamedRenderbufferParameterivEXT(GLuint renderbuffer, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedRenderbufferParameterivEXT)(renderbuffer, pname, params);
#endif
}

static void REGAL_CALL http_glGetPointerIndexedvEXT(GLenum target, GLuint index, GLvoid **data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPointerIndexedvEXT)(target, index, data);
#endif
}

static void REGAL_CALL http_glGetPointeri_vEXT(GLenum pname, GLuint index, GLvoid **params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPointeri_vEXT)(pname, index, params);
#endif
}

static void REGAL_CALL http_glGetTextureImageEXT(GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureImageEXT)(texture, target, level, format, type, pixels);
#endif
}

static void REGAL_CALL http_glGetTextureLevelParameterfvEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureLevelParameterfvEXT)(texture, target, level, pname, params);
#endif
}

static void REGAL_CALL http_glGetTextureLevelParameterivEXT(GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureLevelParameterivEXT)(texture, target, level, pname, params);
#endif
}

static void REGAL_CALL http_glGetTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureParameterIivEXT)(texture, target, pname, params);
#endif
}

static void REGAL_CALL http_glGetTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureParameterIuivEXT)(texture, target, pname, params);
#endif
}

static void REGAL_CALL http_glGetTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureParameterfvEXT)(texture, target, pname, params);
#endif
}

static void REGAL_CALL http_glGetTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTextureParameterivEXT)(texture, target, pname, params);
#endif
}

static void REGAL_CALL http_glGetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexArrayIntegeri_vEXT)(vaobj, index, pname, param);
#endif
}

static void REGAL_CALL http_glGetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexArrayIntegervEXT)(vaobj, pname, param);
#endif
}

static void REGAL_CALL http_glGetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLvoid **param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexArrayPointeri_vEXT)(vaobj, index, pname, param);
#endif
}

static void REGAL_CALL http_glGetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, GLvoid **param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexArrayPointervEXT)(vaobj, pname, param);
#endif
}

static GLvoid *REGAL_CALL http_glMapNamedBufferEXT(GLuint buffer, GLenum access)
{
    GLvoid * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glMapNamedBufferEXT)(buffer, access);
#endif
    return ret;
}

static GLvoid *REGAL_CALL http_glMapNamedBufferRangeEXT(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
    GLvoid * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glMapNamedBufferRangeEXT)(buffer, offset, length, access);
#endif
    return ret;
}

static void REGAL_CALL http_glMatrixFrustumEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixFrustumEXT)(mode, left, right, bottom, top, zNear, zFar);
#endif
}

static void REGAL_CALL http_glMatrixLoadIdentityEXT(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixLoadIdentityEXT)(mode);
#endif
}

static void REGAL_CALL http_glMatrixLoadTransposedEXT(GLenum mode, const GLdouble *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixLoadTransposedEXT)(mode, m);
#endif
}

static void REGAL_CALL http_glMatrixLoadTransposefEXT(GLenum mode, const GLfloat *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixLoadTransposefEXT)(mode, m);
#endif
}

static void REGAL_CALL http_glMatrixLoaddEXT(GLenum mode, const GLdouble *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixLoaddEXT)(mode, m);
#endif
}

static void REGAL_CALL http_glMatrixLoadfEXT(GLenum mode, const GLfloat *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixLoadfEXT)(mode, m);
#endif
}

static void REGAL_CALL http_glMatrixMultTransposedEXT(GLenum mode, const GLdouble *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixMultTransposedEXT)(mode, m);
#endif
}

static void REGAL_CALL http_glMatrixMultTransposefEXT(GLenum mode, const GLfloat *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixMultTransposefEXT)(mode, m);
#endif
}

static void REGAL_CALL http_glMatrixMultdEXT(GLenum mode, const GLdouble *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixMultdEXT)(mode, m);
#endif
}

static void REGAL_CALL http_glMatrixMultfEXT(GLenum mode, const GLfloat *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixMultfEXT)(mode, m);
#endif
}

static void REGAL_CALL http_glMatrixOrthoEXT(GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixOrthoEXT)(mode, left, right, bottom, top, zNear, zFar);
#endif
}

static void REGAL_CALL http_glMatrixPopEXT(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixPopEXT)(mode);
#endif
}

static void REGAL_CALL http_glMatrixPushEXT(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixPushEXT)(mode);
#endif
}

static void REGAL_CALL http_glMatrixRotatedEXT(GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixRotatedEXT)(mode, angle, x, y, z);
#endif
}

static void REGAL_CALL http_glMatrixRotatefEXT(GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixRotatefEXT)(mode, angle, x, y, z);
#endif
}

static void REGAL_CALL http_glMatrixScaledEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixScaledEXT)(mode, x, y, z);
#endif
}

static void REGAL_CALL http_glMatrixScalefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixScalefEXT)(mode, x, y, z);
#endif
}

static void REGAL_CALL http_glMatrixTranslatedEXT(GLenum mode, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixTranslatedEXT)(mode, x, y, z);
#endif
}

static void REGAL_CALL http_glMatrixTranslatefEXT(GLenum mode, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixTranslatefEXT)(mode, x, y, z);
#endif
}

static void REGAL_CALL http_glMultiTexBufferEXT(GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexBufferEXT)(texunit, target, internalformat, buffer);
#endif
}

static void REGAL_CALL http_glMultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoordPointerEXT)(texunit, size, type, stride, pointer);
#endif
}

static void REGAL_CALL http_glMultiTexEnvfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexEnvfEXT)(texunit, target, pname, param);
#endif
}

static void REGAL_CALL http_glMultiTexEnvfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexEnvfvEXT)(texunit, target, pname, params);
#endif
}

static void REGAL_CALL http_glMultiTexEnviEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexEnviEXT)(texunit, target, pname, param);
#endif
}

static void REGAL_CALL http_glMultiTexEnvivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexEnvivEXT)(texunit, target, pname, params);
#endif
}

static void REGAL_CALL http_glMultiTexGendEXT(GLenum texunit, GLenum coord, GLenum pname, GLdouble param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexGendEXT)(texunit, coord, pname, param);
#endif
}

static void REGAL_CALL http_glMultiTexGendvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexGendvEXT)(texunit, coord, pname, params);
#endif
}

static void REGAL_CALL http_glMultiTexGenfEXT(GLenum texunit, GLenum coord, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexGenfEXT)(texunit, coord, pname, param);
#endif
}

static void REGAL_CALL http_glMultiTexGenfvEXT(GLenum texunit, GLenum coord, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexGenfvEXT)(texunit, coord, pname, params);
#endif
}

static void REGAL_CALL http_glMultiTexGeniEXT(GLenum texunit, GLenum coord, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexGeniEXT)(texunit, coord, pname, param);
#endif
}

static void REGAL_CALL http_glMultiTexGenivEXT(GLenum texunit, GLenum coord, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexGenivEXT)(texunit, coord, pname, params);
#endif
}

static void REGAL_CALL http_glMultiTexImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexImage1DEXT)(texunit, target, level, internalformat, width, border, format, type, pixels);
#endif
}

static void REGAL_CALL http_glMultiTexImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexImage2DEXT)(texunit, target, level, internalformat, width, height, border, format, type, pixels);
#endif
}

static void REGAL_CALL http_glMultiTexImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexImage3DEXT)(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
#endif
}

static void REGAL_CALL http_glMultiTexParameterIivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexParameterIivEXT)(texunit, target, pname, params);
#endif
}

static void REGAL_CALL http_glMultiTexParameterIuivEXT(GLenum texunit, GLenum target, GLenum pname, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexParameterIuivEXT)(texunit, target, pname, params);
#endif
}

static void REGAL_CALL http_glMultiTexParameterfEXT(GLenum texunit, GLenum target, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexParameterfEXT)(texunit, target, pname, param);
#endif
}

static void REGAL_CALL http_glMultiTexParameterfvEXT(GLenum texunit, GLenum target, GLenum pname, const GLfloat *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexParameterfvEXT)(texunit, target, pname, param);
#endif
}

static void REGAL_CALL http_glMultiTexParameteriEXT(GLenum texunit, GLenum target, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexParameteriEXT)(texunit, target, pname, param);
#endif
}

static void REGAL_CALL http_glMultiTexParameterivEXT(GLenum texunit, GLenum target, GLenum pname, const GLint *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexParameterivEXT)(texunit, target, pname, param);
#endif
}

static void REGAL_CALL http_glMultiTexRenderbufferEXT(GLenum texunit, GLenum target, GLuint renderbuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexRenderbufferEXT)(texunit, target, renderbuffer);
#endif
}

static void REGAL_CALL http_glMultiTexSubImage1DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexSubImage1DEXT)(texunit, target, level, xoffset, width, format, type, pixels);
#endif
}

static void REGAL_CALL http_glMultiTexSubImage2DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexSubImage2DEXT)(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
#endif
}

static void REGAL_CALL http_glMultiTexSubImage3DEXT(GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexSubImage3DEXT)(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
#endif
}

static void REGAL_CALL http_glNamedBufferDataEXT(GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedBufferDataEXT)(buffer, size, data, usage);
#endif
}

static void REGAL_CALL http_glNamedBufferSubDataEXT(GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedBufferSubDataEXT)(buffer, offset, size, data);
#endif
}

static void REGAL_CALL http_glNamedCopyBufferSubDataEXT(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedCopyBufferSubDataEXT)(readBuffer, writeBuffer, readOffset, writeOffset, size);
#endif
}

static void REGAL_CALL http_glNamedFramebufferRenderbufferEXT(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferRenderbufferEXT)(framebuffer, attachment, renderbuffertarget, renderbuffer);
#endif
}

static void REGAL_CALL http_glNamedFramebufferTexture1DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferTexture1DEXT)(framebuffer, attachment, textarget, texture, level);
#endif
}

static void REGAL_CALL http_glNamedFramebufferTexture2DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferTexture2DEXT)(framebuffer, attachment, textarget, texture, level);
#endif
}

static void REGAL_CALL http_glNamedFramebufferTexture3DEXT(GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferTexture3DEXT)(framebuffer, attachment, textarget, texture, level, zoffset);
#endif
}

static void REGAL_CALL http_glNamedFramebufferTextureEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferTextureEXT)(framebuffer, attachment, texture, level);
#endif
}

static void REGAL_CALL http_glNamedFramebufferTextureFaceEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferTextureFaceEXT)(framebuffer, attachment, texture, level, face);
#endif
}

static void REGAL_CALL http_glNamedFramebufferTextureLayerEXT(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedFramebufferTextureLayerEXT)(framebuffer, attachment, texture, level, layer);
#endif
}

static void REGAL_CALL http_glNamedProgramLocalParameter4dEXT(GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedProgramLocalParameter4dEXT)(program, target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glNamedProgramLocalParameter4dvEXT(GLuint program, GLenum target, GLuint index, const GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedProgramLocalParameter4dvEXT)(program, target, index, params);
#endif
}

static void REGAL_CALL http_glNamedProgramLocalParameter4fEXT(GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedProgramLocalParameter4fEXT)(program, target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glNamedProgramLocalParameter4fvEXT(GLuint program, GLenum target, GLuint index, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedProgramLocalParameter4fvEXT)(program, target, index, params);
#endif
}

static void REGAL_CALL http_glNamedProgramLocalParameterI4iEXT(GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedProgramLocalParameterI4iEXT)(program, target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glNamedProgramLocalParameterI4ivEXT(GLuint program, GLenum target, GLuint index, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedProgramLocalParameterI4ivEXT)(program, target, index, params);
#endif
}

static void REGAL_CALL http_glNamedProgramLocalParameterI4uiEXT(GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedProgramLocalParameterI4uiEXT)(program, target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glNamedProgramLocalParameterI4uivEXT(GLuint program, GLenum target, GLuint index, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedProgramLocalParameterI4uivEXT)(program, target, index, params);
#endif
}

static void REGAL_CALL http_glNamedProgramLocalParameters4fvEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedProgramLocalParameters4fvEXT)(program, target, index, count, params);
#endif
}

static void REGAL_CALL http_glNamedProgramLocalParametersI4ivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedProgramLocalParametersI4ivEXT)(program, target, index, count, params);
#endif
}

static void REGAL_CALL http_glNamedProgramLocalParametersI4uivEXT(GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedProgramLocalParametersI4uivEXT)(program, target, index, count, params);
#endif
}

static void REGAL_CALL http_glNamedProgramStringEXT(GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedProgramStringEXT)(program, target, format, len, string);
#endif
}

static void REGAL_CALL http_glNamedRenderbufferStorageEXT(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedRenderbufferStorageEXT)(renderbuffer, internalformat, width, height);
#endif
}

static void REGAL_CALL http_glNamedRenderbufferStorageMultisampleCoverageEXT(GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedRenderbufferStorageMultisampleCoverageEXT)(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
#endif
}

static void REGAL_CALL http_glNamedRenderbufferStorageMultisampleEXT(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNamedRenderbufferStorageMultisampleEXT)(renderbuffer, samples, internalformat, width, height);
#endif
}

static void REGAL_CALL http_glProgramUniform1dEXT(GLuint program, GLint location, GLdouble x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1dEXT)(program, location, x);
#endif
}

static void REGAL_CALL http_glProgramUniform1dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1dvEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform1fEXT(GLuint program, GLint location, GLfloat v0)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1fEXT)(program, location, v0);
#endif
}

static void REGAL_CALL http_glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1fvEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform1iEXT(GLuint program, GLint location, GLint v0)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1iEXT)(program, location, v0);
#endif
}

static void REGAL_CALL http_glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1ivEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform1uiEXT(GLuint program, GLint location, GLuint v0)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1uiEXT)(program, location, v0);
#endif
}

static void REGAL_CALL http_glProgramUniform1uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1uivEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform2dEXT(GLuint program, GLint location, GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2dEXT)(program, location, x, y);
#endif
}

static void REGAL_CALL http_glProgramUniform2dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2dvEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform2fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2fEXT)(program, location, v0, v1);
#endif
}

static void REGAL_CALL http_glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2fvEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform2iEXT(GLuint program, GLint location, GLint v0, GLint v1)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2iEXT)(program, location, v0, v1);
#endif
}

static void REGAL_CALL http_glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2ivEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform2uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2uiEXT)(program, location, v0, v1);
#endif
}

static void REGAL_CALL http_glProgramUniform2uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2uivEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform3dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3dEXT)(program, location, x, y, z);
#endif
}

static void REGAL_CALL http_glProgramUniform3dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3dvEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform3fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3fEXT)(program, location, v0, v1, v2);
#endif
}

static void REGAL_CALL http_glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3fvEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform3iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3iEXT)(program, location, v0, v1, v2);
#endif
}

static void REGAL_CALL http_glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3ivEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform3uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3uiEXT)(program, location, v0, v1, v2);
#endif
}

static void REGAL_CALL http_glProgramUniform3uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3uivEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform4dEXT(GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4dEXT)(program, location, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramUniform4dvEXT(GLuint program, GLint location, GLsizei count, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4dvEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform4fEXT(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4fEXT)(program, location, v0, v1, v2, v3);
#endif
}

static void REGAL_CALL http_glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4fvEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform4iEXT(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4iEXT)(program, location, v0, v1, v2, v3);
#endif
}

static void REGAL_CALL http_glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4ivEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform4uiEXT(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4uiEXT)(program, location, v0, v1, v2, v3);
#endif
}

static void REGAL_CALL http_glProgramUniform4uivEXT(GLuint program, GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4uivEXT)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix2dvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix2fvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix2x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix2x3dvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix2x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix2x3fvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix2x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix2x4dvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix2x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix2x4fvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix3dvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix3fvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix3x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix3x2dvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix3x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix3x2fvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix3x4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix3x4dvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix3x4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix3x4fvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix4dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix4dvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix4fvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix4x2dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix4x2dvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix4x2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix4x2fvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix4x3dvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix4x3dvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glProgramUniformMatrix4x3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformMatrix4x3fvEXT)(program, location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glPushClientAttribDefaultEXT(GLbitfield mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPushClientAttribDefaultEXT)(mask);
#endif
}

static void REGAL_CALL http_glTextureBufferEXT(GLuint texture, GLenum target, GLenum internalformat, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureBufferEXT)(texture, target, internalformat, buffer);
#endif
}

static void REGAL_CALL http_glTextureImage1DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureImage1DEXT)(texture, target, level, internalformat, width, border, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTextureImage2DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureImage2DEXT)(texture, target, level, internalformat, width, height, border, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTextureImage3DEXT(GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureImage3DEXT)(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTextureParameterIivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureParameterIivEXT)(texture, target, pname, params);
#endif
}

static void REGAL_CALL http_glTextureParameterIuivEXT(GLuint texture, GLenum target, GLenum pname, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureParameterIuivEXT)(texture, target, pname, params);
#endif
}

static void REGAL_CALL http_glTextureParameterfEXT(GLuint texture, GLenum target, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureParameterfEXT)(texture, target, pname, param);
#endif
}

static void REGAL_CALL http_glTextureParameterfvEXT(GLuint texture, GLenum target, GLenum pname, const GLfloat *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureParameterfvEXT)(texture, target, pname, param);
#endif
}

static void REGAL_CALL http_glTextureParameteriEXT(GLuint texture, GLenum target, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureParameteriEXT)(texture, target, pname, param);
#endif
}

static void REGAL_CALL http_glTextureParameterivEXT(GLuint texture, GLenum target, GLenum pname, const GLint *param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureParameterivEXT)(texture, target, pname, param);
#endif
}

static void REGAL_CALL http_glTextureRenderbufferEXT(GLuint texture, GLenum target, GLuint renderbuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureRenderbufferEXT)(texture, target, renderbuffer);
#endif
}

static void REGAL_CALL http_glTextureSubImage1DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureSubImage1DEXT)(texture, target, level, xoffset, width, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTextureSubImage2DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureSubImage2DEXT)(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTextureSubImage3DEXT(GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureSubImage3DEXT)(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
#endif
}

static GLboolean REGAL_CALL http_glUnmapNamedBufferEXT(GLuint buffer)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glUnmapNamedBufferEXT)(buffer);
#endif
    return ret;
}

static void REGAL_CALL http_glVertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayColorOffsetEXT)(vaobj, buffer, size, type, stride, offset);
#endif
}

static void REGAL_CALL http_glVertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride, const GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayEdgeFlagOffsetEXT)(vaobj, buffer, stride, offset);
#endif
}

static void REGAL_CALL http_glVertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayFogCoordOffsetEXT)(vaobj, buffer, type, stride, offset);
#endif
}

static void REGAL_CALL http_glVertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayIndexOffsetEXT)(vaobj, buffer, type, stride, offset);
#endif
}

static void REGAL_CALL http_glVertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayMultiTexCoordOffsetEXT)(vaobj, buffer, texunit, size, type, stride, offset);
#endif
}

static void REGAL_CALL http_glVertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, const GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayNormalOffsetEXT)(vaobj, buffer, type, stride, offset);
#endif
}

static void REGAL_CALL http_glVertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArraySecondaryColorOffsetEXT)(vaobj, buffer, size, type, stride, offset);
#endif
}

static void REGAL_CALL http_glVertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayTexCoordOffsetEXT)(vaobj, buffer, size, type, stride, offset);
#endif
}

static void REGAL_CALL http_glVertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayVertexAttribIOffsetEXT)(vaobj, buffer, index, size, type, stride, offset);
#endif
}

static void REGAL_CALL http_glVertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayVertexAttribOffsetEXT)(vaobj, buffer, index, size, type, normalized, stride, offset);
#endif
}

static void REGAL_CALL http_glVertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, const GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayVertexOffsetEXT)(vaobj, buffer, size, type, stride, offset);
#endif
}

// GL_EXT_discard_framebuffer

static void REGAL_CALL http_glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum *attachments)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDiscardFramebufferEXT)(target, numAttachments, attachments);
#endif
}

// GL_EXT_disjoint_timer_query

static void REGAL_CALL http_glGetQueryObjectivEXT(GLuint id, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjectivEXT)(id, pname, params);
#endif
}

static void REGAL_CALL http_glQueryCounterEXT(GLuint id, GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glQueryCounterEXT)(id, target);
#endif
}

// GL_EXT_draw_buffers2

static void REGAL_CALL http_glColorMaskIndexedEXT(GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorMaskIndexedEXT)(buf, r, g, b, a);
#endif
}

static void REGAL_CALL http_glDisableIndexedEXT(GLenum target, GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisableIndexedEXT)(target, index);
#endif
}

static void REGAL_CALL http_glEnableIndexedEXT(GLenum target, GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnableIndexedEXT)(target, index);
#endif
}

static void REGAL_CALL http_glGetBooleanIndexedvEXT(GLenum value, GLuint index, GLboolean *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetBooleanIndexedvEXT)(value, index, data);
#endif
}

static void REGAL_CALL http_glGetIntegerIndexedvEXT(GLenum value, GLuint index, GLint *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetIntegerIndexedvEXT)(value, index, data);
#endif
}

static GLboolean REGAL_CALL http_glIsEnabledIndexedEXT(GLenum target, GLuint index)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsEnabledIndexedEXT)(target, index);
#endif
    return ret;
}

// GL_EXT_draw_instanced

static void REGAL_CALL http_glDrawArraysInstancedEXT(GLenum mode, GLint start, GLsizei count, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawArraysInstancedEXT)(mode, start, count, primcount);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glDrawElementsInstancedEXT(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawElementsInstancedEXT)(mode, count, type, indices, primcount);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

// GL_EXT_draw_range_elements

static void REGAL_CALL http_glDrawRangeElementsEXT(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawRangeElementsEXT)(mode, start, end, count, type, indices);
#endif
}

// GL_EXT_fog_coord

static void REGAL_CALL http_glFogCoordPointerEXT(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoordPointerEXT)(type, stride, pointer);
#endif
}

static void REGAL_CALL http_glFogCoorddEXT(GLdouble coord)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoorddEXT)(coord);
#endif
}

static void REGAL_CALL http_glFogCoorddvEXT(const GLdouble *coord)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoorddvEXT)(coord);
#endif
}

static void REGAL_CALL http_glFogCoordfEXT(GLfloat coord)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoordfEXT)(coord);
#endif
}

static void REGAL_CALL http_glFogCoordfvEXT(const GLfloat *coord)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoordfvEXT)(coord);
#endif
}

// GL_EXT_fragment_lighting

static void REGAL_CALL http_glFragmentColorMaterialEXT(GLenum face, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentColorMaterialEXT)(face, mode);
#endif
}

static void REGAL_CALL http_glFragmentLightModelfEXT(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightModelfEXT)(pname, param);
#endif
}

static void REGAL_CALL http_glFragmentLightModelfvEXT(GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightModelfvEXT)(pname, params);
#endif
}

static void REGAL_CALL http_glFragmentLightModeliEXT(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightModeliEXT)(pname, param);
#endif
}

static void REGAL_CALL http_glFragmentLightModelivEXT(GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightModelivEXT)(pname, params);
#endif
}

static void REGAL_CALL http_glFragmentLightfEXT(GLenum light, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightfEXT)(light, pname, param);
#endif
}

static void REGAL_CALL http_glFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightfvEXT)(light, pname, params);
#endif
}

static void REGAL_CALL http_glFragmentLightiEXT(GLenum light, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightiEXT)(light, pname, param);
#endif
}

static void REGAL_CALL http_glFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightivEXT)(light, pname, params);
#endif
}

static void REGAL_CALL http_glFragmentMaterialfEXT(GLenum face, GLenum pname, const GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentMaterialfEXT)(face, pname, param);
#endif
}

static void REGAL_CALL http_glFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentMaterialfvEXT)(face, pname, params);
#endif
}

static void REGAL_CALL http_glFragmentMaterialiEXT(GLenum face, GLenum pname, const GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentMaterialiEXT)(face, pname, param);
#endif
}

static void REGAL_CALL http_glFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentMaterialivEXT)(face, pname, params);
#endif
}

static void REGAL_CALL http_glGetFragmentLightfvEXT(GLenum light, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFragmentLightfvEXT)(light, pname, params);
#endif
}

static void REGAL_CALL http_glGetFragmentLightivEXT(GLenum light, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFragmentLightivEXT)(light, pname, params);
#endif
}

static void REGAL_CALL http_glGetFragmentMaterialfvEXT(GLenum face, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFragmentMaterialfvEXT)(face, pname, params);
#endif
}

static void REGAL_CALL http_glGetFragmentMaterialivEXT(GLenum face, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFragmentMaterialivEXT)(face, pname, params);
#endif
}

static void REGAL_CALL http_glLightEnviEXT(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLightEnviEXT)(pname, param);
#endif
}

// GL_EXT_framebuffer_blit

static void REGAL_CALL http_glBlitFramebufferEXT(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlitFramebufferEXT)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
#endif
}

// GL_EXT_framebuffer_multisample

static void REGAL_CALL http_glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRenderbufferStorageMultisampleEXT)(target, samples, internalformat, width, height);
#endif
}

// GL_EXT_framebuffer_object

static void REGAL_CALL http_glBindFramebufferEXT(GLenum target, GLuint framebuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindFramebufferEXT)(target, framebuffer);
#endif
}

static void REGAL_CALL http_glBindRenderbufferEXT(GLenum target, GLuint renderbuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindRenderbufferEXT)(target, renderbuffer);
#endif
}

static GLenum REGAL_CALL http_glCheckFramebufferStatusEXT(GLenum target)
{
    GLenum  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glCheckFramebufferStatusEXT)(target);
#endif
    return ret;
}

static void REGAL_CALL http_glDeleteFramebuffersEXT(GLsizei n, const GLuint *framebuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteFramebuffersEXT)(n, framebuffers);
#endif
}

static void REGAL_CALL http_glDeleteRenderbuffersEXT(GLsizei n, const GLuint *renderbuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteRenderbuffersEXT)(n, renderbuffers);
#endif
}

static void REGAL_CALL http_glFramebufferRenderbufferEXT(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferRenderbufferEXT)(target, attachment, renderbuffertarget, renderbuffer);
#endif
}

static void REGAL_CALL http_glFramebufferTexture1DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTexture1DEXT)(target, attachment, textarget, texture, level);
#endif
}

static void REGAL_CALL http_glFramebufferTexture2DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTexture2DEXT)(target, attachment, textarget, texture, level);
#endif
}

static void REGAL_CALL http_glFramebufferTexture3DEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTexture3DEXT)(target, attachment, textarget, texture, level, zoffset);
#endif
}

static void REGAL_CALL http_glGenFramebuffersEXT(GLsizei n, GLuint *framebuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenFramebuffersEXT)(n, framebuffers);
#endif
}

static void REGAL_CALL http_glGenRenderbuffersEXT(GLsizei n, GLuint *renderbuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenRenderbuffersEXT)(n, renderbuffers);
#endif
}

static void REGAL_CALL http_glGenerateMipmapEXT(GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenerateMipmapEXT)(target);
#endif
}

static void REGAL_CALL http_glGetFramebufferAttachmentParameterivEXT(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFramebufferAttachmentParameterivEXT)(target, attachment, pname, params);
#endif
}

static void REGAL_CALL http_glGetRenderbufferParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetRenderbufferParameterivEXT)(target, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsFramebufferEXT(GLuint framebuffer)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsFramebufferEXT)(framebuffer);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glIsRenderbufferEXT(GLuint renderbuffer)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsRenderbufferEXT)(renderbuffer);
#endif
    return ret;
}

static void REGAL_CALL http_glRenderbufferStorageEXT(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRenderbufferStorageEXT)(target, internalformat, width, height);
#endif
}

// GL_EXT_geometry_shader4

static void REGAL_CALL http_glFramebufferTextureEXT(GLenum target, GLenum attachment, GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTextureEXT)(target, attachment, texture, level);
#endif
}

static void REGAL_CALL http_glFramebufferTextureFaceEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTextureFaceEXT)(target, attachment, texture, level, face);
#endif
}

static void REGAL_CALL http_glProgramParameteriEXT(GLuint program, GLenum pname, GLint value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramParameteriEXT)(program, pname, value);
#endif
}

// GL_EXT_gpu_program_parameters

static void REGAL_CALL http_glProgramEnvParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramEnvParameters4fvEXT)(target, index, count, params);
#endif
}

static void REGAL_CALL http_glProgramLocalParameters4fvEXT(GLenum target, GLuint index, GLsizei count, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramLocalParameters4fvEXT)(target, index, count, params);
#endif
}

// GL_EXT_gpu_shader4

static void REGAL_CALL http_glBindFragDataLocationEXT(GLuint program, GLuint color, const GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindFragDataLocationEXT)(program, color, name);
#endif
}

static GLint REGAL_CALL http_glGetFragDataLocationEXT(GLuint program, const GLchar *name)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetFragDataLocationEXT)(program, name);
#endif
    return ret;
}

static void REGAL_CALL http_glGetUniformuivEXT(GLuint program, GLint location, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetUniformuivEXT)(program, location, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribIivEXT(GLuint index, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribIivEXT)(index, pname, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribIuivEXT(GLuint index, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribIuivEXT)(index, pname, params);
#endif
}

static void REGAL_CALL http_glUniform1uiEXT(GLint location, GLuint v0)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1uiEXT)(location, v0);
#endif
}

static void REGAL_CALL http_glUniform1uivEXT(GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1uivEXT)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform2uiEXT(GLint location, GLuint v0, GLuint v1)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2uiEXT)(location, v0, v1);
#endif
}

static void REGAL_CALL http_glUniform2uivEXT(GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2uivEXT)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform3uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3uiEXT)(location, v0, v1, v2);
#endif
}

static void REGAL_CALL http_glUniform3uivEXT(GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3uivEXT)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform4uiEXT(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4uiEXT)(location, v0, v1, v2, v3);
#endif
}

static void REGAL_CALL http_glUniform4uivEXT(GLint location, GLsizei count, const GLuint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4uivEXT)(location, count, value);
#endif
}

static void REGAL_CALL http_glVertexAttribI1iEXT(GLuint index, GLint x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI1iEXT)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttribI1ivEXT(GLuint index, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI1ivEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI1uiEXT(GLuint index, GLuint x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI1uiEXT)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttribI1uivEXT(GLuint index, const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI1uivEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI2iEXT(GLuint index, GLint x, GLint y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI2iEXT)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttribI2ivEXT(GLuint index, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI2ivEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI2uiEXT(GLuint index, GLuint x, GLuint y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI2uiEXT)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttribI2uivEXT(GLuint index, const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI2uivEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI3iEXT(GLuint index, GLint x, GLint y, GLint z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI3iEXT)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttribI3ivEXT(GLuint index, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI3ivEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI3uiEXT(GLuint index, GLuint x, GLuint y, GLuint z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI3uiEXT)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttribI3uivEXT(GLuint index, const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI3uivEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI4bvEXT(GLuint index, const GLbyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4bvEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI4iEXT(GLuint index, GLint x, GLint y, GLint z, GLint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4iEXT)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttribI4ivEXT(GLuint index, const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4ivEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI4svEXT(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4svEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI4ubvEXT(GLuint index, const GLubyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4ubvEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI4uiEXT(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4uiEXT)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttribI4uivEXT(GLuint index, const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4uivEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribI4usvEXT(GLuint index, const GLushort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribI4usvEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribIPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribIPointerEXT)(index, size, type, stride, pointer);
#endif
}

// GL_EXT_histogram

static void REGAL_CALL http_glGetHistogramEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetHistogramEXT)(target, reset, format, type, values);
#endif
}

static void REGAL_CALL http_glGetHistogramParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetHistogramParameterfvEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetHistogramParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetHistogramParameterivEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetMinmaxEXT(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMinmaxEXT)(target, reset, format, type, values);
#endif
}

static void REGAL_CALL http_glGetMinmaxParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMinmaxParameterfvEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetMinmaxParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMinmaxParameterivEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glHistogramEXT(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glHistogramEXT)(target, width, internalformat, sink);
#endif
}

static void REGAL_CALL http_glMinmaxEXT(GLenum target, GLenum internalformat, GLboolean sink)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMinmaxEXT)(target, internalformat, sink);
#endif
}

static void REGAL_CALL http_glResetHistogramEXT(GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glResetHistogramEXT)(target);
#endif
}

static void REGAL_CALL http_glResetMinmaxEXT(GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glResetMinmaxEXT)(target);
#endif
}

// GL_EXT_index_func

static void REGAL_CALL http_glIndexFuncEXT(GLenum func, GLfloat ref)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexFuncEXT)(func, ref);
#endif
}

// GL_EXT_index_material

static void REGAL_CALL http_glIndexMaterialEXT(GLenum face, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexMaterialEXT)(face, mode);
#endif
}

// GL_EXT_light_texture

static void REGAL_CALL http_glApplyTextureEXT(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glApplyTextureEXT)(mode);
#endif
}

static void REGAL_CALL http_glTextureLightEXT(GLenum pname)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureLightEXT)(pname);
#endif
}

static void REGAL_CALL http_glTextureMaterialEXT(GLenum face, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureMaterialEXT)(face, mode);
#endif
}

// GL_EXT_map_buffer_range

static void REGAL_CALL http_glFlushMappedBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFlushMappedBufferRangeEXT)(target, offset, length);
#endif
}

static GLvoid *REGAL_CALL http_glMapBufferRangeEXT(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
    GLvoid * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glMapBufferRangeEXT)(target, offset, length, access);
#endif
    return ret;
}

// GL_EXT_multi_draw_arrays

static void REGAL_CALL http_glMultiDrawArraysEXT(GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiDrawArraysEXT)(mode, first, count, primcount);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiDrawElementsEXT)(mode, count, type, indices, primcount);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

// GL_EXT_multisample

static void REGAL_CALL http_glSampleMaskEXT(GLclampf value, GLboolean invert)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSampleMaskEXT)(value, invert);
#endif
}

static void REGAL_CALL http_glSamplePatternEXT(GLenum pattern)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSamplePatternEXT)(pattern);
#endif
}

// GL_EXT_multisampled_render_to_texture

static void REGAL_CALL http_glFramebufferTexture2DMultisampleEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTexture2DMultisampleEXT)(target, attachment, textarget, texture, level, samples);
#endif
}

// GL_EXT_multiview_draw_buffers

static void REGAL_CALL http_glDrawBuffersIndexedEXT(GLint n, const GLenum *location, const GLint *indices)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawBuffersIndexedEXT)(n, location, indices);
#endif
}

static void REGAL_CALL http_glGetIntegeri_vEXT(GLenum target, GLuint index, GLint *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetIntegeri_vEXT)(target, index, data);
#endif
}

static void REGAL_CALL http_glReadBufferIndexedEXT(GLenum src, GLint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReadBufferIndexedEXT)(src, index);
#endif
}

// GL_EXT_occlusion_query_boolean

static void REGAL_CALL http_glBeginQueryEXT(GLenum target, GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginQueryEXT)(target, id);
#endif
}

static void REGAL_CALL http_glDeleteQueriesEXT(GLsizei n, const GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteQueriesEXT)(n, ids);
#endif
}

static void REGAL_CALL http_glEndQueryEXT(GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndQueryEXT)(target);
#endif
}

static void REGAL_CALL http_glGenQueriesEXT(GLsizei n, GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenQueriesEXT)(n, ids);
#endif
}

static void REGAL_CALL http_glGetQueryObjectuivEXT(GLuint id, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjectuivEXT)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetQueryivEXT(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryivEXT)(target, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsQueryEXT(GLuint id)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsQueryEXT)(id);
#endif
    return ret;
}

// GL_EXT_paletted_texture

static void REGAL_CALL http_glColorTableEXT(GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorTableEXT)(target, internalFormat, width, format, type, table);
#endif
}

static void REGAL_CALL http_glGetColorTableEXT(GLenum target, GLenum format, GLenum type, GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetColorTableEXT)(target, format, type, data);
#endif
}

static void REGAL_CALL http_glGetColorTableParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetColorTableParameterfvEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetColorTableParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetColorTableParameterivEXT)(target, pname, params);
#endif
}

// GL_EXT_pixel_transform

static void REGAL_CALL http_glGetPixelTransformParameterfvEXT(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPixelTransformParameterfvEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetPixelTransformParameterivEXT(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPixelTransformParameterivEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glPixelTransformParameterfEXT(GLenum target, GLenum pname, const GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelTransformParameterfEXT)(target, pname, param);
#endif
}

static void REGAL_CALL http_glPixelTransformParameterfvEXT(GLenum target, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelTransformParameterfvEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glPixelTransformParameteriEXT(GLenum target, GLenum pname, const GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelTransformParameteriEXT)(target, pname, param);
#endif
}

static void REGAL_CALL http_glPixelTransformParameterivEXT(GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelTransformParameterivEXT)(target, pname, params);
#endif
}

// GL_EXT_point_parameters

static void REGAL_CALL http_glPointParameterfEXT(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameterfEXT)(pname, param);
#endif
}

static void REGAL_CALL http_glPointParameterfvEXT(GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameterfvEXT)(pname, params);
#endif
}

// GL_EXT_polygon_offset

static void REGAL_CALL http_glPolygonOffsetEXT(GLfloat factor, GLfloat bias)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPolygonOffsetEXT)(factor, bias);
#endif
}

// GL_EXT_provoking_vertex

static void REGAL_CALL http_glProvokingVertexEXT(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProvokingVertexEXT)(mode);
#endif
}

// GL_EXT_robustness

static void REGAL_CALL http_glGetnUniformfvEXT(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnUniformfvEXT)(program, location, bufSize, params);
#endif
}

static void REGAL_CALL http_glGetnUniformivEXT(GLuint program, GLint location, GLsizei bufSize, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnUniformivEXT)(program, location, bufSize, params);
#endif
}

static void REGAL_CALL http_glReadnPixelsEXT(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReadnPixelsEXT)(x, y, width, height, format, type, bufSize, data);
#endif
}

// GL_EXT_scene_marker

static void REGAL_CALL http_glBeginSceneEXT(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginSceneEXT)();
#endif
}

static void REGAL_CALL http_glEndSceneEXT(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndSceneEXT)();
#endif
}

// GL_EXT_secondary_color

static void REGAL_CALL http_glSecondaryColor3bEXT(GLbyte red, GLbyte green, GLbyte blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3bEXT)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3bvEXT(const GLbyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3bvEXT)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3dEXT(GLdouble red, GLdouble green, GLdouble blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3dEXT)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3dvEXT(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3dvEXT)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3fEXT(GLfloat red, GLfloat green, GLfloat blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3fEXT)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3fvEXT(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3fvEXT)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3iEXT(GLint red, GLint green, GLint blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3iEXT)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3ivEXT(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3ivEXT)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3sEXT(GLshort red, GLshort green, GLshort blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3sEXT)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3svEXT(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3svEXT)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3ubEXT(GLubyte red, GLubyte green, GLubyte blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3ubEXT)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3ubvEXT(const GLubyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3ubvEXT)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3uiEXT(GLuint red, GLuint green, GLuint blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3uiEXT)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3uivEXT(const GLuint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3uivEXT)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3usEXT(GLushort red, GLushort green, GLushort blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3usEXT)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3usvEXT(const GLushort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3usvEXT)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColorPointerEXT(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColorPointerEXT)(size, type, stride, pointer);
#endif
}

// GL_EXT_separate_shader_objects

static void REGAL_CALL http_glActiveProgramEXT(GLuint program)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glActiveProgramEXT)(program);
#endif
}

static GLuint REGAL_CALL http_glCreateShaderProgramEXT(GLenum type, const GLchar *string)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glCreateShaderProgramEXT)(type, string);
#endif
    return ret;
}

static void REGAL_CALL http_glUseShaderProgramEXT(GLenum type, GLuint program)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUseShaderProgramEXT)(type, program);
#endif
}

// GL_EXT_shader_image_load_store

static void REGAL_CALL http_glBindImageTextureEXT(GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindImageTextureEXT)(index, texture, level, layered, layer, access, format);
#endif
}

static void REGAL_CALL http_glMemoryBarrierEXT(GLbitfield barriers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMemoryBarrierEXT)(barriers);
#endif
}

// GL_EXT_stencil_clear_tag

static void REGAL_CALL http_glStencilClearTagEXT(GLsizei stencilTagBits, GLuint stencilClearTag)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilClearTagEXT)(stencilTagBits, stencilClearTag);
#endif
}

// GL_EXT_stencil_two_side

static void REGAL_CALL http_glActiveStencilFaceEXT(GLenum face)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glActiveStencilFaceEXT)(face);
#endif
}

// GL_EXT_subtexture

static void REGAL_CALL http_glTexSubImage1DEXT(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexSubImage1DEXT)(target, level, xoffset, width, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTexSubImage2DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexSubImage2DEXT)(target, level, xoffset, yoffset, width, height, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTexSubImage3DEXT(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexSubImage3DEXT)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
#endif
}

// GL_EXT_texture3D

static void REGAL_CALL http_glTexImage3DEXT(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexImage3DEXT)(target, level, internalformat, width, height, depth, border, format, type, pixels);
#endif
}

// GL_EXT_texture_array

static void REGAL_CALL http_glFramebufferTextureLayerEXT(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTextureLayerEXT)(target, attachment, texture, level, layer);
#endif
}

// GL_EXT_texture_buffer_object

static void REGAL_CALL http_glTexBufferEXT(GLenum target, GLenum internalformat, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexBufferEXT)(target, internalformat, buffer);
#endif
}

// GL_EXT_texture_integer

static void REGAL_CALL http_glClearColorIiEXT(GLint red, GLint green, GLint blue, GLint alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearColorIiEXT)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glClearColorIuiEXT(GLuint red, GLuint green, GLuint blue, GLuint alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearColorIuiEXT)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glGetTexParameterIivEXT(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexParameterIivEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexParameterIuivEXT(GLenum target, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexParameterIuivEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glTexParameterIivEXT(GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexParameterIivEXT)(target, pname, params);
#endif
}

static void REGAL_CALL http_glTexParameterIuivEXT(GLenum target, GLenum pname, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexParameterIuivEXT)(target, pname, params);
#endif
}

// GL_EXT_texture_object

static GLboolean REGAL_CALL http_glAreTexturesResidentEXT(GLsizei n, const GLuint *textures, GLboolean *residences)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glAreTexturesResidentEXT)(n, textures, residences);
#endif
    return ret;
}

static void REGAL_CALL http_glBindTextureEXT(GLenum target, GLuint texture)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      if( texture != 0 ) {
        HttpTextureInfo & hti = _context->http.texture[ texture ];
        RegalAssert( hti.name == 0 || hti.name == texture );
        if( hti.name == 0 ) {
          hti.name = texture;
          hti.target = target;
        }
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindTextureEXT)(target, texture);
#endif
}

static void REGAL_CALL http_glDeleteTexturesEXT(GLsizei n, const GLuint *textures)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      for( int i = 0; i < n; i++ ) {
        _context->http.texture.erase( textures[i] );
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteTexturesEXT)(n, textures);
#endif
}

static void REGAL_CALL http_glGenTexturesEXT(GLsizei n, GLuint *textures)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenTexturesEXT)(n, textures);
#endif
}

static GLboolean REGAL_CALL http_glIsTextureEXT(GLuint texture)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsTextureEXT)(texture);
#endif
    return ret;
}

static void REGAL_CALL http_glPrioritizeTexturesEXT(GLsizei n, const GLuint *textures, const GLclampf *priorities)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPrioritizeTexturesEXT)(n, textures, priorities);
#endif
}

// GL_EXT_texture_perturb_normal

static void REGAL_CALL http_glTextureNormalEXT(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureNormalEXT)(mode);
#endif
}

// GL_EXT_texture_storage

static void REGAL_CALL http_glTexStorage1DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexStorage1DEXT)(target, levels, internalformat, width);
#endif
}

static void REGAL_CALL http_glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexStorage2DEXT)(target, levels, internalformat, width, height);
#endif
}

static void REGAL_CALL http_glTexStorage3DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexStorage3DEXT)(target, levels, internalformat, width, height, depth);
#endif
}

// GL_EXT_timer_query

static void REGAL_CALL http_glGetQueryObjecti64vEXT(GLuint id, GLenum pname, GLint64EXT *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjecti64vEXT)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetQueryObjectui64vEXT(GLuint id, GLenum pname, GLuint64EXT *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetQueryObjectui64vEXT)(id, pname, params);
#endif
}

// GL_EXT_transform_feedback

static void REGAL_CALL http_glBeginTransformFeedbackEXT(GLenum primitiveMode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginTransformFeedbackEXT)(primitiveMode);
#endif
}

static void REGAL_CALL http_glBindBufferBaseEXT(GLenum target, GLuint index, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindBufferBaseEXT)(target, index, buffer);
#endif
}

static void REGAL_CALL http_glBindBufferOffsetEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindBufferOffsetEXT)(target, index, buffer, offset);
#endif
}

static void REGAL_CALL http_glBindBufferRangeEXT(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindBufferRangeEXT)(target, index, buffer, offset, size);
#endif
}

static void REGAL_CALL http_glEndTransformFeedbackEXT(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndTransformFeedbackEXT)();
#endif
}

static void REGAL_CALL http_glGetTransformFeedbackVaryingEXT(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTransformFeedbackVaryingEXT)(program, index, bufSize, length, size, type, name);
#endif
}

static void REGAL_CALL http_glTransformFeedbackVaryingsEXT(GLuint program, GLsizei count, const GLchar * const *varyings, GLenum bufferMode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTransformFeedbackVaryingsEXT)(program, count, varyings, bufferMode);
#endif
}

// GL_EXT_vertex_array

static void REGAL_CALL http_glArrayElementEXT(GLint i)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glArrayElementEXT)(i);
#endif
}

static void REGAL_CALL http_glColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorPointerEXT)(size, type, stride, count, pointer);
#endif
}

static void REGAL_CALL http_glDrawArraysEXT(GLenum mode, GLint first, GLsizei count)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.draw++;
      if( _context->http.runState == RS_NextDraw ) {
        _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawArraysEXT)(mode, first, count);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastDraw = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glEdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEdgeFlagPointerEXT)(stride, count, pointer);
#endif
}

static void REGAL_CALL http_glGetPointervEXT(GLenum pname, GLvoid **params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPointervEXT)(pname, params);
#endif
}

static void REGAL_CALL http_glIndexPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexPointerEXT)(type, stride, count, pointer);
#endif
}

static void REGAL_CALL http_glNormalPointerEXT(GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalPointerEXT)(type, stride, count, pointer);
#endif
}

static void REGAL_CALL http_glTexCoordPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoordPointerEXT)(size, type, stride, count, pointer);
#endif
}

static void REGAL_CALL http_glVertexPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexPointerEXT)(size, type, stride, count, pointer);
#endif
}

// GL_EXT_vertex_attrib_64bit

static void REGAL_CALL http_glGetVertexAttribLdvEXT(GLuint index, GLenum pname, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribLdvEXT)(index, pname, params);
#endif
}

static void REGAL_CALL http_glVertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayVertexAttribLOffsetEXT)(vaobj, buffer, index, size, type, stride, offset);
#endif
}

static void REGAL_CALL http_glVertexAttribL1dEXT(GLuint index, GLdouble x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL1dEXT)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttribL1dvEXT(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL1dvEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribL2dEXT(GLuint index, GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL2dEXT)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttribL2dvEXT(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL2dvEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribL3dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL3dEXT)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttribL3dvEXT(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL3dvEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribL4dEXT(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL4dEXT)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttribL4dvEXT(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL4dvEXT)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribLPointerEXT(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribLPointerEXT)(index, size, type, stride, pointer);
#endif
}

// GL_EXT_vertex_shader

static void REGAL_CALL http_glBeginVertexShaderEXT(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginVertexShaderEXT)();
#endif
}

static GLuint REGAL_CALL http_glBindLightParameterEXT(GLenum light, GLenum value)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glBindLightParameterEXT)(light, value);
#endif
    return ret;
}

static GLuint REGAL_CALL http_glBindMaterialParameterEXT(GLenum face, GLenum value)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glBindMaterialParameterEXT)(face, value);
#endif
    return ret;
}

static GLuint REGAL_CALL http_glBindParameterEXT(GLenum value)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glBindParameterEXT)(value);
#endif
    return ret;
}

static GLuint REGAL_CALL http_glBindTexGenParameterEXT(GLenum unit, GLenum coord, GLenum value)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glBindTexGenParameterEXT)(unit, coord, value);
#endif
    return ret;
}

static GLuint REGAL_CALL http_glBindTextureUnitParameterEXT(GLenum unit, GLenum value)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glBindTextureUnitParameterEXT)(unit, value);
#endif
    return ret;
}

static void REGAL_CALL http_glBindVertexShaderEXT(GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindVertexShaderEXT)(id);
#endif
}

static void REGAL_CALL http_glDeleteVertexShaderEXT(GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteVertexShaderEXT)(id);
#endif
}

static void REGAL_CALL http_glDisableVariantClientStateEXT(GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisableVariantClientStateEXT)(id);
#endif
}

static void REGAL_CALL http_glEnableVariantClientStateEXT(GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnableVariantClientStateEXT)(id);
#endif
}

static void REGAL_CALL http_glEndVertexShaderEXT(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndVertexShaderEXT)();
#endif
}

static void REGAL_CALL http_glExtractComponentEXT(GLuint res, GLuint src, GLuint num)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glExtractComponentEXT)(res, src, num);
#endif
}

static GLuint REGAL_CALL http_glGenSymbolsEXT(GLenum datatype, GLenum storagetype, GLenum range, GLuint components)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGenSymbolsEXT)(datatype, storagetype, range, components);
#endif
    return ret;
}

static GLuint REGAL_CALL http_glGenVertexShadersEXT(GLuint range)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGenVertexShadersEXT)(range);
#endif
    return ret;
}

static void REGAL_CALL http_glGetInvariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetInvariantBooleanvEXT)(id, value, data);
#endif
}

static void REGAL_CALL http_glGetInvariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetInvariantFloatvEXT)(id, value, data);
#endif
}

static void REGAL_CALL http_glGetInvariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetInvariantIntegervEXT)(id, value, data);
#endif
}

static void REGAL_CALL http_glGetLocalConstantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetLocalConstantBooleanvEXT)(id, value, data);
#endif
}

static void REGAL_CALL http_glGetLocalConstantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetLocalConstantFloatvEXT)(id, value, data);
#endif
}

static void REGAL_CALL http_glGetLocalConstantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetLocalConstantIntegervEXT)(id, value, data);
#endif
}

static void REGAL_CALL http_glGetVariantBooleanvEXT(GLuint id, GLenum value, GLboolean *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVariantBooleanvEXT)(id, value, data);
#endif
}

static void REGAL_CALL http_glGetVariantFloatvEXT(GLuint id, GLenum value, GLfloat *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVariantFloatvEXT)(id, value, data);
#endif
}

static void REGAL_CALL http_glGetVariantIntegervEXT(GLuint id, GLenum value, GLint *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVariantIntegervEXT)(id, value, data);
#endif
}

static void REGAL_CALL http_glGetVariantPointervEXT(GLuint id, GLenum value, GLvoid **data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVariantPointervEXT)(id, value, data);
#endif
}

static void REGAL_CALL http_glInsertComponentEXT(GLuint res, GLuint src, GLuint num)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInsertComponentEXT)(res, src, num);
#endif
}

static GLboolean REGAL_CALL http_glIsVariantEnabledEXT(GLuint id, GLenum cap)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsVariantEnabledEXT)(id, cap);
#endif
    return ret;
}

static void REGAL_CALL http_glSetInvariantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSetInvariantEXT)(id, type, addr);
#endif
}

static void REGAL_CALL http_glSetLocalConstantEXT(GLuint id, GLenum type, const GLvoid *addr)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSetLocalConstantEXT)(id, type, addr);
#endif
}

static void REGAL_CALL http_glShaderOp1EXT(GLenum op, GLuint res, GLuint arg1)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glShaderOp1EXT)(op, res, arg1);
#endif
}

static void REGAL_CALL http_glShaderOp2EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glShaderOp2EXT)(op, res, arg1, arg2);
#endif
}

static void REGAL_CALL http_glShaderOp3EXT(GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glShaderOp3EXT)(op, res, arg1, arg2, arg3);
#endif
}

static void REGAL_CALL http_glSwizzleEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSwizzleEXT)(res, in, outX, outY, outZ, outW);
#endif
}

static void REGAL_CALL http_glVariantPointerEXT(GLuint id, GLenum type, GLuint stride, const GLvoid *addr)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVariantPointerEXT)(id, type, stride, addr);
#endif
}

static void REGAL_CALL http_glVariantbvEXT(GLuint id, const GLbyte *addr)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVariantbvEXT)(id, addr);
#endif
}

static void REGAL_CALL http_glVariantdvEXT(GLuint id, const GLdouble *addr)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVariantdvEXT)(id, addr);
#endif
}

static void REGAL_CALL http_glVariantfvEXT(GLuint id, const GLfloat *addr)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVariantfvEXT)(id, addr);
#endif
}

static void REGAL_CALL http_glVariantivEXT(GLuint id, const GLint *addr)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVariantivEXT)(id, addr);
#endif
}

static void REGAL_CALL http_glVariantsvEXT(GLuint id, const GLshort *addr)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVariantsvEXT)(id, addr);
#endif
}

static void REGAL_CALL http_glVariantubvEXT(GLuint id, const GLubyte *addr)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVariantubvEXT)(id, addr);
#endif
}

static void REGAL_CALL http_glVariantuivEXT(GLuint id, const GLuint *addr)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVariantuivEXT)(id, addr);
#endif
}

static void REGAL_CALL http_glVariantusvEXT(GLuint id, const GLushort *addr)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVariantusvEXT)(id, addr);
#endif
}

static void REGAL_CALL http_glWriteMaskEXT(GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWriteMaskEXT)(res, in, outX, outY, outZ, outW);
#endif
}

// GL_EXT_vertex_weighting

static void REGAL_CALL http_glVertexWeightPointerEXT(GLsizei size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexWeightPointerEXT)(size, type, stride, pointer);
#endif
}

static void REGAL_CALL http_glVertexWeightfEXT(GLfloat weight)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexWeightfEXT)(weight);
#endif
}

static void REGAL_CALL http_glVertexWeightfvEXT(const GLfloat *weight)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexWeightfvEXT)(weight);
#endif
}

// GL_EXT_x11_sync_object

static GLsync REGAL_CALL http_glImportSyncEXT(GLenum external_sync_type, GLintptr external_sync, GLbitfield flags)
{
    GLsync  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glImportSyncEXT)(external_sync_type, external_sync, flags);
#endif
    return ret;
}

// GL_GREMEDY_frame_terminator

static void REGAL_CALL http_glFrameTerminatorGREMEDY(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFrameTerminatorGREMEDY)();
#endif
}

// GL_GREMEDY_string_marker

static void REGAL_CALL http_glStringMarkerGREMEDY(GLsizei len, const GLvoid *string)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStringMarkerGREMEDY)(len, string);
#endif
}

// GL_HP_image_transform

static void REGAL_CALL http_glGetImageTransformParameterfvHP(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetImageTransformParameterfvHP)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetImageTransformParameterivHP(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetImageTransformParameterivHP)(target, pname, params);
#endif
}

static void REGAL_CALL http_glImageTransformParameterfHP(GLenum target, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glImageTransformParameterfHP)(target, pname, param);
#endif
}

static void REGAL_CALL http_glImageTransformParameterfvHP(GLenum target, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glImageTransformParameterfvHP)(target, pname, params);
#endif
}

static void REGAL_CALL http_glImageTransformParameteriHP(GLenum target, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glImageTransformParameteriHP)(target, pname, param);
#endif
}

static void REGAL_CALL http_glImageTransformParameterivHP(GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glImageTransformParameterivHP)(target, pname, params);
#endif
}

// GL_IBM_multimode_draw_arrays

static void REGAL_CALL http_glMultiModeDrawArraysIBM(const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiModeDrawArraysIBM)(mode, first, count, primcount, modestride);
#endif
}

static void REGAL_CALL http_glMultiModeDrawElementsIBM(const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, GLint modestride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiModeDrawElementsIBM)(mode, count, type, indices, primcount, modestride);
#endif
}

// GL_IBM_vertex_array_lists

static void REGAL_CALL http_glColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorPointerListIBM)(size, type, stride, pointer, ptrstride);
#endif
}

static void REGAL_CALL http_glEdgeFlagPointerListIBM(GLint stride, const GLboolean **pointer, GLint ptrstride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEdgeFlagPointerListIBM)(stride, pointer, ptrstride);
#endif
}

static void REGAL_CALL http_glFogCoordPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoordPointerListIBM)(type, stride, pointer, ptrstride);
#endif
}

static void REGAL_CALL http_glIndexPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexPointerListIBM)(type, stride, pointer, ptrstride);
#endif
}

static void REGAL_CALL http_glNormalPointerListIBM(GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalPointerListIBM)(type, stride, pointer, ptrstride);
#endif
}

static void REGAL_CALL http_glSecondaryColorPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColorPointerListIBM)(size, type, stride, pointer, ptrstride);
#endif
}

static void REGAL_CALL http_glTexCoordPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoordPointerListIBM)(size, type, stride, pointer, ptrstride);
#endif
}

static void REGAL_CALL http_glVertexPointerListIBM(GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexPointerListIBM)(size, type, stride, pointer, ptrstride);
#endif
}

// GL_IMG_multisampled_render_to_texture

static void REGAL_CALL http_glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTexture2DMultisampleIMG)(target, attachment, textarget, texture, level, samples);
#endif
}

static void REGAL_CALL http_glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRenderbufferStorageMultisampleIMG)(target, samples, internalformat, width, height);
#endif
}

// GL_INGR_blend_func_separate

static void REGAL_CALL http_glBlendFuncSeparateINGR(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendFuncSeparateINGR)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
#endif
}

// GL_INTEL_map_texture

static GLvoid *REGAL_CALL http_glMapTexture2DINTEL(GLuint texture, GLint level, GLbitfield access, GLint *stride, GLenum *layout)
{
    GLvoid * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glMapTexture2DINTEL)(texture, level, access, stride, layout);
#endif
    return ret;
}

static void REGAL_CALL http_glSyncTextureINTEL(GLuint texture)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSyncTextureINTEL)(texture);
#endif
}

static void REGAL_CALL http_glUnmapTexture2DINTEL(GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUnmapTexture2DINTEL)(texture, level);
#endif
}

// GL_INTEL_parallel_arrays

static void REGAL_CALL http_glColorPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorPointervINTEL)(size, type, pointer);
#endif
}

static void REGAL_CALL http_glNormalPointervINTEL(GLenum type, const GLvoid **pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalPointervINTEL)(type, pointer);
#endif
}

static void REGAL_CALL http_glTexCoordPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoordPointervINTEL)(size, type, pointer);
#endif
}

static void REGAL_CALL http_glVertexPointervINTEL(GLint size, GLenum type, const GLvoid **pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexPointervINTEL)(size, type, pointer);
#endif
}

// GL_INTEL_texture_scissor

static void REGAL_CALL http_glTexScissorFuncINTEL(GLenum target, GLenum lfunc, GLenum hfunc)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexScissorFuncINTEL)(target, lfunc, hfunc);
#endif
}

static void REGAL_CALL http_glTexScissorINTEL(GLenum target, GLclampf tlow, GLclampf thigh)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexScissorINTEL)(target, tlow, thigh);
#endif
}

// GL_KHR_blend_equation_advanced

static void REGAL_CALL http_glBlendBarrierKHR(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendBarrierKHR)();
#endif
}

// GL_KHR_debug

static void REGAL_CALL http_glDebugMessageCallback(GLDEBUGPROC callback, const void *userParam)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDebugMessageCallback)(callback, userParam);
#endif
}

static void REGAL_CALL http_glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDebugMessageControl)(source, type, severity, count, ids, enabled);
#endif
}

static void REGAL_CALL http_glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDebugMessageInsert)(source, type, id, severity, length, buf);
#endif
}

static GLuint REGAL_CALL http_glGetDebugMessageLog(GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetDebugMessageLog)(count, bufsize, sources, types, ids, severities, lengths, messageLog);
#endif
    return ret;
}

static void REGAL_CALL http_glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetObjectLabel)(identifier, name, bufSize, length, label);
#endif
}

static void REGAL_CALL http_glGetObjectPtrLabel(const GLvoid *ptr, GLsizei bufSize, GLsizei *length, GLchar *label)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetObjectPtrLabel)(ptr, bufSize, length, label);
#endif
}

static void REGAL_CALL http_glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar *label)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glObjectLabel)(identifier, name, length, label);
#endif
}

static void REGAL_CALL http_glObjectPtrLabel(const GLvoid *ptr, GLsizei length, const GLchar *label)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glObjectPtrLabel)(ptr, length, label);
#endif
}

static void REGAL_CALL http_glPopDebugGroup(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPopDebugGroup)();
#endif
    if( _context ) {
      #if REGAL_HTTP
      DispatchHttpState &h = _context->http;
      if( h.runState == RS_StepOutOfGroup || h.runState == RS_NextGroup ) {
        h.runState = RS_Pause;
      }
      if( h.runState == RS_StepOverGroup && h.debugGroupStackDepth == h.stepOverGroupDepth ) {
        h.runState = RS_Pause;
      }
      h.debugGroupStackDepth--;
      #endif
    }
}

static void REGAL_CALL http_glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar *message)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.group++;
      if( _context->http.runState == RS_NextGroup ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.debugGroupStackDepth++;
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPushDebugGroup)(source, id, length, message);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastGroup = _context->http.count.call;
      #endif
    }
}

// GL_KHR_robustness

static void REGAL_CALL http_glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnUniformfv)(program, location, bufSize, params);
#endif
}

static void REGAL_CALL http_glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnUniformiv)(program, location, bufSize, params);
#endif
}

static void REGAL_CALL http_glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetnUniformuiv)(program, location, bufSize, params);
#endif
}

static void REGAL_CALL http_glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReadnPixels)(x, y, width, height, format, type, bufSize, data);
#endif
}

// GL_KTX_buffer_region

static GLuint REGAL_CALL http_glBufferRegionEnabled(void)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glBufferRegionEnabled)();
#endif
    return ret;
}

static void REGAL_CALL http_glDeleteBufferRegion(GLenum region)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteBufferRegion)(region);
#endif
}

static void REGAL_CALL http_glDrawBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawBufferRegion)(region, x, y, width, height, xDest, yDest);
#endif
}

static GLuint REGAL_CALL http_glNewBufferRegion(GLenum region)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glNewBufferRegion)(region);
#endif
    return ret;
}

static void REGAL_CALL http_glReadBufferRegion(GLuint region, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReadBufferRegion)(region, x, y, width, height);
#endif
}

// GL_MESA_resize_buffers

static void REGAL_CALL http_glResizeBuffersMESA(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glResizeBuffersMESA)();
#endif
}

// GL_MESA_window_pos

static void REGAL_CALL http_glWindowPos2dMESA(GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2dMESA)(x, y);
#endif
}

static void REGAL_CALL http_glWindowPos2dvMESA(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2dvMESA)(v);
#endif
}

static void REGAL_CALL http_glWindowPos2fMESA(GLfloat x, GLfloat y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2fMESA)(x, y);
#endif
}

static void REGAL_CALL http_glWindowPos2fvMESA(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2fvMESA)(v);
#endif
}

static void REGAL_CALL http_glWindowPos2iMESA(GLint x, GLint y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2iMESA)(x, y);
#endif
}

static void REGAL_CALL http_glWindowPos2ivMESA(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2ivMESA)(v);
#endif
}

static void REGAL_CALL http_glWindowPos2sMESA(GLshort x, GLshort y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2sMESA)(x, y);
#endif
}

static void REGAL_CALL http_glWindowPos2svMESA(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos2svMESA)(v);
#endif
}

static void REGAL_CALL http_glWindowPos3dMESA(GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3dMESA)(x, y, z);
#endif
}

static void REGAL_CALL http_glWindowPos3dvMESA(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3dvMESA)(v);
#endif
}

static void REGAL_CALL http_glWindowPos3fMESA(GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3fMESA)(x, y, z);
#endif
}

static void REGAL_CALL http_glWindowPos3fvMESA(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3fvMESA)(v);
#endif
}

static void REGAL_CALL http_glWindowPos3iMESA(GLint x, GLint y, GLint z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3iMESA)(x, y, z);
#endif
}

static void REGAL_CALL http_glWindowPos3ivMESA(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3ivMESA)(v);
#endif
}

static void REGAL_CALL http_glWindowPos3sMESA(GLshort x, GLshort y, GLshort z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3sMESA)(x, y, z);
#endif
}

static void REGAL_CALL http_glWindowPos3svMESA(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos3svMESA)(v);
#endif
}

static void REGAL_CALL http_glWindowPos4dMESA(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos4dMESA)(x, y, z, w);
#endif
}

static void REGAL_CALL http_glWindowPos4dvMESA(const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos4dvMESA)(v);
#endif
}

static void REGAL_CALL http_glWindowPos4fMESA(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos4fMESA)(x, y, z, w);
#endif
}

static void REGAL_CALL http_glWindowPos4fvMESA(const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos4fvMESA)(v);
#endif
}

static void REGAL_CALL http_glWindowPos4iMESA(GLint x, GLint y, GLint z, GLint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos4iMESA)(x, y, z, w);
#endif
}

static void REGAL_CALL http_glWindowPos4ivMESA(const GLint *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos4ivMESA)(v);
#endif
}

static void REGAL_CALL http_glWindowPos4sMESA(GLshort x, GLshort y, GLshort z, GLshort w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos4sMESA)(x, y, z, w);
#endif
}

static void REGAL_CALL http_glWindowPos4svMESA(const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWindowPos4svMESA)(v);
#endif
}

// GL_NVX_conditional_render

static void REGAL_CALL http_glBeginConditionalRenderNVX(GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginConditionalRenderNVX)(id);
#endif
}

static void REGAL_CALL http_glEndConditionalRenderNVX(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndConditionalRenderNVX)();
#endif
}

// GL_NV_bindless_texture

static GLuint64 REGAL_CALL http_glGetImageHandleNV(GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format)
{
    GLuint64  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetImageHandleNV)(texture, level, layered, layer, format);
#endif
    return ret;
}

static GLuint64 REGAL_CALL http_glGetTextureHandleNV(GLuint texture)
{
    GLuint64  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetTextureHandleNV)(texture);
#endif
    return ret;
}

static GLuint64 REGAL_CALL http_glGetTextureSamplerHandleNV(GLuint texture, GLuint sampler)
{
    GLuint64  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetTextureSamplerHandleNV)(texture, sampler);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glIsImageHandleResidentNV(GLuint64 handle)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsImageHandleResidentNV)(handle);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glIsTextureHandleResidentNV(GLuint64 handle)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsTextureHandleResidentNV)(handle);
#endif
    return ret;
}

static void REGAL_CALL http_glMakeImageHandleNonResidentNV(GLuint64 handle)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMakeImageHandleNonResidentNV)(handle);
#endif
}

static void REGAL_CALL http_glMakeImageHandleResidentNV(GLuint64 handle, GLenum access)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMakeImageHandleResidentNV)(handle, access);
#endif
}

static void REGAL_CALL http_glMakeTextureHandleNonResidentNV(GLuint64 handle)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMakeTextureHandleNonResidentNV)(handle);
#endif
}

static void REGAL_CALL http_glMakeTextureHandleResidentNV(GLuint64 handle)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMakeTextureHandleResidentNV)(handle);
#endif
}

static void REGAL_CALL http_glProgramUniformHandleui64NV(GLuint program, GLint location, GLuint64 value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformHandleui64NV)(program, location, value);
#endif
}

static void REGAL_CALL http_glProgramUniformHandleui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64 *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformHandleui64vNV)(program, location, count, values);
#endif
}

static void REGAL_CALL http_glUniformHandleui64NV(GLint location, GLuint64 value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformHandleui64NV)(location, value);
#endif
}

static void REGAL_CALL http_glUniformHandleui64vNV(GLint location, GLsizei count, const GLuint64 *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformHandleui64vNV)(location, count, value);
#endif
}

// GL_NV_blend_equation_advanced

static void REGAL_CALL http_glBlendBarrierNV(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendBarrierNV)();
#endif
}

static void REGAL_CALL http_glBlendParameteriNV(GLenum pname, GLint value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendParameteriNV)(pname, value);
#endif
}

// GL_NV_conditional_render

static void REGAL_CALL http_glBeginConditionalRenderNV(GLuint id, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginConditionalRenderNV)(id, mode);
#endif
}

static void REGAL_CALL http_glEndConditionalRenderNV(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndConditionalRenderNV)();
#endif
}

// GL_NV_copy_buffer

static void REGAL_CALL http_glCopyBufferSubDataNV(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyBufferSubDataNV)(readtarget, writetarget, readoffset, writeoffset, size);
#endif
}

// GL_NV_copy_image

static void REGAL_CALL http_glCopyImageSubDataNV(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyImageSubDataNV)(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
#endif
}

// GL_NV_coverage_sample

static void REGAL_CALL http_glCoverageMaskNV(GLboolean mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCoverageMaskNV)(mask);
#endif
}

static void REGAL_CALL http_glCoverageOperationNV(GLenum operation)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCoverageOperationNV)(operation);
#endif
}

// GL_NV_depth_buffer_float

static void REGAL_CALL http_glClearDepthdNV(GLdouble depth)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearDepthdNV)(depth);
#endif
}

static void REGAL_CALL http_glDepthBoundsdNV(GLdouble zmin, GLdouble zmax)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDepthBoundsdNV)(zmin, zmax);
#endif
}

static void REGAL_CALL http_glDepthRangedNV(GLdouble zNear, GLdouble zFar)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDepthRangedNV)(zNear, zFar);
#endif
}

// GL_NV_draw_buffers

static void REGAL_CALL http_glDrawBuffersNV(GLsizei n, const GLenum *bufs)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawBuffersNV)(n, bufs);
#endif
}

// GL_NV_draw_texture

static void REGAL_CALL http_glDrawTextureNV(GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawTextureNV)(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
#endif
}

// GL_NV_evaluators

static void REGAL_CALL http_glEvalMapsNV(GLenum target, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEvalMapsNV)(target, mode);
#endif
}

static void REGAL_CALL http_glGetMapAttribParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMapAttribParameterfvNV)(target, index, pname, params);
#endif
}

static void REGAL_CALL http_glGetMapAttribParameterivNV(GLenum target, GLuint index, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMapAttribParameterivNV)(target, index, pname, params);
#endif
}

static void REGAL_CALL http_glGetMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMapControlPointsNV)(target, index, type, ustride, vstride, packed, points);
#endif
}

static void REGAL_CALL http_glGetMapParameterfvNV(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMapParameterfvNV)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetMapParameterivNV(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMapParameterivNV)(target, pname, params);
#endif
}

static void REGAL_CALL http_glMapControlPointsNV(GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMapControlPointsNV)(target, index, type, ustride, vstride, uorder, vorder, packed, points);
#endif
}

static void REGAL_CALL http_glMapParameterfvNV(GLenum target, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMapParameterfvNV)(target, pname, params);
#endif
}

static void REGAL_CALL http_glMapParameterivNV(GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMapParameterivNV)(target, pname, params);
#endif
}

// GL_NV_explicit_multisample

static void REGAL_CALL http_glGetMultisamplefvNV(GLenum pname, GLuint index, GLfloat *val)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMultisamplefvNV)(pname, index, val);
#endif
}

static void REGAL_CALL http_glSampleMaskIndexedNV(GLuint index, GLbitfield mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSampleMaskIndexedNV)(index, mask);
#endif
}

static void REGAL_CALL http_glTexRenderbufferNV(GLenum target, GLuint renderbuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexRenderbufferNV)(target, renderbuffer);
#endif
}

// GL_NV_fence

static void REGAL_CALL http_glDeleteFencesNV(GLsizei n, const GLuint *fences)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteFencesNV)(n, fences);
#endif
}

static void REGAL_CALL http_glFinishFenceNV(GLuint fence)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFinishFenceNV)(fence);
#endif
}

static void REGAL_CALL http_glGenFencesNV(GLsizei n, GLuint *fences)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenFencesNV)(n, fences);
#endif
}

static void REGAL_CALL http_glGetFenceivNV(GLuint fence, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFenceivNV)(fence, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsFenceNV(GLuint fence)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsFenceNV)(fence);
#endif
    return ret;
}

static void REGAL_CALL http_glSetFenceNV(GLuint fence, GLenum condition)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSetFenceNV)(fence, condition);
#endif
}

static GLboolean REGAL_CALL http_glTestFenceNV(GLuint fence)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glTestFenceNV)(fence);
#endif
    return ret;
}

// GL_NV_fragment_program

static void REGAL_CALL http_glGetProgramNamedParameterdvNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramNamedParameterdvNV)(id, len, name, params);
#endif
}

static void REGAL_CALL http_glGetProgramNamedParameterfvNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramNamedParameterfvNV)(id, len, name, params);
#endif
}

static void REGAL_CALL http_glProgramNamedParameter4dNV(GLuint id, GLsizei len, const GLubyte *name, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramNamedParameter4dNV)(id, len, name, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramNamedParameter4dvNV(GLuint id, GLsizei len, const GLubyte *name, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramNamedParameter4dvNV)(id, len, name, v);
#endif
}

static void REGAL_CALL http_glProgramNamedParameter4fNV(GLuint id, GLsizei len, const GLubyte *name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramNamedParameter4fNV)(id, len, name, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramNamedParameter4fvNV(GLuint id, GLsizei len, const GLubyte *name, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramNamedParameter4fvNV)(id, len, name, v);
#endif
}

// GL_NV_framebuffer_blit

static void REGAL_CALL http_glBlitFramebufferNV(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlitFramebufferNV)(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
#endif
}

// GL_NV_framebuffer_multisample_coverage

static void REGAL_CALL http_glRenderbufferStorageMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRenderbufferStorageMultisampleCoverageNV)(target, coverageSamples, colorSamples, internalformat, width, height);
#endif
}

// GL_NV_geometry_program4

static void REGAL_CALL http_glProgramVertexLimitNV(GLenum target, GLint limit)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramVertexLimitNV)(target, limit);
#endif
}

// GL_NV_gpu_program4

static void REGAL_CALL http_glGetProgramEnvParameterIivNV(GLenum target, GLuint index, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramEnvParameterIivNV)(target, index, params);
#endif
}

static void REGAL_CALL http_glGetProgramEnvParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramEnvParameterIuivNV)(target, index, params);
#endif
}

static void REGAL_CALL http_glGetProgramLocalParameterIivNV(GLenum target, GLuint index, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramLocalParameterIivNV)(target, index, params);
#endif
}

static void REGAL_CALL http_glGetProgramLocalParameterIuivNV(GLenum target, GLuint index, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramLocalParameterIuivNV)(target, index, params);
#endif
}

static void REGAL_CALL http_glProgramEnvParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramEnvParameterI4iNV)(target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramEnvParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramEnvParameterI4ivNV)(target, index, params);
#endif
}

static void REGAL_CALL http_glProgramEnvParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramEnvParameterI4uiNV)(target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramEnvParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramEnvParameterI4uivNV)(target, index, params);
#endif
}

static void REGAL_CALL http_glProgramEnvParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramEnvParametersI4ivNV)(target, index, count, params);
#endif
}

static void REGAL_CALL http_glProgramEnvParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramEnvParametersI4uivNV)(target, index, count, params);
#endif
}

static void REGAL_CALL http_glProgramLocalParameterI4iNV(GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramLocalParameterI4iNV)(target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramLocalParameterI4ivNV(GLenum target, GLuint index, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramLocalParameterI4ivNV)(target, index, params);
#endif
}

static void REGAL_CALL http_glProgramLocalParameterI4uiNV(GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramLocalParameterI4uiNV)(target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramLocalParameterI4uivNV(GLenum target, GLuint index, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramLocalParameterI4uivNV)(target, index, params);
#endif
}

static void REGAL_CALL http_glProgramLocalParametersI4ivNV(GLenum target, GLuint index, GLsizei count, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramLocalParametersI4ivNV)(target, index, count, params);
#endif
}

static void REGAL_CALL http_glProgramLocalParametersI4uivNV(GLenum target, GLuint index, GLsizei count, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramLocalParametersI4uivNV)(target, index, count, params);
#endif
}

// GL_NV_gpu_shader5

static void REGAL_CALL http_glGetUniformi64vNV(GLuint program, GLint location, GLint64EXT *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetUniformi64vNV)(program, location, params);
#endif
}

static void REGAL_CALL http_glProgramUniform1i64NV(GLuint program, GLint location, GLint64EXT x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1i64NV)(program, location, x);
#endif
}

static void REGAL_CALL http_glProgramUniform1i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1i64vNV)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform1ui64NV(GLuint program, GLint location, GLuint64EXT x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1ui64NV)(program, location, x);
#endif
}

static void REGAL_CALL http_glProgramUniform1ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform1ui64vNV)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform2i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2i64NV)(program, location, x, y);
#endif
}

static void REGAL_CALL http_glProgramUniform2i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2i64vNV)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform2ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2ui64NV)(program, location, x, y);
#endif
}

static void REGAL_CALL http_glProgramUniform2ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform2ui64vNV)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform3i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3i64NV)(program, location, x, y, z);
#endif
}

static void REGAL_CALL http_glProgramUniform3i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3i64vNV)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform3ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3ui64NV)(program, location, x, y, z);
#endif
}

static void REGAL_CALL http_glProgramUniform3ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform3ui64vNV)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform4i64NV(GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4i64NV)(program, location, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramUniform4i64vNV(GLuint program, GLint location, GLsizei count, const GLint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4i64vNV)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glProgramUniform4ui64NV(GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4ui64NV)(program, location, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramUniform4ui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniform4ui64vNV)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glUniform1i64NV(GLint location, GLint64EXT x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1i64NV)(location, x);
#endif
}

static void REGAL_CALL http_glUniform1i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1i64vNV)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform1ui64NV(GLint location, GLuint64EXT x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1ui64NV)(location, x);
#endif
}

static void REGAL_CALL http_glUniform1ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform1ui64vNV)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform2i64NV(GLint location, GLint64EXT x, GLint64EXT y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2i64NV)(location, x, y);
#endif
}

static void REGAL_CALL http_glUniform2i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2i64vNV)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform2ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2ui64NV)(location, x, y);
#endif
}

static void REGAL_CALL http_glUniform2ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform2ui64vNV)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform3i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3i64NV)(location, x, y, z);
#endif
}

static void REGAL_CALL http_glUniform3i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3i64vNV)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform3ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3ui64NV)(location, x, y, z);
#endif
}

static void REGAL_CALL http_glUniform3ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform3ui64vNV)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform4i64NV(GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4i64NV)(location, x, y, z, w);
#endif
}

static void REGAL_CALL http_glUniform4i64vNV(GLint location, GLsizei count, const GLint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4i64vNV)(location, count, value);
#endif
}

static void REGAL_CALL http_glUniform4ui64NV(GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4ui64NV)(location, x, y, z, w);
#endif
}

static void REGAL_CALL http_glUniform4ui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniform4ui64vNV)(location, count, value);
#endif
}

// GL_NV_half_float

static void REGAL_CALL http_glColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3hNV)(red, green, blue);
#endif
}

static void REGAL_CALL http_glColor3hvNV(const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3hvNV)(v);
#endif
}

static void REGAL_CALL http_glColor4hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4hNV)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glColor4hvNV(const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4hvNV)(v);
#endif
}

static void REGAL_CALL http_glFogCoordhNV(GLhalfNV coord)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoordhNV)(coord);
#endif
}

static void REGAL_CALL http_glFogCoordhvNV(const GLhalfNV *coord)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoordhvNV)(coord);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1hNV(GLenum target, GLhalfNV s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1hNV)(target, s);
#endif
}

static void REGAL_CALL http_glMultiTexCoord1hvNV(GLenum target, const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord1hvNV)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2hNV(GLenum target, GLhalfNV s, GLhalfNV t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2hNV)(target, s, t);
#endif
}

static void REGAL_CALL http_glMultiTexCoord2hvNV(GLenum target, const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord2hvNV)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3hNV)(target, s, t, r);
#endif
}

static void REGAL_CALL http_glMultiTexCoord3hvNV(GLenum target, const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord3hvNV)(target, v);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4hNV(GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4hNV)(target, s, t, r, q);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4hvNV(GLenum target, const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4hvNV)(target, v);
#endif
}

static void REGAL_CALL http_glNormal3hNV(GLhalfNV nx, GLhalfNV ny, GLhalfNV nz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3hNV)(nx, ny, nz);
#endif
}

static void REGAL_CALL http_glNormal3hvNV(const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3hvNV)(v);
#endif
}

static void REGAL_CALL http_glSecondaryColor3hNV(GLhalfNV red, GLhalfNV green, GLhalfNV blue)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3hNV)(red, green, blue);
#endif
}

static void REGAL_CALL http_glSecondaryColor3hvNV(const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColor3hvNV)(v);
#endif
}

static void REGAL_CALL http_glTexCoord1hNV(GLhalfNV s)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord1hNV)(s);
#endif
}

static void REGAL_CALL http_glTexCoord1hvNV(const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord1hvNV)(v);
#endif
}

static void REGAL_CALL http_glTexCoord2hNV(GLhalfNV s, GLhalfNV t)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2hNV)(s, t);
#endif
}

static void REGAL_CALL http_glTexCoord2hvNV(const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2hvNV)(v);
#endif
}

static void REGAL_CALL http_glTexCoord3hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord3hNV)(s, t, r);
#endif
}

static void REGAL_CALL http_glTexCoord3hvNV(const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord3hvNV)(v);
#endif
}

static void REGAL_CALL http_glTexCoord4hNV(GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4hNV)(s, t, r, q);
#endif
}

static void REGAL_CALL http_glTexCoord4hvNV(const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4hvNV)(v);
#endif
}

static void REGAL_CALL http_glVertex2hNV(GLhalfNV x, GLhalfNV y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex2hNV)(x, y);
#endif
}

static void REGAL_CALL http_glVertex2hvNV(const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex2hvNV)(v);
#endif
}

static void REGAL_CALL http_glVertex3hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex3hNV)(x, y, z);
#endif
}

static void REGAL_CALL http_glVertex3hvNV(const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex3hvNV)(v);
#endif
}

static void REGAL_CALL http_glVertex4hNV(GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex4hNV)(x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertex4hvNV(const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertex4hvNV)(v);
#endif
}

static void REGAL_CALL http_glVertexAttrib1hNV(GLuint index, GLhalfNV x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1hNV)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttrib1hvNV(GLuint index, const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1hvNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib2hNV(GLuint index, GLhalfNV x, GLhalfNV y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2hNV)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttrib2hvNV(GLuint index, const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2hvNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib3hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3hNV)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttrib3hvNV(GLuint index, const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3hvNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4hNV(GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4hNV)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttrib4hvNV(GLuint index, const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4hvNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs1hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs1hvNV)(index, count, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs2hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs2hvNV)(index, count, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs3hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs3hvNV)(index, count, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs4hvNV(GLuint index, GLsizei count, const GLhalfNV *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs4hvNV)(index, count, v);
#endif
}

static void REGAL_CALL http_glVertexWeighthNV(GLhalfNV weight)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexWeighthNV)(weight);
#endif
}

static void REGAL_CALL http_glVertexWeighthvNV(const GLhalfNV *weight)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexWeighthvNV)(weight);
#endif
}

// GL_NV_non_square_matrices

static void REGAL_CALL http_glUniformMatrix2x3fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix2x3fvNV)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix2x4fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix2x4fvNV)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix3x2fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix3x2fvNV)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix3x4fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix3x4fvNV)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix4x2fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix4x2fvNV)(location, count, transpose, value);
#endif
}

static void REGAL_CALL http_glUniformMatrix4x3fvNV(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformMatrix4x3fvNV)(location, count, transpose, value);
#endif
}

// GL_NV_occlusion_query

static void REGAL_CALL http_glBeginOcclusionQueryNV(GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginOcclusionQueryNV)(id);
#endif
}

static void REGAL_CALL http_glDeleteOcclusionQueriesNV(GLsizei n, const GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteOcclusionQueriesNV)(n, ids);
#endif
}

static void REGAL_CALL http_glEndOcclusionQueryNV(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndOcclusionQueryNV)();
#endif
}

static void REGAL_CALL http_glGenOcclusionQueriesNV(GLsizei n, GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenOcclusionQueriesNV)(n, ids);
#endif
}

static void REGAL_CALL http_glGetOcclusionQueryivNV(GLuint id, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetOcclusionQueryivNV)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetOcclusionQueryuivNV(GLuint id, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetOcclusionQueryuivNV)(id, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsOcclusionQueryNV(GLuint id)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsOcclusionQueryNV)(id);
#endif
    return ret;
}

// GL_NV_parameter_buffer_object

static void REGAL_CALL http_glProgramBufferParametersIivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramBufferParametersIivNV)(target, buffer, index, count, params);
#endif
}

static void REGAL_CALL http_glProgramBufferParametersIuivNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramBufferParametersIuivNV)(target, buffer, index, count, params);
#endif
}

static void REGAL_CALL http_glProgramBufferParametersfvNV(GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramBufferParametersfvNV)(target, buffer, index, count, params);
#endif
}

// GL_NV_path_rendering

static void REGAL_CALL http_glCopyPathNV(GLuint resultPath, GLuint srcPath)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyPathNV)(resultPath, srcPath);
#endif
}

static void REGAL_CALL http_glCoverFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCoverFillPathInstancedNV)(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
#endif
}

static void REGAL_CALL http_glCoverFillPathNV(GLuint path, GLenum coverMode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCoverFillPathNV)(path, coverMode);
#endif
}

static void REGAL_CALL http_glCoverStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCoverStrokePathInstancedNV)(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
#endif
}

static void REGAL_CALL http_glCoverStrokePathNV(GLuint name, GLenum coverMode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCoverStrokePathNV)(name, coverMode);
#endif
}

static void REGAL_CALL http_glDeletePathsNV(GLuint path, GLsizei range)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeletePathsNV)(path, range);
#endif
}

static GLuint REGAL_CALL http_glGenPathsNV(GLsizei range)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGenPathsNV)(range);
#endif
    return ret;
}

static void REGAL_CALL http_glGetPathColorGenfvNV(GLenum color, GLenum pname, GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPathColorGenfvNV)(color, pname, value);
#endif
}

static void REGAL_CALL http_glGetPathColorGenivNV(GLenum color, GLenum pname, GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPathColorGenivNV)(color, pname, value);
#endif
}

static void REGAL_CALL http_glGetPathCommandsNV(GLuint name, GLubyte *commands)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPathCommandsNV)(name, commands);
#endif
}

static void REGAL_CALL http_glGetPathCoordsNV(GLuint name, GLfloat *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPathCoordsNV)(name, coords);
#endif
}

static void REGAL_CALL http_glGetPathDashArrayNV(GLuint name, GLfloat *dashArray)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPathDashArrayNV)(name, dashArray);
#endif
}

static GLfloat REGAL_CALL http_glGetPathLengthNV(GLuint path, GLsizei startSegment, GLsizei numSegments)
{
    GLfloat  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetPathLengthNV)(path, startSegment, numSegments);
#endif
    return ret;
}

static void REGAL_CALL http_glGetPathMetricRangeNV(GLbitfield metricQueryMask, GLuint fistPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPathMetricRangeNV)(metricQueryMask, fistPathName, numPaths, stride, metrics);
#endif
}

static void REGAL_CALL http_glGetPathMetricsNV(GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPathMetricsNV)(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
#endif
}

static void REGAL_CALL http_glGetPathParameterfvNV(GLuint name, GLenum param, GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPathParameterfvNV)(name, param, value);
#endif
}

static void REGAL_CALL http_glGetPathParameterivNV(GLuint name, GLenum param, GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPathParameterivNV)(name, param, value);
#endif
}

static void REGAL_CALL http_glGetPathSpacingNV(GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPathSpacingNV)(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
#endif
}

static void REGAL_CALL http_glGetPathTexGenfvNV(GLenum texCoordSet, GLenum pname, GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPathTexGenfvNV)(texCoordSet, pname, value);
#endif
}

static void REGAL_CALL http_glGetPathTexGenivNV(GLenum texCoordSet, GLenum pname, GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPathTexGenivNV)(texCoordSet, pname, value);
#endif
}

static void REGAL_CALL http_glInterpolatePathsNV(GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInterpolatePathsNV)(resultPath, pathA, pathB, weight);
#endif
}

static GLboolean REGAL_CALL http_glIsPathNV(GLuint path)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsPathNV)(path);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glIsPointInFillPathNV(GLuint path, GLuint mask, GLfloat x, GLfloat y)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsPointInFillPathNV)(path, mask, x, y);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glIsPointInStrokePathNV(GLuint path, GLfloat x, GLfloat y)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsPointInStrokePathNV)(path, x, y);
#endif
    return ret;
}

static void REGAL_CALL http_glPathColorGenNV(GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathColorGenNV)(color, genMode, colorFormat, coeffs);
#endif
}

static void REGAL_CALL http_glPathCommandsNV(GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathCommandsNV)(path, numCommands, commands, numCoords, coordType, coords);
#endif
}

static void REGAL_CALL http_glPathCoordsNV(GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathCoordsNV)(path, numCoords, coordType, coords);
#endif
}

static void REGAL_CALL http_glPathCoverDepthFuncNV(GLenum zfunc)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathCoverDepthFuncNV)(zfunc);
#endif
}

static void REGAL_CALL http_glPathDashArrayNV(GLuint path, GLsizei dashCount, const GLfloat *dashArray)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathDashArrayNV)(path, dashCount, dashArray);
#endif
}

static void REGAL_CALL http_glPathFogGenNV(GLenum genMode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathFogGenNV)(genMode);
#endif
}

static void REGAL_CALL http_glPathGlyphRangeNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathGlyphRangeNV)(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
#endif
}

static void REGAL_CALL http_glPathGlyphsNV(GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathGlyphsNV)(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
#endif
}

static void REGAL_CALL http_glPathParameterfNV(GLuint path, GLenum pname, GLfloat value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathParameterfNV)(path, pname, value);
#endif
}

static void REGAL_CALL http_glPathParameterfvNV(GLuint path, GLenum pname, const GLfloat *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathParameterfvNV)(path, pname, value);
#endif
}

static void REGAL_CALL http_glPathParameteriNV(GLuint path, GLenum pname, GLint value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathParameteriNV)(path, pname, value);
#endif
}

static void REGAL_CALL http_glPathParameterivNV(GLuint path, GLenum pname, const GLint *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathParameterivNV)(path, pname, value);
#endif
}

static void REGAL_CALL http_glPathStencilDepthOffsetNV(GLfloat factor, GLfloat units)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathStencilDepthOffsetNV)(factor, units);
#endif
}

static void REGAL_CALL http_glPathStencilFuncNV(GLenum func, GLint ref, GLuint mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathStencilFuncNV)(func, ref, mask);
#endif
}

static void REGAL_CALL http_glPathStringNV(GLuint path, GLenum format, GLsizei length, const GLvoid *pathString)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathStringNV)(path, format, length, pathString);
#endif
}

static void REGAL_CALL http_glPathSubCommandsNV(GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathSubCommandsNV)(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
#endif
}

static void REGAL_CALL http_glPathSubCoordsNV(GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid *coords)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathSubCoordsNV)(path, coordStart, numCoords, coordType, coords);
#endif
}

static void REGAL_CALL http_glPathTexGenNV(GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPathTexGenNV)(texCoordSet, genMode, components, coeffs);
#endif
}

static GLboolean REGAL_CALL http_glPointAlongPathNV(GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat *x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glPointAlongPathNV)(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
#endif
    return ret;
}

static void REGAL_CALL http_glStencilFillPathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilFillPathInstancedNV)(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
#endif
}

static void REGAL_CALL http_glStencilFillPathNV(GLuint path, GLenum fillMode, GLuint mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilFillPathNV)(path, fillMode, mask);
#endif
}

static void REGAL_CALL http_glStencilStrokePathInstancedNV(GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilStrokePathInstancedNV)(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
#endif
}

static void REGAL_CALL http_glStencilStrokePathNV(GLuint path, GLint reference, GLuint mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStencilStrokePathNV)(path, reference, mask);
#endif
}

static void REGAL_CALL http_glTransformPathNV(GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat *transformValues)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTransformPathNV)(resultPath, srcPath, transformType, transformValues);
#endif
}

static void REGAL_CALL http_glWeightPathsNV(GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWeightPathsNV)(resultPath, numPaths, paths, weights);
#endif
}

// GL_NV_pixel_data_range

static void REGAL_CALL http_glFlushPixelDataRangeNV(GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFlushPixelDataRangeNV)(target);
#endif
}

static void REGAL_CALL http_glPixelDataRangeNV(GLenum target, GLsizei size, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelDataRangeNV)(target, size, pointer);
#endif
}

// GL_NV_point_sprite

static void REGAL_CALL http_glPointParameteriNV(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameteriNV)(pname, param);
#endif
}

static void REGAL_CALL http_glPointParameterivNV(GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameterivNV)(pname, params);
#endif
}

// GL_NV_present_video

static void REGAL_CALL http_glGetVideoi64vNV(GLuint video_slot, GLenum pname, GLint64EXT *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVideoi64vNV)(video_slot, pname, params);
#endif
}

static void REGAL_CALL http_glGetVideoivNV(GLuint video_slot, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVideoivNV)(video_slot, pname, params);
#endif
}

static void REGAL_CALL http_glGetVideoui64vNV(GLuint video_slot, GLenum pname, GLuint64EXT *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVideoui64vNV)(video_slot, pname, params);
#endif
}

static void REGAL_CALL http_glGetVideouivNV(GLuint video_slot, GLenum pname, GLuint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVideouivNV)(video_slot, pname, params);
#endif
}

static void REGAL_CALL http_glPresentFrameDualFillNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPresentFrameDualFillNV)(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
#endif
}

static void REGAL_CALL http_glPresentFrameKeyedNV(GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPresentFrameKeyedNV)(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
#endif
}

// GL_NV_primitive_restart

static void REGAL_CALL http_glPrimitiveRestartIndexNV(GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPrimitiveRestartIndexNV)(index);
#endif
}

static void REGAL_CALL http_glPrimitiveRestartNV(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPrimitiveRestartNV)();
#endif
}

// GL_NV_read_buffer

static void REGAL_CALL http_glReadBufferNV(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReadBufferNV)(mode);
#endif
}

// GL_NV_register_combiners

static void REGAL_CALL http_glCombinerInputNV(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCombinerInputNV)(stage, portion, variable, input, mapping, componentUsage);
#endif
}

static void REGAL_CALL http_glCombinerOutputNV(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCombinerOutputNV)(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
#endif
}

static void REGAL_CALL http_glCombinerParameterfNV(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCombinerParameterfNV)(pname, param);
#endif
}

static void REGAL_CALL http_glCombinerParameterfvNV(GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCombinerParameterfvNV)(pname, params);
#endif
}

static void REGAL_CALL http_glCombinerParameteriNV(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCombinerParameteriNV)(pname, param);
#endif
}

static void REGAL_CALL http_glCombinerParameterivNV(GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCombinerParameterivNV)(pname, params);
#endif
}

static void REGAL_CALL http_glFinalCombinerInputNV(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFinalCombinerInputNV)(variable, input, mapping, componentUsage);
#endif
}

static void REGAL_CALL http_glGetCombinerInputParameterfvNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetCombinerInputParameterfvNV)(stage, portion, variable, pname, params);
#endif
}

static void REGAL_CALL http_glGetCombinerInputParameterivNV(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetCombinerInputParameterivNV)(stage, portion, variable, pname, params);
#endif
}

static void REGAL_CALL http_glGetCombinerOutputParameterfvNV(GLenum stage, GLenum portion, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetCombinerOutputParameterfvNV)(stage, portion, pname, params);
#endif
}

static void REGAL_CALL http_glGetCombinerOutputParameterivNV(GLenum stage, GLenum portion, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetCombinerOutputParameterivNV)(stage, portion, pname, params);
#endif
}

static void REGAL_CALL http_glGetFinalCombinerInputParameterfvNV(GLenum variable, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFinalCombinerInputParameterfvNV)(variable, pname, params);
#endif
}

static void REGAL_CALL http_glGetFinalCombinerInputParameterivNV(GLenum variable, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFinalCombinerInputParameterivNV)(variable, pname, params);
#endif
}

// GL_NV_register_combiners2

static void REGAL_CALL http_glCombinerStageParameterfvNV(GLenum stage, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCombinerStageParameterfvNV)(stage, pname, params);
#endif
}

static void REGAL_CALL http_glGetCombinerStageParameterfvNV(GLenum stage, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetCombinerStageParameterfvNV)(stage, pname, params);
#endif
}

// GL_NV_shader_buffer_load

static void REGAL_CALL http_glGetBufferParameterui64vNV(GLenum target, GLenum pname, GLuint64EXT *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetBufferParameterui64vNV)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetIntegerui64vNV(GLenum target, GLuint64EXT *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetIntegerui64vNV)(target, data);
#endif
}

static void REGAL_CALL http_glGetNamedBufferParameterui64vNV(GLuint buffer, GLenum pname, GLuint64EXT *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetNamedBufferParameterui64vNV)(buffer, pname, params);
#endif
}

static void REGAL_CALL http_glGetUniformui64vNV(GLuint program, GLint location, GLuint64EXT *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetUniformui64vNV)(program, location, params);
#endif
}

static GLboolean REGAL_CALL http_glIsBufferResidentNV(GLenum target)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsBufferResidentNV)(target);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glIsNamedBufferResidentNV(GLuint buffer)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsNamedBufferResidentNV)(buffer);
#endif
    return ret;
}

static void REGAL_CALL http_glMakeBufferNonResidentNV(GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMakeBufferNonResidentNV)(target);
#endif
}

static void REGAL_CALL http_glMakeBufferResidentNV(GLenum target, GLenum access)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMakeBufferResidentNV)(target, access);
#endif
}

static void REGAL_CALL http_glMakeNamedBufferNonResidentNV(GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMakeNamedBufferNonResidentNV)(buffer);
#endif
}

static void REGAL_CALL http_glMakeNamedBufferResidentNV(GLuint buffer, GLenum access)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMakeNamedBufferResidentNV)(buffer, access);
#endif
}

static void REGAL_CALL http_glProgramUniformui64NV(GLuint program, GLint location, GLuint64EXT v0)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformui64NV)(program, location, v0);
#endif
}

static void REGAL_CALL http_glProgramUniformui64vNV(GLuint program, GLint location, GLsizei count, const GLuint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramUniformui64vNV)(program, location, count, value);
#endif
}

static void REGAL_CALL http_glUniformui64NV(GLint location, GLuint64EXT v0)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformui64NV)(location, v0);
#endif
}

static void REGAL_CALL http_glUniformui64vNV(GLint location, GLsizei count, const GLuint64EXT *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glUniformui64vNV)(location, count, value);
#endif
}

// GL_NV_texture_barrier

static void REGAL_CALL http_glTextureBarrierNV(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureBarrierNV)();
#endif
}

// GL_NV_texture_multisample

static void REGAL_CALL http_glTexImage2DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexImage2DMultisampleCoverageNV)(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
#endif
}

static void REGAL_CALL http_glTexImage3DMultisampleCoverageNV(GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexImage3DMultisampleCoverageNV)(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
#endif
}

static void REGAL_CALL http_glTextureImage2DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureImage2DMultisampleCoverageNV)(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
#endif
}

static void REGAL_CALL http_glTextureImage2DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureImage2DMultisampleNV)(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
#endif
}

static void REGAL_CALL http_glTextureImage3DMultisampleCoverageNV(GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureImage3DMultisampleCoverageNV)(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
#endif
}

static void REGAL_CALL http_glTextureImage3DMultisampleNV(GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureImage3DMultisampleNV)(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
#endif
}

// GL_NV_transform_feedback

static void REGAL_CALL http_glActiveVaryingNV(GLuint program, const GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glActiveVaryingNV)(program, name);
#endif
}

static void REGAL_CALL http_glBeginTransformFeedbackNV(GLenum primitiveMode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginTransformFeedbackNV)(primitiveMode);
#endif
}

static void REGAL_CALL http_glBindBufferBaseNV(GLenum target, GLuint index, GLuint buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindBufferBaseNV)(target, index, buffer);
#endif
}

static void REGAL_CALL http_glBindBufferOffsetNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindBufferOffsetNV)(target, index, buffer, offset);
#endif
}

static void REGAL_CALL http_glBindBufferRangeNV(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindBufferRangeNV)(target, index, buffer, offset, size);
#endif
}

static void REGAL_CALL http_glEndTransformFeedbackNV(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndTransformFeedbackNV)();
#endif
}

static void REGAL_CALL http_glGetActiveVaryingNV(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetActiveVaryingNV)(program, index, bufSize, length, size, type, name);
#endif
}

static void REGAL_CALL http_glGetTransformFeedbackVaryingNV(GLuint program, GLuint index, GLint *location)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTransformFeedbackVaryingNV)(program, index, location);
#endif
}

static GLint REGAL_CALL http_glGetVaryingLocationNV(GLuint program, const GLchar *name)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetVaryingLocationNV)(program, name);
#endif
    return ret;
}

static void REGAL_CALL http_glTransformFeedbackAttribsNV(GLuint count, const GLint *attribs, GLenum bufferMode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTransformFeedbackAttribsNV)(count, attribs, bufferMode);
#endif
}

static void REGAL_CALL http_glTransformFeedbackVaryingsNV(GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTransformFeedbackVaryingsNV)(program, count, locations, bufferMode);
#endif
}

// GL_NV_transform_feedback2

static void REGAL_CALL http_glBindTransformFeedbackNV(GLenum target, GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindTransformFeedbackNV)(target, id);
#endif
}

static void REGAL_CALL http_glDeleteTransformFeedbacksNV(GLsizei n, const GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteTransformFeedbacksNV)(n, ids);
#endif
}

static void REGAL_CALL http_glDrawTransformFeedbackNV(GLenum mode, GLuint name)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawTransformFeedbackNV)(mode, name);
#endif
}

static void REGAL_CALL http_glGenTransformFeedbacksNV(GLsizei n, GLuint *ids)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenTransformFeedbacksNV)(n, ids);
#endif
}

static GLboolean REGAL_CALL http_glIsTransformFeedbackNV(GLuint id)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsTransformFeedbackNV)(id);
#endif
    return ret;
}

static void REGAL_CALL http_glPauseTransformFeedbackNV(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPauseTransformFeedbackNV)();
#endif
}

static void REGAL_CALL http_glResumeTransformFeedbackNV(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glResumeTransformFeedbackNV)();
#endif
}

// GL_NV_vdpau_interop

static void REGAL_CALL http_glVDPAUFiniNV(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVDPAUFiniNV)();
#endif
}

static void REGAL_CALL http_glVDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVDPAUGetSurfaceivNV)(surface, pname, bufSize, length, values);
#endif
}

static void REGAL_CALL http_glVDPAUInitNV(const GLvoid *vdpDevice, const GLvoid *getProcAddress)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVDPAUInitNV)(vdpDevice, getProcAddress);
#endif
}

static GLboolean REGAL_CALL http_glVDPAUIsSurfaceNV(GLvdpauSurfaceNV surface)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glVDPAUIsSurfaceNV)(surface);
#endif
    return ret;
}

static void REGAL_CALL http_glVDPAUMapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVDPAUMapSurfacesNV)(numSurfaces, surfaces);
#endif
}

static GLvdpauSurfaceNV REGAL_CALL http_glVDPAURegisterOutputSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
{
    GLvdpauSurfaceNV  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glVDPAURegisterOutputSurfaceNV)(vdpSurface, target, numTextureNames, textureNames);
#endif
    return ret;
}

static GLvdpauSurfaceNV REGAL_CALL http_glVDPAURegisterVideoSurfaceNV(const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames)
{
    GLvdpauSurfaceNV  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glVDPAURegisterVideoSurfaceNV)(vdpSurface, target, numTextureNames, textureNames);
#endif
    return ret;
}

static void REGAL_CALL http_glVDPAUSurfaceAccessNV(GLvdpauSurfaceNV surface, GLenum access)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVDPAUSurfaceAccessNV)(surface, access);
#endif
}

static void REGAL_CALL http_glVDPAUUnmapSurfacesNV(GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVDPAUUnmapSurfacesNV)(numSurfaces, surfaces);
#endif
}

static void REGAL_CALL http_glVDPAUUnregisterSurfaceNV(GLvdpauSurfaceNV surface)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVDPAUUnregisterSurfaceNV)(surface);
#endif
}

// GL_NV_vertex_array_range

static void REGAL_CALL http_glFlushVertexArrayRangeNV(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFlushVertexArrayRangeNV)();
#endif
}

static void REGAL_CALL http_glVertexArrayRangeNV(GLsizei size, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexArrayRangeNV)(size, pointer);
#endif
}

// GL_NV_vertex_attrib_integer_64bit

static void REGAL_CALL http_glGetVertexAttribLi64vNV(GLuint index, GLenum pname, GLint64EXT *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribLi64vNV)(index, pname, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribLui64vNV(GLuint index, GLenum pname, GLuint64EXT *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribLui64vNV)(index, pname, params);
#endif
}

static void REGAL_CALL http_glVertexAttribL1i64NV(GLuint index, GLint64EXT x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL1i64NV)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttribL1i64vNV(GLuint index, const GLint64EXT *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL1i64vNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribL1ui64NV(GLuint index, GLuint64EXT x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL1ui64NV)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttribL1ui64vNV(GLuint index, const GLuint64EXT *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL1ui64vNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribL2i64NV(GLuint index, GLint64EXT x, GLint64EXT y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL2i64NV)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttribL2i64vNV(GLuint index, const GLint64EXT *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL2i64vNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribL2ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL2ui64NV)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttribL2ui64vNV(GLuint index, const GLuint64EXT *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL2ui64vNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribL3i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL3i64NV)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttribL3i64vNV(GLuint index, const GLint64EXT *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL3i64vNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribL3ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL3ui64NV)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttribL3ui64vNV(GLuint index, const GLuint64EXT *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL3ui64vNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribL4i64NV(GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL4i64NV)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttribL4i64vNV(GLuint index, const GLint64EXT *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL4i64vNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribL4ui64NV(GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL4ui64NV)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttribL4ui64vNV(GLuint index, const GLuint64EXT *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribL4ui64vNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribLFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribLFormatNV)(index, size, type, stride);
#endif
}

// GL_NV_vertex_buffer_unified_memory

static void REGAL_CALL http_glBufferAddressRangeNV(GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBufferAddressRangeNV)(pname, index, address, length);
#endif
}

static void REGAL_CALL http_glColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorFormatNV)(size, type, stride);
#endif
}

static void REGAL_CALL http_glEdgeFlagFormatNV(GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEdgeFlagFormatNV)(stride);
#endif
}

static void REGAL_CALL http_glFogCoordFormatNV(GLenum type, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogCoordFormatNV)(type, stride);
#endif
}

static void REGAL_CALL http_glGetIntegerui64i_vNV(GLenum target, GLuint index, GLuint64EXT *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetIntegerui64i_vNV)(target, index, data);
#endif
}

static void REGAL_CALL http_glIndexFormatNV(GLenum type, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIndexFormatNV)(type, stride);
#endif
}

static void REGAL_CALL http_glNormalFormatNV(GLenum type, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormalFormatNV)(type, stride);
#endif
}

static void REGAL_CALL http_glSecondaryColorFormatNV(GLint size, GLenum type, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSecondaryColorFormatNV)(size, type, stride);
#endif
}

static void REGAL_CALL http_glTexCoordFormatNV(GLint size, GLenum type, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoordFormatNV)(size, type, stride);
#endif
}

static void REGAL_CALL http_glVertexAttribFormatNV(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribFormatNV)(index, size, type, normalized, stride);
#endif
}

static void REGAL_CALL http_glVertexAttribIFormatNV(GLuint index, GLint size, GLenum type, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribIFormatNV)(index, size, type, stride);
#endif
}

static void REGAL_CALL http_glVertexFormatNV(GLint size, GLenum type, GLsizei stride)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexFormatNV)(size, type, stride);
#endif
}

// GL_NV_vertex_program

static GLboolean REGAL_CALL http_glAreProgramsResidentNV(GLsizei n, const GLuint *programs, GLboolean *residences)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glAreProgramsResidentNV)(n, programs, residences);
#endif
    return ret;
}

static void REGAL_CALL http_glBindProgramNV(GLenum target, GLuint id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindProgramNV)(target, id);
#endif
}

static void REGAL_CALL http_glDeleteProgramsNV(GLsizei n, const GLuint *programs)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteProgramsNV)(n, programs);
#endif
}

static void REGAL_CALL http_glExecuteProgramNV(GLenum target, GLuint id, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glExecuteProgramNV)(target, id, params);
#endif
}

static void REGAL_CALL http_glGenProgramsNV(GLsizei n, GLuint *programs)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenProgramsNV)(n, programs);
#endif
}

static void REGAL_CALL http_glGetProgramParameterdvNV(GLenum target, GLuint index, GLenum pname, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramParameterdvNV)(target, index, pname, params);
#endif
}

static void REGAL_CALL http_glGetProgramParameterfvNV(GLenum target, GLuint index, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramParameterfvNV)(target, index, pname, params);
#endif
}

static void REGAL_CALL http_glGetProgramStringNV(GLuint id, GLenum pname, GLubyte *program)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramStringNV)(id, pname, program);
#endif
}

static void REGAL_CALL http_glGetProgramivNV(GLuint id, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramivNV)(id, pname, params);
#endif
}

static void REGAL_CALL http_glGetTrackMatrixivNV(GLenum target, GLuint address, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTrackMatrixivNV)(target, address, pname, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribPointervNV(GLuint index, GLenum pname, GLvoid **pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribPointervNV)(index, pname, pointer);
#endif
}

static void REGAL_CALL http_glGetVertexAttribdvNV(GLuint index, GLenum pname, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribdvNV)(index, pname, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribfvNV(GLuint index, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribfvNV)(index, pname, params);
#endif
}

static void REGAL_CALL http_glGetVertexAttribivNV(GLuint index, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVertexAttribivNV)(index, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsProgramNV(GLuint id)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsProgramNV)(id);
#endif
    return ret;
}

static void REGAL_CALL http_glLoadProgramNV(GLenum target, GLuint id, GLsizei len, const GLubyte *program)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLoadProgramNV)(target, id, len, program);
#endif
}

static void REGAL_CALL http_glProgramParameter4dNV(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramParameter4dNV)(target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramParameter4dvNV(GLenum target, GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramParameter4dvNV)(target, index, v);
#endif
}

static void REGAL_CALL http_glProgramParameter4fNV(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramParameter4fNV)(target, index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glProgramParameter4fvNV(GLenum target, GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramParameter4fvNV)(target, index, v);
#endif
}

static void REGAL_CALL http_glProgramParameters4dvNV(GLenum target, GLuint index, GLsizei count, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramParameters4dvNV)(target, index, count, v);
#endif
}

static void REGAL_CALL http_glProgramParameters4fvNV(GLenum target, GLuint index, GLsizei count, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramParameters4fvNV)(target, index, count, v);
#endif
}

static void REGAL_CALL http_glRequestResidentProgramsNV(GLsizei n, const GLuint *programs)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRequestResidentProgramsNV)(n, programs);
#endif
}

static void REGAL_CALL http_glTrackMatrixNV(GLenum target, GLuint address, GLenum matrix, GLenum transform)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTrackMatrixNV)(target, address, matrix, transform);
#endif
}

static void REGAL_CALL http_glVertexAttrib1dNV(GLuint index, GLdouble x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1dNV)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttrib1dvNV(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1dvNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib1fNV(GLuint index, GLfloat x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1fNV)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttrib1fvNV(GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1fvNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib1sNV(GLuint index, GLshort x)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1sNV)(index, x);
#endif
}

static void REGAL_CALL http_glVertexAttrib1svNV(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib1svNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib2dNV(GLuint index, GLdouble x, GLdouble y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2dNV)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttrib2dvNV(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2dvNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib2fNV(GLuint index, GLfloat x, GLfloat y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2fNV)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttrib2fvNV(GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2fvNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib2sNV(GLuint index, GLshort x, GLshort y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2sNV)(index, x, y);
#endif
}

static void REGAL_CALL http_glVertexAttrib2svNV(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib2svNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib3dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3dNV)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttrib3dvNV(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3dvNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib3fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3fNV)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttrib3fvNV(GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3fvNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib3sNV(GLuint index, GLshort x, GLshort y, GLshort z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3sNV)(index, x, y, z);
#endif
}

static void REGAL_CALL http_glVertexAttrib3svNV(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib3svNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4dNV(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4dNV)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttrib4dvNV(GLuint index, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4dvNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4fNV(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4fNV)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttrib4fvNV(GLuint index, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4fvNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4sNV(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4sNV)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttrib4svNV(GLuint index, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4svNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttrib4ubNV(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4ubNV)(index, x, y, z, w);
#endif
}

static void REGAL_CALL http_glVertexAttrib4ubvNV(GLuint index, const GLubyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttrib4ubvNV)(index, v);
#endif
}

static void REGAL_CALL http_glVertexAttribPointerNV(GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribPointerNV)(index, fsize, type, stride, pointer);
#endif
}

static void REGAL_CALL http_glVertexAttribs1dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs1dvNV)(index, n, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs1fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs1fvNV)(index, n, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs1svNV(GLuint index, GLsizei n, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs1svNV)(index, n, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs2dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs2dvNV)(index, n, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs2fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs2fvNV)(index, n, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs2svNV(GLuint index, GLsizei n, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs2svNV)(index, n, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs3dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs3dvNV)(index, n, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs3fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs3fvNV)(index, n, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs3svNV(GLuint index, GLsizei n, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs3svNV)(index, n, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs4dvNV(GLuint index, GLsizei n, const GLdouble *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs4dvNV)(index, n, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs4fvNV(GLuint index, GLsizei n, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs4fvNV)(index, n, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs4svNV(GLuint index, GLsizei n, const GLshort *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs4svNV)(index, n, v);
#endif
}

static void REGAL_CALL http_glVertexAttribs4ubvNV(GLuint index, GLsizei n, const GLubyte *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVertexAttribs4ubvNV)(index, n, v);
#endif
}

// GL_NV_video_capture

static void REGAL_CALL http_glBeginVideoCaptureNV(GLuint video_capture_slot)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBeginVideoCaptureNV)(video_capture_slot);
#endif
}

static void REGAL_CALL http_glBindVideoCaptureStreamBufferNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptr offset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindVideoCaptureStreamBufferNV)(video_capture_slot, stream, frame_region, offset);
#endif
}

static void REGAL_CALL http_glBindVideoCaptureStreamTextureNV(GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindVideoCaptureStreamTextureNV)(video_capture_slot, stream, frame_region, target, texture);
#endif
}

static void REGAL_CALL http_glEndVideoCaptureNV(GLuint video_capture_slot)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndVideoCaptureNV)(video_capture_slot);
#endif
}

static void REGAL_CALL http_glGetVideoCaptureStreamdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVideoCaptureStreamdvNV)(video_capture_slot, stream, pname, params);
#endif
}

static void REGAL_CALL http_glGetVideoCaptureStreamfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVideoCaptureStreamfvNV)(video_capture_slot, stream, pname, params);
#endif
}

static void REGAL_CALL http_glGetVideoCaptureStreamivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVideoCaptureStreamivNV)(video_capture_slot, stream, pname, params);
#endif
}

static void REGAL_CALL http_glGetVideoCaptureivNV(GLuint video_capture_slot, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetVideoCaptureivNV)(video_capture_slot, pname, params);
#endif
}

static GLenum REGAL_CALL http_glVideoCaptureNV(GLuint video_capture_slot, GLuint *sequence_num, GLuint64EXT *capture_time)
{
    GLenum  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glVideoCaptureNV)(video_capture_slot, sequence_num, capture_time);
#endif
    return ret;
}

static void REGAL_CALL http_glVideoCaptureStreamParameterdvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVideoCaptureStreamParameterdvNV)(video_capture_slot, stream, pname, params);
#endif
}

static void REGAL_CALL http_glVideoCaptureStreamParameterfvNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVideoCaptureStreamParameterfvNV)(video_capture_slot, stream, pname, params);
#endif
}

static void REGAL_CALL http_glVideoCaptureStreamParameterivNV(GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glVideoCaptureStreamParameterivNV)(video_capture_slot, stream, pname, params);
#endif
}

// GL_OES_blend_equation_separate

static void REGAL_CALL http_glBlendEquationSeparateOES(GLenum modeRGB, GLenum modeAlpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendEquationSeparateOES)(modeRGB, modeAlpha);
#endif
}

// GL_OES_blend_func_separate

static void REGAL_CALL http_glBlendFuncSeparateOES(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendFuncSeparateOES)(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
#endif
}

// GL_OES_blend_subtract

static void REGAL_CALL http_glBlendEquationOES(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBlendEquationOES)(mode);
#endif
}

// GL_OES_framebuffer_object

static void REGAL_CALL http_glBindFramebufferOES(GLenum target, GLuint framebuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindFramebufferOES)(target, framebuffer);
#endif
}

static void REGAL_CALL http_glBindRenderbufferOES(GLenum target, GLuint renderbuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindRenderbufferOES)(target, renderbuffer);
#endif
}

static GLenum REGAL_CALL http_glCheckFramebufferStatusOES(GLenum target)
{
    GLenum  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glCheckFramebufferStatusOES)(target);
#endif
    return ret;
}

static void REGAL_CALL http_glDeleteFramebuffersOES(GLsizei n, const GLuint *framebuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteFramebuffersOES)(n, framebuffers);
#endif
}

static void REGAL_CALL http_glDeleteRenderbuffersOES(GLsizei n, const GLuint *renderbuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteRenderbuffersOES)(n, renderbuffers);
#endif
}

static void REGAL_CALL http_glFramebufferRenderbufferOES(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferRenderbufferOES)(target, attachment, renderbuffertarget, renderbuffer);
#endif
}

static void REGAL_CALL http_glFramebufferTexture2DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTexture2DOES)(target, attachment, textarget, texture, level);
#endif
}

static void REGAL_CALL http_glGenFramebuffersOES(GLsizei n, GLuint *framebuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenFramebuffersOES)(n, framebuffers);
#endif
}

static void REGAL_CALL http_glGenRenderbuffersOES(GLsizei n, GLuint *renderbuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenRenderbuffersOES)(n, renderbuffers);
#endif
}

static void REGAL_CALL http_glGenerateMipmapOES(GLenum target)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenerateMipmapOES)(target);
#endif
}

static void REGAL_CALL http_glGetFramebufferAttachmentParameterivOES(GLenum target, GLenum attachment, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFramebufferAttachmentParameterivOES)(target, attachment, pname, params);
#endif
}

static void REGAL_CALL http_glGetRenderbufferParameterivOES(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetRenderbufferParameterivOES)(target, pname, params);
#endif
}

static GLboolean REGAL_CALL http_glIsFramebufferOES(GLuint framebuffer)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsFramebufferOES)(framebuffer);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glIsRenderbufferOES(GLuint renderbuffer)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsRenderbufferOES)(renderbuffer);
#endif
    return ret;
}

static void REGAL_CALL http_glRenderbufferStorageOES(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRenderbufferStorageOES)(target, internalformat, width, height);
#endif
}

// GL_OES_get_program_binary

static void REGAL_CALL http_glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetProgramBinaryOES)(program, bufSize, length, binaryFormat, binary);
#endif
}

static void REGAL_CALL http_glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLint length)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glProgramBinaryOES)(program, binaryFormat, binary, length);
#endif
}

// GL_OES_mapbuffer

static void REGAL_CALL http_glGetBufferPointervOES(GLenum target, GLenum pname, GLvoid **params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetBufferPointervOES)(target, pname, params);
#endif
}

static GLvoid *REGAL_CALL http_glMapBufferOES(GLenum target, GLenum access)
{
    GLvoid * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glMapBufferOES)(target, access);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glUnmapBufferOES(GLenum target)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glUnmapBufferOES)(target);
#endif
    return ret;
}

// GL_OES_matrix_palette

static void REGAL_CALL http_glCurrentPaletteMatrixOES(GLuint index)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCurrentPaletteMatrixOES)(index);
#endif
}

static void REGAL_CALL http_glMatrixIndexPointerOES(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMatrixIndexPointerOES)(size, type, stride, pointer);
#endif
}

static void REGAL_CALL http_glWeightPointerOES(GLint size, GLenum type, GLsizei stride, GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glWeightPointerOES)(size, type, stride, pointer);
#endif
}

// GL_OES_single_precision

static void REGAL_CALL http_glClearDepthfOES(GLclampd depth)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearDepthfOES)(depth);
#endif
}

static void REGAL_CALL http_glClipPlanefOES(GLenum plane, const GLfloat *equation)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClipPlanefOES)(plane, equation);
#endif
}

static void REGAL_CALL http_glDepthRangefOES(GLclampf n, GLclampf f)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDepthRangefOES)(n, f);
#endif
}

static void REGAL_CALL http_glFrustumfOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFrustumfOES)(l, r, b, t, n, f);
#endif
}

static void REGAL_CALL http_glGetClipPlanefOES(GLenum plane, GLfloat *equation)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetClipPlanefOES)(plane, equation);
#endif
}

static void REGAL_CALL http_glOrthofOES(GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glOrthofOES)(l, r, b, t, n, f);
#endif
}

// GL_OES_texture_3D

static void REGAL_CALL http_glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexImage3DOES)(target, level, internalformat, width, height, depth, border, imageSize, data);
#endif
}

static void REGAL_CALL http_glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCompressedTexSubImage3DOES)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
#endif
}

static void REGAL_CALL http_glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyTexSubImage3DOES)(target, level, xoffset, yoffset, zoffset, x, y, width, height);
#endif
}

static void REGAL_CALL http_glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFramebufferTexture3DOES)(target, attachment, textarget, texture, level, zoffset);
#endif
}

static void REGAL_CALL http_glTexImage3DOES(GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexImage3DOES)(target, level, internalFormat, width, height, depth, border, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexSubImage3DOES)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
#endif
}

// GL_OES_texture_cube_map

static void REGAL_CALL http_glGetTexGenfvOES(GLenum coord, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexGenfvOES)(coord, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexGenivOES(GLenum coord, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexGenivOES)(coord, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexGenxvOES(GLenum coord, GLenum pname, GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexGenxvOES)(coord, pname, params);
#endif
}

static void REGAL_CALL http_glTexGenfOES(GLenum coord, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexGenfOES)(coord, pname, param);
#endif
}

static void REGAL_CALL http_glTexGenfvOES(GLenum coord, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexGenfvOES)(coord, pname, params);
#endif
}

static void REGAL_CALL http_glTexGeniOES(GLenum coord, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexGeniOES)(coord, pname, param);
#endif
}

static void REGAL_CALL http_glTexGenivOES(GLenum coord, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexGenivOES)(coord, pname, params);
#endif
}

static void REGAL_CALL http_glTexGenxOES(GLenum coord, GLenum pname, GLfixed param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexGenxOES)(coord, pname, param);
#endif
}

static void REGAL_CALL http_glTexGenxvOES(GLenum coord, GLenum pname, const GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexGenxvOES)(coord, pname, params);
#endif
}

// GL_OES_vertex_array_object

static void REGAL_CALL http_glBindVertexArrayOES(GLuint array)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glBindVertexArrayOES)(array);
#endif
}

static void REGAL_CALL http_glDeleteVertexArraysOES(GLsizei n, const GLuint *arrays)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteVertexArraysOES)(n, arrays);
#endif
}

static void REGAL_CALL http_glGenVertexArraysOES(GLsizei n, GLuint *arrays)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGenVertexArraysOES)(n, arrays);
#endif
}

static GLboolean REGAL_CALL http_glIsVertexArrayOES(GLuint array)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsVertexArrayOES)(array);
#endif
    return ret;
}

// GL_PGI_misc_hints

static void REGAL_CALL http_glHintPGI(GLenum target, GLint mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glHintPGI)(target, mode);
#endif
}

// GL_QCOM_alpha_test

static void REGAL_CALL http_glAlphaFuncQCOM(GLenum func, GLclampf ref)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glAlphaFuncQCOM)(func, ref);
#endif
}

// GL_QCOM_driver_control

static void REGAL_CALL http_glDisableDriverControlQCOM(GLuint driverControl)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDisableDriverControlQCOM)(driverControl);
#endif
}

static void REGAL_CALL http_glEnableDriverControlQCOM(GLuint driverControl)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEnableDriverControlQCOM)(driverControl);
#endif
}

static void REGAL_CALL http_glGetDriverControlStringQCOM(GLuint driverControl, GLsizei bufSize, GLsizei *length, GLchar *driverControlString)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetDriverControlStringQCOM)(driverControl, bufSize, length, driverControlString);
#endif
}

static void REGAL_CALL http_glGetDriverControlsQCOM(GLint *num, GLsizei size, GLuint *driverControls)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetDriverControlsQCOM)(num, size, driverControls);
#endif
}

// GL_QCOM_extended_get

static void REGAL_CALL http_glExtGetBufferPointervQCOM(GLenum target, GLvoid **params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glExtGetBufferPointervQCOM)(target, params);
#endif
}

static void REGAL_CALL http_glExtGetBuffersQCOM(GLuint *buffers, GLint maxBuffers, GLint *numBuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glExtGetBuffersQCOM)(buffers, maxBuffers, numBuffers);
#endif
}

static void REGAL_CALL http_glExtGetFramebuffersQCOM(GLuint *framebuffers, GLint maxFramebuffers, GLint *numFramebuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glExtGetFramebuffersQCOM)(framebuffers, maxFramebuffers, numFramebuffers);
#endif
}

static void REGAL_CALL http_glExtGetRenderbuffersQCOM(GLuint *renderbuffers, GLint maxRenderbuffers, GLint *numRenderbuffers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glExtGetRenderbuffersQCOM)(renderbuffers, maxRenderbuffers, numRenderbuffers);
#endif
}

static void REGAL_CALL http_glExtGetTexLevelParameterivQCOM(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glExtGetTexLevelParameterivQCOM)(texture, face, level, pname, params);
#endif
}

static void REGAL_CALL http_glExtGetTexSubImageQCOM(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *texels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glExtGetTexSubImageQCOM)(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
#endif
}

static void REGAL_CALL http_glExtGetTexturesQCOM(GLuint *textures, GLint maxTextures, GLint *numTextures)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glExtGetTexturesQCOM)(textures, maxTextures, numTextures);
#endif
}

static void REGAL_CALL http_glExtTexObjectStateOverrideiQCOM(GLenum target, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glExtTexObjectStateOverrideiQCOM)(target, pname, param);
#endif
}

// GL_QCOM_extended_get2

static void REGAL_CALL http_glExtGetProgramBinarySourceQCOM(GLuint program, GLenum shadertype, GLchar *source, GLint *length)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glExtGetProgramBinarySourceQCOM)(program, shadertype, source, length);
#endif
}

static void REGAL_CALL http_glExtGetProgramsQCOM(GLuint *programs, GLint maxPrograms, GLint *numPrograms)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glExtGetProgramsQCOM)(programs, maxPrograms, numPrograms);
#endif
}

static void REGAL_CALL http_glExtGetShadersQCOM(GLuint *shaders, GLint maxShaders, GLint *numShaders)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glExtGetShadersQCOM)(shaders, maxShaders, numShaders);
#endif
}

static GLboolean REGAL_CALL http_glExtIsProgramBinaryQCOM(GLuint program)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glExtIsProgramBinaryQCOM)(program);
#endif
    return ret;
}

// GL_QCOM_tiled_rendering

static void REGAL_CALL http_glEndTilingQCOM(GLbitfield preserveMask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glEndTilingQCOM)(preserveMask);
#endif
}

static void REGAL_CALL http_glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStartTilingQCOM)(x, y, width, height, preserveMask);
#endif
}

// GL_REGAL_ES1_0_compatibility

static void REGAL_CALL http_glAlphaFuncx(GLenum func, GLclampx ref)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glAlphaFuncx)(func, ref);
#endif
}

static void REGAL_CALL http_glClearColorx(GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearColorx)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glClearDepthx(GLclampx depth)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClearDepthx)(depth);
#endif
}

static void REGAL_CALL http_glColor4x(GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4x)(red, green, blue, alpha);
#endif
}

static void REGAL_CALL http_glDepthRangex(GLclampx zNear, GLclampx zFar)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDepthRangex)(zNear, zFar);
#endif
}

static void REGAL_CALL http_glFogx(GLenum pname, GLfixed param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogx)(pname, param);
#endif
}

static void REGAL_CALL http_glFogxv(GLenum pname, const GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogxv)(pname, params);
#endif
}

static void REGAL_CALL http_glFrustumf(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFrustumf)(left, right, bottom, top, zNear, zFar);
#endif
}

static void REGAL_CALL http_glFrustumx(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFrustumx)(left, right, bottom, top, zNear, zFar);
#endif
}

static void REGAL_CALL http_glLightModelx(GLenum pname, GLfixed param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLightModelx)(pname, param);
#endif
}

static void REGAL_CALL http_glLightModelxv(GLenum pname, const GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLightModelxv)(pname, params);
#endif
}

static void REGAL_CALL http_glLightx(GLenum light, GLenum pname, GLfixed param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLightx)(light, pname, param);
#endif
}

static void REGAL_CALL http_glLightxv(GLenum light, GLenum pname, const GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLightxv)(light, pname, params);
#endif
}

static void REGAL_CALL http_glLineWidthx(GLfixed width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLineWidthx)(width);
#endif
}

static void REGAL_CALL http_glLoadMatrixx(const GLfixed *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLoadMatrixx)(m);
#endif
}

static void REGAL_CALL http_glMaterialx(GLenum face, GLenum pname, GLfixed param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMaterialx)(face, pname, param);
#endif
}

static void REGAL_CALL http_glMaterialxv(GLenum face, GLenum pname, const GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMaterialxv)(face, pname, params);
#endif
}

static void REGAL_CALL http_glMultMatrixx(const GLfixed *m)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultMatrixx)(m);
#endif
}

static void REGAL_CALL http_glMultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glMultiTexCoord4x)(target, s, t, r, q);
#endif
}

static void REGAL_CALL http_glNormal3x(GLfixed nx, GLfixed ny, GLfixed nz)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3x)(nx, ny, nz);
#endif
}

static void REGAL_CALL http_glOrthof(GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glOrthof)(left, right, bottom, top, zNear, zFar);
#endif
}

static void REGAL_CALL http_glOrthox(GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glOrthox)(left, right, bottom, top, zNear, zFar);
#endif
}

static void REGAL_CALL http_glPointSizex(GLfixed size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointSizex)(size);
#endif
}

static void REGAL_CALL http_glPolygonOffsetx(GLfixed factor, GLfixed units)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPolygonOffsetx)(factor, units);
#endif
}

static void REGAL_CALL http_glRotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glRotatex)(angle, x, y, z);
#endif
}

static void REGAL_CALL http_glSampleCoveragex(GLclampx value, GLboolean invert)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSampleCoveragex)(value, invert);
#endif
}

static void REGAL_CALL http_glScalex(GLfixed x, GLfixed y, GLfixed z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glScalex)(x, y, z);
#endif
}

static void REGAL_CALL http_glTexEnvx(GLenum target, GLenum pname, GLfixed param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexEnvx)(target, pname, param);
#endif
}

static void REGAL_CALL http_glTexEnvxv(GLenum target, GLenum pname, const GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexEnvxv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glTexParameterx(GLenum target, GLenum pname, GLfixed param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexParameterx)(target, pname, param);
#endif
}

static void REGAL_CALL http_glTranslatex(GLfixed x, GLfixed y, GLfixed z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTranslatex)(x, y, z);
#endif
}

// GL_REGAL_ES1_1_compatibility

static void REGAL_CALL http_glClipPlanef(GLenum plane, const GLfloat *equation)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClipPlanef)(plane, equation);
#endif
}

static void REGAL_CALL http_glClipPlanex(GLenum plane, const GLfixed *equation)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glClipPlanex)(plane, equation);
#endif
}

static void REGAL_CALL http_glGetClipPlanef(GLenum pname, GLfloat *eqn)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetClipPlanef)(pname, eqn);
#endif
}

static void REGAL_CALL http_glGetClipPlanex(GLenum pname, GLfixed *eqn)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetClipPlanex)(pname, eqn);
#endif
}

static void REGAL_CALL http_glGetFixedv(GLenum pname, GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFixedv)(pname, params);
#endif
}

static void REGAL_CALL http_glGetLightxv(GLenum light, GLenum pname, GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetLightxv)(light, pname, params);
#endif
}

static void REGAL_CALL http_glGetMaterialxv(GLenum face, GLenum pname, GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetMaterialxv)(face, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexEnvxv(GLenum env, GLenum pname, GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexEnvxv)(env, pname, params);
#endif
}

static void REGAL_CALL http_glGetTexParameterxv(GLenum target, GLenum pname, GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexParameterxv)(target, pname, params);
#endif
}

static void REGAL_CALL http_glPointParameterx(GLenum pname, GLfixed param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameterx)(pname, param);
#endif
}

static void REGAL_CALL http_glPointParameterxv(GLenum pname, const GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameterxv)(pname, params);
#endif
}

static void REGAL_CALL http_glPointSizePointerOES(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointSizePointerOES)(type, stride, pointer);
#endif
}

static void REGAL_CALL http_glTexParameterxv(GLenum target, GLenum pname, const GLfixed *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexParameterxv)(target, pname, params);
#endif
}

// GL_REGAL_log

static void REGAL_CALL http_glLogMessageCallbackREGAL(GLLOGPROCREGAL callback)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLogMessageCallbackREGAL)(callback);
#endif
}

// GL_SGIS_detail_texture

static void REGAL_CALL http_glDetailTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDetailTexFuncSGIS)(target, n, points);
#endif
}

static void REGAL_CALL http_glGetDetailTexFuncSGIS(GLenum target, GLfloat *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetDetailTexFuncSGIS)(target, points);
#endif
}

// GL_SGIS_fog_function

static void REGAL_CALL http_glFogFuncSGIS(GLsizei n, const GLfloat *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFogFuncSGIS)(n, points);
#endif
}

static void REGAL_CALL http_glGetFogFuncSGIS(GLfloat *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFogFuncSGIS)(points);
#endif
}

// GL_SGIS_multisample

static void REGAL_CALL http_glSampleMaskSGIS(GLclampf value, GLboolean invert)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSampleMaskSGIS)(value, invert);
#endif
}

static void REGAL_CALL http_glSamplePatternSGIS(GLenum pattern)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSamplePatternSGIS)(pattern);
#endif
}

// GL_SGIS_pixel_texture

static void REGAL_CALL http_glGetPixelTexGenParameterfvSGIS(GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPixelTexGenParameterfvSGIS)(pname, params);
#endif
}

static void REGAL_CALL http_glGetPixelTexGenParameterivSGIS(GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetPixelTexGenParameterivSGIS)(pname, params);
#endif
}

static void REGAL_CALL http_glPixelTexGenParameterfSGIS(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelTexGenParameterfSGIS)(pname, param);
#endif
}

static void REGAL_CALL http_glPixelTexGenParameterfvSGIS(GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelTexGenParameterfvSGIS)(pname, params);
#endif
}

static void REGAL_CALL http_glPixelTexGenParameteriSGIS(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelTexGenParameteriSGIS)(pname, param);
#endif
}

static void REGAL_CALL http_glPixelTexGenParameterivSGIS(GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelTexGenParameterivSGIS)(pname, params);
#endif
}

// GL_SGIS_point_parameters

static void REGAL_CALL http_glPointParameterfSGIS(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameterfSGIS)(pname, param);
#endif
}

static void REGAL_CALL http_glPointParameterfvSGIS(GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPointParameterfvSGIS)(pname, params);
#endif
}

// GL_SGIS_sharpen_texture

static void REGAL_CALL http_glGetSharpenTexFuncSGIS(GLenum target, GLfloat *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetSharpenTexFuncSGIS)(target, points);
#endif
}

static void REGAL_CALL http_glSharpenTexFuncSGIS(GLenum target, GLsizei n, const GLfloat *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSharpenTexFuncSGIS)(target, n, points);
#endif
}

// GL_SGIS_texture4D

static void REGAL_CALL http_glTexImage4DSGIS(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexImage4DSGIS)(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
#endif
}

static void REGAL_CALL http_glTexSubImage4DSGIS(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexSubImage4DSGIS)(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
#endif
}

// GL_SGIS_texture_color_mask

static void REGAL_CALL http_glTextureColorMaskSGIS(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureColorMaskSGIS)(red, green, blue, alpha);
#endif
}

// GL_SGIS_texture_filter4

static void REGAL_CALL http_glGetTexFilterFuncSGIS(GLenum target, GLenum filter, GLfloat *weights)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetTexFilterFuncSGIS)(target, filter, weights);
#endif
}

static void REGAL_CALL http_glTexFilterFuncSGIS(GLenum target, GLenum filter, GLsizei n, const GLfloat *weights)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexFilterFuncSGIS)(target, filter, n, weights);
#endif
}

// GL_SGIX_async

static void REGAL_CALL http_glAsyncMarkerSGIX(GLuint marker)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glAsyncMarkerSGIX)(marker);
#endif
}

static void REGAL_CALL http_glDeleteAsyncMarkersSGIX(GLuint marker, GLsizei range)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeleteAsyncMarkersSGIX)(marker, range);
#endif
}

static GLint REGAL_CALL http_glFinishAsyncSGIX(GLuint *markerp)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glFinishAsyncSGIX)(markerp);
#endif
    return ret;
}

static GLuint REGAL_CALL http_glGenAsyncMarkersSGIX(GLsizei range)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGenAsyncMarkersSGIX)(range);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_glIsAsyncMarkerSGIX(GLuint marker)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glIsAsyncMarkerSGIX)(marker);
#endif
    return ret;
}

static GLint REGAL_CALL http_glPollAsyncSGIX(GLuint *markerp)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glPollAsyncSGIX)(markerp);
#endif
    return ret;
}

// GL_SGIX_flush_raster

static void REGAL_CALL http_glFlushRasterSGIX(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFlushRasterSGIX)();
#endif
}

// GL_SGIX_fog_texture

static void REGAL_CALL http_glTextureFogSGIX(GLenum pname)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTextureFogSGIX)(pname);
#endif
}

// GL_SGIX_fragment_lighting

static void REGAL_CALL http_glFragmentColorMaterialSGIX(GLenum face, GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentColorMaterialSGIX)(face, mode);
#endif
}

static void REGAL_CALL http_glFragmentLightModelfSGIX(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightModelfSGIX)(pname, param);
#endif
}

static void REGAL_CALL http_glFragmentLightModelfvSGIX(GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightModelfvSGIX)(pname, params);
#endif
}

static void REGAL_CALL http_glFragmentLightModeliSGIX(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightModeliSGIX)(pname, param);
#endif
}

static void REGAL_CALL http_glFragmentLightModelivSGIX(GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightModelivSGIX)(pname, params);
#endif
}

static void REGAL_CALL http_glFragmentLightfSGIX(GLenum light, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightfSGIX)(light, pname, param);
#endif
}

static void REGAL_CALL http_glFragmentLightfvSGIX(GLenum light, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightfvSGIX)(light, pname, params);
#endif
}

static void REGAL_CALL http_glFragmentLightiSGIX(GLenum light, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightiSGIX)(light, pname, param);
#endif
}

static void REGAL_CALL http_glFragmentLightivSGIX(GLenum light, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentLightivSGIX)(light, pname, params);
#endif
}

static void REGAL_CALL http_glFragmentMaterialfSGIX(GLenum face, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentMaterialfSGIX)(face, pname, param);
#endif
}

static void REGAL_CALL http_glFragmentMaterialfvSGIX(GLenum face, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentMaterialfvSGIX)(face, pname, params);
#endif
}

static void REGAL_CALL http_glFragmentMaterialiSGIX(GLenum face, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentMaterialiSGIX)(face, pname, param);
#endif
}

static void REGAL_CALL http_glFragmentMaterialivSGIX(GLenum face, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFragmentMaterialivSGIX)(face, pname, params);
#endif
}

static void REGAL_CALL http_glGetFragmentLightfvSGIX(GLenum light, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFragmentLightfvSGIX)(light, pname, params);
#endif
}

static void REGAL_CALL http_glGetFragmentLightivSGIX(GLenum light, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFragmentLightivSGIX)(light, pname, params);
#endif
}

static void REGAL_CALL http_glGetFragmentMaterialfvSGIX(GLenum face, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFragmentMaterialfvSGIX)(face, pname, params);
#endif
}

static void REGAL_CALL http_glGetFragmentMaterialivSGIX(GLenum face, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetFragmentMaterialivSGIX)(face, pname, params);
#endif
}

static void REGAL_CALL http_glLightEnviSGIX(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLightEnviSGIX)(pname, param);
#endif
}

// GL_SGIX_framezoom

static void REGAL_CALL http_glFrameZoomSGIX(GLint factor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFrameZoomSGIX)(factor);
#endif
}

// GL_SGIX_igloo_interface

static void REGAL_CALL http_glIglooInterfaceSGIX(GLenum pname, const GLvoid *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glIglooInterfaceSGIX)(pname, params);
#endif
}

// GL_SGIX_instruments

static GLint REGAL_CALL http_glGetInstrumentsSGIX(void)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glGetInstrumentsSGIX)();
#endif
    return ret;
}

static void REGAL_CALL http_glInstrumentsBufferSGIX(GLsizei size, GLint *buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glInstrumentsBufferSGIX)(size, buffer);
#endif
}

static GLint REGAL_CALL http_glPollInstrumentsSGIX(GLint *marker_p)
{
    GLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    ret = _next->call(&_next->glPollInstrumentsSGIX)(marker_p);
#endif
    return ret;
}

static void REGAL_CALL http_glReadInstrumentsSGIX(GLint marker)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReadInstrumentsSGIX)(marker);
#endif
}

static void REGAL_CALL http_glStartInstrumentsSGIX(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStartInstrumentsSGIX)();
#endif
}

static void REGAL_CALL http_glStopInstrumentsSGIX(GLint marker)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glStopInstrumentsSGIX)(marker);
#endif
}

// GL_SGIX_list_priority

static void REGAL_CALL http_glGetListParameterfvSGIX(GLuint list, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetListParameterfvSGIX)(list, pname, params);
#endif
}

static void REGAL_CALL http_glGetListParameterivSGIX(GLuint list, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetListParameterivSGIX)(list, pname, params);
#endif
}

static void REGAL_CALL http_glListParameterfSGIX(GLuint list, GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glListParameterfSGIX)(list, pname, param);
#endif
}

static void REGAL_CALL http_glListParameterfvSGIX(GLuint list, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glListParameterfvSGIX)(list, pname, params);
#endif
}

static void REGAL_CALL http_glListParameteriSGIX(GLuint list, GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glListParameteriSGIX)(list, pname, param);
#endif
}

static void REGAL_CALL http_glListParameterivSGIX(GLuint list, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glListParameterivSGIX)(list, pname, params);
#endif
}

// GL_SGIX_pixel_texture

static void REGAL_CALL http_glPixelTexGenSGIX(GLenum mode)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glPixelTexGenSGIX)(mode);
#endif
}

// GL_SGIX_polynomial_ffd

static void REGAL_CALL http_glDeformSGIX(GLbitfield mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeformSGIX)(mask);
#endif
}

static void REGAL_CALL http_glDeformationMap3dSGIX(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeformationMap3dSGIX)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
#endif
}

static void REGAL_CALL http_glDeformationMap3fSGIX(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat *points)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDeformationMap3fSGIX)(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
#endif
}

static void REGAL_CALL http_glLoadIdentityDeformationMapSGIX(GLbitfield mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glLoadIdentityDeformationMapSGIX)(mask);
#endif
}

// GL_SGIX_reference_plane

static void REGAL_CALL http_glReferencePlaneSGIX(const GLdouble *equation)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReferencePlaneSGIX)(equation);
#endif
}

// GL_SGIX_sprite

static void REGAL_CALL http_glSpriteParameterfSGIX(GLenum pname, GLfloat param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSpriteParameterfSGIX)(pname, param);
#endif
}

static void REGAL_CALL http_glSpriteParameterfvSGIX(GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSpriteParameterfvSGIX)(pname, params);
#endif
}

static void REGAL_CALL http_glSpriteParameteriSGIX(GLenum pname, GLint param)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSpriteParameteriSGIX)(pname, param);
#endif
}

static void REGAL_CALL http_glSpriteParameterivSGIX(GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glSpriteParameterivSGIX)(pname, params);
#endif
}

// GL_SGIX_tag_sample_buffer

static void REGAL_CALL http_glTagSampleBufferSGIX(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTagSampleBufferSGIX)();
#endif
}

// GL_SGI_color_table

static void REGAL_CALL http_glColorTableParameterfvSGI(GLenum target, GLenum pname, const GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorTableParameterfvSGI)(target, pname, params);
#endif
}

static void REGAL_CALL http_glColorTableParameterivSGI(GLenum target, GLenum pname, const GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorTableParameterivSGI)(target, pname, params);
#endif
}

static void REGAL_CALL http_glColorTableSGI(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColorTableSGI)(target, internalformat, width, format, type, table);
#endif
}

static void REGAL_CALL http_glCopyColorTableSGI(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glCopyColorTableSGI)(target, internalformat, x, y, width);
#endif
}

static void REGAL_CALL http_glGetColorTableParameterfvSGI(GLenum target, GLenum pname, GLfloat *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetColorTableParameterfvSGI)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetColorTableParameterivSGI(GLenum target, GLenum pname, GLint *params)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetColorTableParameterivSGI)(target, pname, params);
#endif
}

static void REGAL_CALL http_glGetColorTableSGI(GLenum target, GLenum format, GLenum type, GLvoid *table)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGetColorTableSGI)(target, format, type, table);
#endif
}

// GL_SUNX_constant_data

static void REGAL_CALL http_glFinishTextureSUNX(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glFinishTextureSUNX)();
#endif
}

// GL_SUN_global_alpha

static void REGAL_CALL http_glGlobalAlphaFactorbSUN(GLbyte factor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGlobalAlphaFactorbSUN)(factor);
#endif
}

static void REGAL_CALL http_glGlobalAlphaFactordSUN(GLdouble factor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGlobalAlphaFactordSUN)(factor);
#endif
}

static void REGAL_CALL http_glGlobalAlphaFactorfSUN(GLfloat factor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGlobalAlphaFactorfSUN)(factor);
#endif
}

static void REGAL_CALL http_glGlobalAlphaFactoriSUN(GLint factor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGlobalAlphaFactoriSUN)(factor);
#endif
}

static void REGAL_CALL http_glGlobalAlphaFactorsSUN(GLshort factor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGlobalAlphaFactorsSUN)(factor);
#endif
}

static void REGAL_CALL http_glGlobalAlphaFactorubSUN(GLubyte factor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGlobalAlphaFactorubSUN)(factor);
#endif
}

static void REGAL_CALL http_glGlobalAlphaFactoruiSUN(GLuint factor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGlobalAlphaFactoruiSUN)(factor);
#endif
}

static void REGAL_CALL http_glGlobalAlphaFactorusSUN(GLushort factor)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glGlobalAlphaFactorusSUN)(factor);
#endif
}

// GL_SUN_mesh_array

static void REGAL_CALL http_glDrawMeshArraysSUN(GLenum mode, GLint first, GLsizei count, GLsizei width)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glDrawMeshArraysSUN)(mode, first, count, width);
#endif
}

// GL_SUN_read_video_pixels

static void REGAL_CALL http_glReadVideoPixelsSUN(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReadVideoPixelsSUN)(x, y, width, height, format, type, pixels);
#endif
}

// GL_SUN_triangle_list

static void REGAL_CALL http_glReplacementCodePointerSUN(GLenum type, GLsizei stride, const GLvoid **pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodePointerSUN)(type, stride, pointer);
#endif
}

static void REGAL_CALL http_glReplacementCodeubSUN(GLubyte code)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeubSUN)(code);
#endif
}

static void REGAL_CALL http_glReplacementCodeubvSUN(const GLubyte *code)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeubvSUN)(code);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiSUN(GLuint code)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiSUN)(code);
#endif
}

static void REGAL_CALL http_glReplacementCodeuivSUN(const GLuint *code)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuivSUN)(code);
#endif
}

static void REGAL_CALL http_glReplacementCodeusSUN(GLushort code)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeusSUN)(code);
#endif
}

static void REGAL_CALL http_glReplacementCodeusvSUN(const GLushort *code)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeusvSUN)(code);
#endif
}

// GL_SUN_vertex

static void REGAL_CALL http_glColor3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3fVertex3fSUN)(r, g, b, x, y, z);
#endif
}

static void REGAL_CALL http_glColor3fVertex3fvSUN(const GLfloat *c, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor3fVertex3fvSUN)(c, v);
#endif
}

static void REGAL_CALL http_glColor4fNormal3fVertex3fSUN(GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4fNormal3fVertex3fSUN)(r, g, b, a, nx, ny, nz, x, y, z);
#endif
}

static void REGAL_CALL http_glColor4fNormal3fVertex3fvSUN(const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4fNormal3fVertex3fvSUN)(c, n, v);
#endif
}

static void REGAL_CALL http_glColor4ubVertex2fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4ubVertex2fSUN)(r, g, b, a, x, y);
#endif
}

static void REGAL_CALL http_glColor4ubVertex2fvSUN(const GLubyte *c, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4ubVertex2fvSUN)(c, v);
#endif
}

static void REGAL_CALL http_glColor4ubVertex3fSUN(GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4ubVertex3fSUN)(r, g, b, a, x, y, z);
#endif
}

static void REGAL_CALL http_glColor4ubVertex3fvSUN(const GLubyte *c, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glColor4ubVertex3fvSUN)(c, v);
#endif
}

static void REGAL_CALL http_glNormal3fVertex3fSUN(GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3fVertex3fSUN)(nx, ny, nz, x, y, z);
#endif
}

static void REGAL_CALL http_glNormal3fVertex3fvSUN(const GLfloat *n, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glNormal3fVertex3fvSUN)(n, v);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiColor3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiColor3fVertex3fSUN)(rc, r, g, b, x, y, z);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiColor3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiColor3fVertex3fvSUN)(rc, c, v);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiColor4fNormal3fVertex3fSUN)(rc, r, g, b, a, nx, ny, nz, x, y, z);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiColor4fNormal3fVertex3fvSUN)(rc, c, n, v);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiColor4ubVertex3fSUN(GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiColor4ubVertex3fSUN)(rc, r, g, b, a, x, y, z);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiColor4ubVertex3fvSUN(const GLuint *rc, const GLubyte *c, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiColor4ubVertex3fvSUN)(rc, c, v);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiNormal3fVertex3fSUN(GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiNormal3fVertex3fSUN)(rc, nx, ny, nz, x, y, z);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *n, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiNormal3fVertex3fvSUN)(rc, n, v);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN)(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN)(rc, tc, c, n, v);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN)(rc, s, t, nx, ny, nz, x, y, z);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN)(rc, tc, n, v);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiTexCoord2fVertex3fSUN(GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiTexCoord2fVertex3fSUN)(rc, s, t, x, y, z);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiTexCoord2fVertex3fvSUN(const GLuint *rc, const GLfloat *tc, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiTexCoord2fVertex3fvSUN)(rc, tc, v);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiVertex3fSUN(GLuint rc, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiVertex3fSUN)(rc, x, y, z);
#endif
}

static void REGAL_CALL http_glReplacementCodeuiVertex3fvSUN(const GLuint *rc, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glReplacementCodeuiVertex3fvSUN)(rc, v);
#endif
}

static void REGAL_CALL http_glTexCoord2fColor3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2fColor3fVertex3fSUN)(s, t, r, g, b, x, y, z);
#endif
}

static void REGAL_CALL http_glTexCoord2fColor3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2fColor3fVertex3fvSUN)(tc, c, v);
#endif
}

static void REGAL_CALL http_glTexCoord2fColor4fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2fColor4fNormal3fVertex3fSUN)(s, t, r, g, b, a, nx, ny, nz, x, y, z);
#endif
}

static void REGAL_CALL http_glTexCoord2fColor4fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2fColor4fNormal3fVertex3fvSUN)(tc, c, n, v);
#endif
}

static void REGAL_CALL http_glTexCoord2fColor4ubVertex3fSUN(GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2fColor4ubVertex3fSUN)(s, t, r, g, b, a, x, y, z);
#endif
}

static void REGAL_CALL http_glTexCoord2fColor4ubVertex3fvSUN(const GLfloat *tc, const GLubyte *c, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2fColor4ubVertex3fvSUN)(tc, c, v);
#endif
}

static void REGAL_CALL http_glTexCoord2fNormal3fVertex3fSUN(GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2fNormal3fVertex3fSUN)(s, t, nx, ny, nz, x, y, z);
#endif
}

static void REGAL_CALL http_glTexCoord2fNormal3fVertex3fvSUN(const GLfloat *tc, const GLfloat *n, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2fNormal3fVertex3fvSUN)(tc, n, v);
#endif
}

static void REGAL_CALL http_glTexCoord2fVertex3fSUN(GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2fVertex3fSUN)(s, t, x, y, z);
#endif
}

static void REGAL_CALL http_glTexCoord2fVertex3fvSUN(const GLfloat *tc, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord2fVertex3fvSUN)(tc, v);
#endif
}

static void REGAL_CALL http_glTexCoord4fColor4fNormal3fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4fColor4fNormal3fVertex4fSUN)(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
#endif
}

static void REGAL_CALL http_glTexCoord4fColor4fNormal3fVertex4fvSUN(const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4fColor4fNormal3fVertex4fvSUN)(tc, c, n, v);
#endif
}

static void REGAL_CALL http_glTexCoord4fVertex4fSUN(GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4fVertex4fSUN)(s, t, p, q, x, y, z, w);
#endif
}

static void REGAL_CALL http_glTexCoord4fVertex4fvSUN(const GLfloat *tc, const GLfloat *v)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glTexCoord4fVertex4fvSUN)(tc, v);
#endif
}

// GL_WIN_swap_hint

static void REGAL_CALL http_glAddSwapHintRectWIN(GLint x, GLint y, GLsizei width, GLsizei height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    RegalAssert( _context );
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGL *_next = _context ? _context->dispatcher.http.next() : NULL;
    RegalAssert(_next);
    _next->call(&_next->glAddSwapHintRectWIN)(x, y, width, height);
#endif
}

#if REGAL_SYS_WGL

// WGL_3DL_stereo_control

static BOOL REGAL_CALL http_wglSetStereoEmitterState3DL(HDC hDC, UINT uState)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSetStereoEmitterState3DL)(hDC, uState);
#endif
    return ret;
}

// WGL_AMD_gpu_association

static VOID REGAL_CALL http_wglBlitContextFramebufferAMD(HGLRC dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->wglBlitContextFramebufferAMD)(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
#endif
}

static HGLRC REGAL_CALL http_wglCreateAssociatedContextAMD(UINT id)
{
    HGLRC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglCreateAssociatedContextAMD)(id);
#endif
    return ret;
}

static HGLRC REGAL_CALL http_wglCreateAssociatedContextAttribsAMD(UINT id, HGLRC hShareContext, const int *attribList)
{
    HGLRC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglCreateAssociatedContextAttribsAMD)(id, hShareContext, attribList);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglDeleteAssociatedContextAMD(HGLRC hglrc)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDeleteAssociatedContextAMD)(hglrc);
#endif
    return ret;
}

static UINT REGAL_CALL http_wglGetContextGPUIDAMD(HGLRC hglrc)
{
    UINT  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetContextGPUIDAMD)(hglrc);
#endif
    return ret;
}

static HGLRC REGAL_CALL http_wglGetCurrentAssociatedContextAMD(void)
{
    HGLRC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetCurrentAssociatedContextAMD)();
#endif
    return ret;
}

static UINT REGAL_CALL http_wglGetGPUIDsAMD(UINT maxCount, UINT *ids)
{
    UINT  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetGPUIDsAMD)(maxCount, ids);
#endif
    return ret;
}

static INT REGAL_CALL http_wglGetGPUInfoAMD(UINT id, int property, GLenum dataType, UINT size, void *data)
{
    INT  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetGPUInfoAMD)(id, property, dataType, size, data);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglMakeAssociatedContextCurrentAMD(HGLRC hglrc)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglMakeAssociatedContextCurrentAMD)(hglrc);
#endif
    return ret;
}

// WGL_ARB_buffer_region

static HANDLE REGAL_CALL http_wglCreateBufferRegionARB(HDC hDC, int iLayerPlane, UINT uType)
{
    HANDLE  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglCreateBufferRegionARB)(hDC, iLayerPlane, uType);
#endif
    return ret;
}

static VOID REGAL_CALL http_wglDeleteBufferRegionARB(HANDLE hRegion)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->wglDeleteBufferRegionARB)(hRegion);
#endif
}

static BOOL REGAL_CALL http_wglRestoreBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height, int xSrc, int ySrc)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglRestoreBufferRegionARB)(hRegion, x, y, width, height, xSrc, ySrc);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglSaveBufferRegionARB(HANDLE hRegion, int x, int y, int width, int height)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSaveBufferRegionARB)(hRegion, x, y, width, height);
#endif
    return ret;
}

// WGL_ARB_create_context

static HGLRC REGAL_CALL http_wglCreateContextAttribsARB(HDC hDC, HGLRC hShareContext, const int *piAttribList)
{
    HGLRC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglCreateContextAttribsARB)(hDC, hShareContext, piAttribList);
#endif
    return ret;
}

// WGL_ARB_extensions_string

static const char *REGAL_CALL http_wglGetExtensionsStringARB(HDC hDC)
{
    const char * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetExtensionsStringARB)(hDC);
#endif
    return ret;
}

// WGL_ARB_make_current_read

static HDC REGAL_CALL http_wglGetCurrentReadDCARB(void)
{
    HDC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetCurrentReadDCARB)();
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglMakeContextCurrentARB(HDC hDrawDC, HDC hReadDC, HGLRC hglrc)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglMakeContextCurrentARB)(hDrawDC, hReadDC, hglrc);
#endif
    return ret;
}

// WGL_ARB_pbuffer

static HPBUFFERARB REGAL_CALL http_wglCreatePbufferARB(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList)
{
    HPBUFFERARB  ret = (HPBUFFERARB) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglCreatePbufferARB)(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglDestroyPbufferARB(HPBUFFERARB hPbuffer)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDestroyPbufferARB)(hPbuffer);
#endif
    return ret;
}

static HDC REGAL_CALL http_wglGetPbufferDCARB(HPBUFFERARB hPbuffer)
{
    HDC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetPbufferDCARB)(hPbuffer);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglQueryPbufferARB(HPBUFFERARB hPbuffer, int iAttribute, int *piValue)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglQueryPbufferARB)(hPbuffer, iAttribute, piValue);
#endif
    return ret;
}

static int REGAL_CALL http_wglReleasePbufferDCARB(HPBUFFERARB hPbuffer, HDC hDC)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglReleasePbufferDCARB)(hPbuffer, hDC);
#endif
    return ret;
}

// WGL_ARB_pixel_format

static BOOL REGAL_CALL http_wglChoosePixelFormatARB(HDC hDC, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglChoosePixelFormatARB)(hDC, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGetPixelFormatAttribfvARB(HDC hDC, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, FLOAT *pfValues)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetPixelFormatAttribfvARB)(hDC, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGetPixelFormatAttribivARB(HDC hDC, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, int *piValues)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetPixelFormatAttribivARB)(hDC, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
#endif
    return ret;
}

// WGL_ARB_render_texture

static BOOL REGAL_CALL http_wglBindTexImageARB(HPBUFFERARB hPbuffer, int iBuffer)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglBindTexImageARB)(hPbuffer, iBuffer);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglReleaseTexImageARB(HPBUFFERARB hPbuffer, int iBuffer)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglReleaseTexImageARB)(hPbuffer, iBuffer);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglSetPbufferAttribARB(HPBUFFERARB hPbuffer, const int *piAttribList)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSetPbufferAttribARB)(hPbuffer, piAttribList);
#endif
    return ret;
}

// WGL_EXT_display_color_table

static GLboolean REGAL_CALL http_wglBindDisplayColorTableEXT(GLushort id)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglBindDisplayColorTableEXT)(id);
#endif
    return ret;
}

static GLboolean REGAL_CALL http_wglCreateDisplayColorTableEXT(GLushort id)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglCreateDisplayColorTableEXT)(id);
#endif
    return ret;
}

static VOID REGAL_CALL http_wglDestroyDisplayColorTableEXT(GLushort id)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->wglDestroyDisplayColorTableEXT)(id);
#endif
}

static GLboolean REGAL_CALL http_wglLoadDisplayColorTableEXT(const GLushort *table, GLuint length)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglLoadDisplayColorTableEXT)(table, length);
#endif
    return ret;
}

// WGL_EXT_extensions_string

static const char *REGAL_CALL http_wglGetExtensionsStringEXT(void)
{
    const char * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetExtensionsStringEXT)();
#endif
    return ret;
}

// WGL_EXT_make_current_read

static HDC REGAL_CALL http_wglGetCurrentReadDCEXT(void)
{
    HDC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetCurrentReadDCEXT)();
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglMakeContextCurrentEXT(HDC hDrawDC, HDC hReadDC, HGLRC hglrc)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglMakeContextCurrentEXT)(hDrawDC, hReadDC, hglrc);
#endif
    return ret;
}

// WGL_EXT_pbuffer

static HPBUFFEREXT REGAL_CALL http_wglCreatePbufferEXT(HDC hDC, int iPixelFormat, int iWidth, int iHeight, const int *piAttribList)
{
    HPBUFFEREXT  ret = (HPBUFFEREXT) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglCreatePbufferEXT)(hDC, iPixelFormat, iWidth, iHeight, piAttribList);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglDestroyPbufferEXT(HPBUFFEREXT hPbuffer)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDestroyPbufferEXT)(hPbuffer);
#endif
    return ret;
}

static HDC REGAL_CALL http_wglGetPbufferDCEXT(HPBUFFEREXT hPbuffer)
{
    HDC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetPbufferDCEXT)(hPbuffer);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglQueryPbufferEXT(HPBUFFEREXT hPbuffer, int iAttribute, int *piValue)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglQueryPbufferEXT)(hPbuffer, iAttribute, piValue);
#endif
    return ret;
}

static int REGAL_CALL http_wglReleasePbufferDCEXT(HPBUFFEREXT hPbuffer, HDC hDC)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglReleasePbufferDCEXT)(hPbuffer, hDC);
#endif
    return ret;
}

// WGL_EXT_pixel_format

static BOOL REGAL_CALL http_wglChoosePixelFormatEXT(HDC hDC, const int *piAttribIList, const FLOAT *pfAttribFList, UINT nMaxFormats, int *piFormats, UINT *nNumFormats)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglChoosePixelFormatEXT)(hDC, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGetPixelFormatAttribfvEXT(HDC hDC, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, FLOAT *pfValues)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetPixelFormatAttribfvEXT)(hDC, iPixelFormat, iLayerPlane, nAttributes, piAttributes, pfValues);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGetPixelFormatAttribivEXT(HDC hDC, int iPixelFormat, int iLayerPlane, UINT nAttributes, const int *piAttributes, int *piValues)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetPixelFormatAttribivEXT)(hDC, iPixelFormat, iLayerPlane, nAttributes, piAttributes, piValues);
#endif
    return ret;
}

// WGL_EXT_swap_control

static int REGAL_CALL http_wglGetSwapIntervalEXT(void)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetSwapIntervalEXT)();
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglSwapIntervalEXT(int interval)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSwapIntervalEXT)(interval);
#endif
    return ret;
}

// WGL_GDI

static int REGAL_CALL http_wglChoosePixelFormat(HDC hDC, const PIXELFORMATDESCRIPTOR *ppfd)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglChoosePixelFormat)(hDC, ppfd);
#endif
    return ret;
}

static int REGAL_CALL http_wglDescribePixelFormat(HDC hDC, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDescribePixelFormat)(hDC, iPixelFormat, nBytes, ppfd);
#endif
    return ret;
}

static int REGAL_CALL http_wglGetPixelFormat(HDC hDC)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetPixelFormat)(hDC);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglSetPixelFormat(HDC hDC, int iPixelFormat, const PIXELFORMATDESCRIPTOR *ppfd)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSetPixelFormat)(hDC, iPixelFormat, ppfd);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglSwapBuffers(HDC hDC)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.frame++;
      switch( _context->http.runState ) {
         case RS_Run:
           break;
         default:
          _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSwapBuffers)(hDC);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastFrame = _context->http.count.call;
      #endif
    }
    return ret;
}

// WGL_I3D_digital_video_control

static BOOL REGAL_CALL http_wglGetDigitalVideoParametersI3D(HDC hDC, int iAttribute, int *piValue)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetDigitalVideoParametersI3D)(hDC, iAttribute, piValue);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglSetDigitalVideoParametersI3D(HDC hDC, int iAttribute, const int *piValue)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSetDigitalVideoParametersI3D)(hDC, iAttribute, piValue);
#endif
    return ret;
}

// WGL_I3D_gamma

static BOOL REGAL_CALL http_wglGetGammaTableI3D(HDC hDC, int iEntries, USHORT *puRed, USHORT *puGreen, USHORT *puBlue)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetGammaTableI3D)(hDC, iEntries, puRed, puGreen, puBlue);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGetGammaTableParametersI3D(HDC hDC, int iAttribute, int *piValue)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetGammaTableParametersI3D)(hDC, iAttribute, piValue);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglSetGammaTableI3D(HDC hDC, int iEntries, const USHORT *puRed, const USHORT *puGreen, const USHORT *puBlue)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSetGammaTableI3D)(hDC, iEntries, puRed, puGreen, puBlue);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglSetGammaTableParametersI3D(HDC hDC, int iAttribute, const int *piValue)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSetGammaTableParametersI3D)(hDC, iAttribute, piValue);
#endif
    return ret;
}

// WGL_I3D_genlock

static BOOL REGAL_CALL http_wglDisableGenlockI3D(HDC hDC)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDisableGenlockI3D)(hDC);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglEnableGenlockI3D(HDC hDC)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglEnableGenlockI3D)(hDC);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGenlockSampleRateI3D(HDC hDC, UINT uRate)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGenlockSampleRateI3D)(hDC, uRate);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGenlockSourceDelayI3D(HDC hDC, UINT uDelay)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGenlockSourceDelayI3D)(hDC, uDelay);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGenlockSourceEdgeI3D(HDC hDC, UINT uEdge)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGenlockSourceEdgeI3D)(hDC, uEdge);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGenlockSourceI3D(HDC hDC, UINT uSource)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGenlockSourceI3D)(hDC, uSource);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGetGenlockSampleRateI3D(HDC hDC, UINT *uRate)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetGenlockSampleRateI3D)(hDC, uRate);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGetGenlockSourceDelayI3D(HDC hDC, UINT *uDelay)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetGenlockSourceDelayI3D)(hDC, uDelay);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGetGenlockSourceEdgeI3D(HDC hDC, UINT *uEdge)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetGenlockSourceEdgeI3D)(hDC, uEdge);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGetGenlockSourceI3D(HDC hDC, UINT *uSource)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetGenlockSourceI3D)(hDC, uSource);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglIsEnabledGenlockI3D(HDC hDC, BOOL *pFlag)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglIsEnabledGenlockI3D)(hDC, pFlag);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglQueryGenlockMaxSourceDelayI3D(HDC hDC, UINT *uMaxLineDelay, UINT *uMaxPixelDelay)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglQueryGenlockMaxSourceDelayI3D)(hDC, uMaxLineDelay, uMaxPixelDelay);
#endif
    return ret;
}

// WGL_I3D_image_buffer

static BOOL REGAL_CALL http_wglAssociateImageBufferEventsI3D(HDC hDC, const HANDLE *pEvent, const LPVOID *pAddress, const DWORD *pSize, UINT count)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglAssociateImageBufferEventsI3D)(hDC, pEvent, pAddress, pSize, count);
#endif
    return ret;
}

static LPVOID REGAL_CALL http_wglCreateImageBufferI3D(HDC hDC, DWORD dwSize, UINT uFlags)
{
    LPVOID  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglCreateImageBufferI3D)(hDC, dwSize, uFlags);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglDestroyImageBufferI3D(HDC hDC, LPVOID pAddress)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDestroyImageBufferI3D)(hDC, pAddress);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglReleaseImageBufferEventsI3D(HDC hDC, const LPVOID *pAddress, UINT count)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglReleaseImageBufferEventsI3D)(hDC, pAddress, count);
#endif
    return ret;
}

// WGL_I3D_swap_frame_lock

static BOOL REGAL_CALL http_wglDisableFrameLockI3D(void)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDisableFrameLockI3D)();
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglEnableFrameLockI3D(void)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglEnableFrameLockI3D)();
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglIsEnabledFrameLockI3D(BOOL *pFlag)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglIsEnabledFrameLockI3D)(pFlag);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglQueryFrameLockMasterI3D(BOOL *pFlag)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglQueryFrameLockMasterI3D)(pFlag);
#endif
    return ret;
}

// WGL_I3D_swap_frame_usage

static BOOL REGAL_CALL http_wglBeginFrameTrackingI3D(void)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglBeginFrameTrackingI3D)();
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglEndFrameTrackingI3D(void)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglEndFrameTrackingI3D)();
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGetFrameUsageI3D(float *pUsage)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetFrameUsageI3D)(pUsage);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglQueryFrameTrackingI3D(DWORD *pFrameCount, DWORD *pMissedFrames, float *pLastMissedUsage)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglQueryFrameTrackingI3D)(pFrameCount, pMissedFrames, pLastMissedUsage);
#endif
    return ret;
}

// WGL_NV_DX_interop

static BOOL REGAL_CALL http_wglDXCloseDeviceNV(HANDLE hDevice)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDXCloseDeviceNV)(hDevice);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglDXLockObjectsNV(HANDLE hDevice, GLint count, HANDLE *hObjects)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDXLockObjectsNV)(hDevice, count, hObjects);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglDXObjectAccessNV(HANDLE hObject, GLenum access)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDXObjectAccessNV)(hObject, access);
#endif
    return ret;
}

static HANDLE REGAL_CALL http_wglDXOpenDeviceNV(GLvoid *dxDevice)
{
    HANDLE  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDXOpenDeviceNV)(dxDevice);
#endif
    return ret;
}

static HANDLE REGAL_CALL http_wglDXRegisterObjectNV(HANDLE hDevice, GLvoid *dxObject, GLuint name, GLenum type, GLenum access)
{
    HANDLE  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDXRegisterObjectNV)(hDevice, dxObject, name, type, access);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglDXSetResourceShareHandleNV(GLvoid *dxObject, HANDLE shareHandle)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDXSetResourceShareHandleNV)(dxObject, shareHandle);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglDXUnlockObjectsNV(HANDLE hDevice, GLint count, HANDLE *hObjects)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDXUnlockObjectsNV)(hDevice, count, hObjects);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglDXUnregisterObjectNV(HANDLE hDevice, HANDLE hObject)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDXUnregisterObjectNV)(hDevice, hObject);
#endif
    return ret;
}

// WGL_NV_copy_image

static BOOL REGAL_CALL http_wglCopyImageSubDataNV(HGLRC hSrcRC, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, HGLRC hDstRC, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglCopyImageSubDataNV)(hSrcRC, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, hDstRC, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
#endif
    return ret;
}

// WGL_NV_delay_before_swap

static BOOL REGAL_CALL http_wglDelayBeforeSwapNV(HDC hDC, GLfloat seconds)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDelayBeforeSwapNV)(hDC, seconds);
#endif
    return ret;
}

// WGL_NV_gpu_affinity

static HDC REGAL_CALL http_wglCreateAffinityDCNV(const HGPUNV *phGpuList)
{
    HDC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglCreateAffinityDCNV)(phGpuList);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglDeleteDCNV(HDC hAffinityDC)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDeleteDCNV)(hAffinityDC);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglEnumGpuDevicesNV(HGPUNV hGpu, UINT iDeviceIndex, PGPU_DEVICE lpGpuDevice)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglEnumGpuDevicesNV)(hGpu, iDeviceIndex, lpGpuDevice);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglEnumGpusFromAffinityDCNV(HDC hAffinityDC, UINT iGpuIndex, HGPUNV *hGpu)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglEnumGpusFromAffinityDCNV)(hAffinityDC, iGpuIndex, hGpu);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglEnumGpusNV(UINT iGpuIndex, HGPUNV *phGpu)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglEnumGpusNV)(iGpuIndex, phGpu);
#endif
    return ret;
}

// WGL_NV_present_video

static BOOL REGAL_CALL http_wglBindVideoDeviceNV(HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglBindVideoDeviceNV)(hDC, uVideoSlot, hVideoDevice, piAttribList);
#endif
    return ret;
}

static int REGAL_CALL http_wglEnumerateVideoDevicesNV(HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglEnumerateVideoDevicesNV)(hDC, phDeviceList);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglQueryCurrentContextNV(int iAttribute, int *piValue)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglQueryCurrentContextNV)(iAttribute, piValue);
#endif
    return ret;
}

// WGL_NV_swap_group

static BOOL REGAL_CALL http_wglBindSwapBarrierNV(GLuint group, GLuint barrier)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglBindSwapBarrierNV)(group, barrier);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglJoinSwapGroupNV(HDC hDC, GLuint group)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglJoinSwapGroupNV)(hDC, group);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglQueryFrameCountNV(HDC hDC, GLuint *count)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglQueryFrameCountNV)(hDC, count);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglQueryMaxSwapGroupsNV(HDC hDC, GLuint *maxGroups, GLuint *maxBarriers)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglQueryMaxSwapGroupsNV)(hDC, maxGroups, maxBarriers);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglQuerySwapGroupNV(HDC hDC, GLuint *group, GLuint *barrier)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglQuerySwapGroupNV)(hDC, group, barrier);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglResetFrameCountNV(HDC hDC)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglResetFrameCountNV)(hDC);
#endif
    return ret;
}

// WGL_NV_vertex_array_range

static void *REGAL_CALL http_wglAllocateMemoryNV(GLsizei size, GLfloat readfreq, GLfloat writefreq, GLfloat priority)
{
    void * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglAllocateMemoryNV)(size, readfreq, writefreq, priority);
#endif
    return ret;
}

static void REGAL_CALL http_wglFreeMemoryNV(void *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->wglFreeMemoryNV)(pointer);
#endif
}

// WGL_NV_video_capture

static BOOL REGAL_CALL http_wglBindVideoCaptureDeviceNV(UINT uVideoSlot, HVIDEOINPUTDEVICENV hDevice)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglBindVideoCaptureDeviceNV)(uVideoSlot, hDevice);
#endif
    return ret;
}

static UINT REGAL_CALL http_wglEnumerateVideoCaptureDevicesNV(HDC hDC, HVIDEOINPUTDEVICENV *phDeviceList)
{
    UINT  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglEnumerateVideoCaptureDevicesNV)(hDC, phDeviceList);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglLockVideoCaptureDeviceNV(HDC hDC, HVIDEOINPUTDEVICENV hDevice)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglLockVideoCaptureDeviceNV)(hDC, hDevice);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglQueryVideoCaptureDeviceNV(HDC hDC, HVIDEOINPUTDEVICENV hDevice, int iAttribute, int *piValue)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglQueryVideoCaptureDeviceNV)(hDC, hDevice, iAttribute, piValue);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglReleaseVideoCaptureDeviceNV(HDC hDC, HVIDEOINPUTDEVICENV hDevice)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglReleaseVideoCaptureDeviceNV)(hDC, hDevice);
#endif
    return ret;
}

// WGL_NV_video_output

static BOOL REGAL_CALL http_wglBindVideoImageNV(HPVIDEODEV hVideoDevice, HPBUFFERARB hPbuffer, int iVideoBuffer)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglBindVideoImageNV)(hVideoDevice, hPbuffer, iVideoBuffer);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGetVideoDeviceNV(HDC hDC, int numDevices, HPVIDEODEV *hVideoDevice)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetVideoDeviceNV)(hDC, numDevices, hVideoDevice);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGetVideoInfoNV(HPVIDEODEV hpVideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetVideoInfoNV)(hpVideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglReleaseVideoDeviceNV(HPVIDEODEV hVideoDevice)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglReleaseVideoDeviceNV)(hVideoDevice);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglReleaseVideoImageNV(HPBUFFERARB hPbuffer, int iVideoBuffer)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglReleaseVideoImageNV)(hPbuffer, iVideoBuffer);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglSendPbufferToVideoNV(HPBUFFERARB hPbuffer, int iBufferType, unsigned long *pulCounterPbuffer, BOOL bBlock)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSendPbufferToVideoNV)(hPbuffer, iBufferType, pulCounterPbuffer, bBlock);
#endif
    return ret;
}

// WGL_OML_sync_control

static BOOL REGAL_CALL http_wglGetMscRateOML(HDC hDC, INT32 *numerator, INT32 *denominator)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetMscRateOML)(hDC, numerator, denominator);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglGetSyncValuesOML(HDC hDC, INT64 *ust, INT64 *msc, INT64 *sbc)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetSyncValuesOML)(hDC, ust, msc, sbc);
#endif
    return ret;
}

static INT64 REGAL_CALL http_wglSwapBuffersMscOML(HDC hDC, INT64 target_msc, INT64 divisor, INT64 remainder)
{
    INT64  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSwapBuffersMscOML)(hDC, target_msc, divisor, remainder);
#endif
    return ret;
}

static INT64 REGAL_CALL http_wglSwapLayerBuffersMscOML(HDC hDC, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder)
{
    INT64  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSwapLayerBuffersMscOML)(hDC, fuPlanes, target_msc, divisor, remainder);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglWaitForMscOML(HDC hDC, INT64 target_msc, INT64 divisor, INT64 remainder, INT64 *ust, INT64 *msc, INT64 *sbc)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglWaitForMscOML)(hDC, target_msc, divisor, remainder, ust, msc, sbc);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglWaitForSbcOML(HDC hDC, INT64 target_sbc, INT64 *ust, INT64 *msc, INT64 *sbc)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglWaitForSbcOML)(hDC, target_sbc, ust, msc, sbc);
#endif
    return ret;
}

// WGL_core

static BOOL REGAL_CALL http_wglCopyContext(HGLRC hglrcSrc, HGLRC hglrcDst, UINT mask)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglCopyContext)(hglrcSrc, hglrcDst, mask);
#endif
    return ret;
}

static HGLRC REGAL_CALL http_wglCreateContext(HDC hDC)
{
    HGLRC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglCreateContext)(hDC);
#endif
    return ret;
}

static HGLRC REGAL_CALL http_wglCreateLayerContext(HDC hDC, int iLayerPlane)
{
    HGLRC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglCreateLayerContext)(hDC, iLayerPlane);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglDeleteContext(HGLRC hglrc)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDeleteContext)(hglrc);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglDescribeLayerPlane(HDC hDC, int iPixelFormat, int iLayerPlane, UINT nBytes, LPLAYERPLANEDESCRIPTOR plpd)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglDescribeLayerPlane)(hDC, iPixelFormat, iLayerPlane, nBytes, plpd);
#endif
    return ret;
}

static HGLRC REGAL_CALL http_wglGetCurrentContext(void)
{
    HGLRC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetCurrentContext)();
#endif
    return ret;
}

static HDC REGAL_CALL http_wglGetCurrentDC(void)
{
    HDC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetCurrentDC)();
#endif
    return ret;
}

static PROC REGAL_CALL http_wglGetDefaultProcAddress(LPCSTR lpszProc)
{
    PROC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetDefaultProcAddress)(lpszProc);
#endif
    return ret;
}

static int REGAL_CALL http_wglGetLayerPaletteEntries(HDC hDC, int iLayerPlane, int iStart, int nEntries, COLORREF *pcr)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetLayerPaletteEntries)(hDC, iLayerPlane, iStart, nEntries, pcr);
#endif
    return ret;
}

static PROC REGAL_CALL http_wglGetProcAddress(LPCSTR lpszProc)
{
    PROC  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglGetProcAddress)(lpszProc);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglMakeCurrent(HDC hDC, HGLRC hglrc)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglMakeCurrent)(hDC, hglrc);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglRealizeLayerPalette(HDC hDC, int iLayerPlane, BOOL bRealize)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglRealizeLayerPalette)(hDC, iLayerPlane, bRealize);
#endif
    return ret;
}

static int REGAL_CALL http_wglSetLayerPaletteEntries(HDC hDC, int iLayerPlane, int iStart, int nEntries, const COLORREF *pcr)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSetLayerPaletteEntries)(hDC, iLayerPlane, iStart, nEntries, pcr);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglShareLists(HGLRC hglrcShare, HGLRC hglrcSrc)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglShareLists)(hglrcShare, hglrcSrc);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglSwapLayerBuffers(HDC hDC, UINT fuPlanes)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSwapLayerBuffers)(hDC, fuPlanes);
#endif
    return ret;
}

static DWORD REGAL_CALL http_wglSwapMultipleBuffers(UINT n, const WGLSWAP *ps)
{
    DWORD  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglSwapMultipleBuffers)(n, ps);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglUseFontBitmapsA(HDC hDC, DWORD first, DWORD count, DWORD listBase)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglUseFontBitmapsA)(hDC, first, count, listBase);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglUseFontBitmapsW(HDC hDC, DWORD first, DWORD count, DWORD listBase)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglUseFontBitmapsW)(hDC, first, count, listBase);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglUseFontOutlinesA(HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglUseFontOutlinesA)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
#endif
    return ret;
}

static BOOL REGAL_CALL http_wglUseFontOutlinesW(HDC hDC, DWORD first, DWORD count, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf)
{
    BOOL  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->wglUseFontOutlinesW)(hDC, first, count, listBase, deviation, extrusion, format, lpgmf);
#endif
    return ret;
}

#endif // REGAL_SYS_WGL

#if REGAL_SYS_GLX

// GLX_VERSION_1_0

static XVisualInfo *REGAL_CALL http_glXChooseVisual(Display *dpy, int screen, int *attribList)
{
    XVisualInfo * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXChooseVisual)(dpy, screen, attribList);
#endif
    return ret;
}

static void REGAL_CALL http_glXCopyContext(Display *dpy, GLXContext src, GLXContext dst, unsigned long mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXCopyContext)(dpy, src, dst, mask);
#endif
}

static GLXContext REGAL_CALL http_glXCreateContext(Display *dpy, XVisualInfo *vis, GLXContext shareList, Bool direct)
{
    GLXContext  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXCreateContext)(dpy, vis, shareList, direct);
#endif
    return ret;
}

static GLXPixmap REGAL_CALL http_glXCreateGLXPixmap(Display *dpy, XVisualInfo *vis, Pixmap pixmap)
{
    GLXPixmap  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXCreateGLXPixmap)(dpy, vis, pixmap);
#endif
    return ret;
}

static void REGAL_CALL http_glXDestroyContext(Display *dpy, GLXContext ctx)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXDestroyContext)(dpy, ctx);
#endif
}

static void REGAL_CALL http_glXDestroyGLXPixmap(Display *dpy, GLXPixmap pix)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXDestroyGLXPixmap)(dpy, pix);
#endif
}

static int REGAL_CALL http_glXGetConfig(Display *dpy, XVisualInfo *vis, int attrib, int *value)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetConfig)(dpy, vis, attrib, value);
#endif
    return ret;
}

static GLXContext REGAL_CALL http_glXGetCurrentContext(void)
{
    GLXContext  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetCurrentContext)();
#endif
    return ret;
}

static GLXDrawable REGAL_CALL http_glXGetCurrentDrawable(void)
{
    GLXDrawable  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetCurrentDrawable)();
#endif
    return ret;
}

static Bool REGAL_CALL http_glXIsDirect(Display *dpy, GLXContext ctx)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXIsDirect)(dpy, ctx);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXMakeCurrent(Display *dpy, GLXDrawable drawable, GLXContext ctx)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXMakeCurrent)(dpy, drawable, ctx);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXQueryExtension(Display *dpy, int *errorBase, int *eventBase)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryExtension)(dpy, errorBase, eventBase);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXQueryVersion(Display *dpy, int *major, int *minor)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryVersion)(dpy, major, minor);
#endif
    return ret;
}

static void REGAL_CALL http_glXSwapBuffers(Display *dpy, GLXDrawable drawable)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.frame++;
      switch( _context->http.runState ) {
         case RS_Run:
           break;
         default:
          _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXSwapBuffers)(dpy, drawable);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastFrame = _context->http.count.call;
      #endif
    }
}

static void REGAL_CALL http_glXUseXFont(Font font, int first, int count, int listBase)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXUseXFont)(font, first, count, listBase);
#endif
}

static void REGAL_CALL http_glXWaitGL(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXWaitGL)();
#endif
}

static void REGAL_CALL http_glXWaitX(void)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXWaitX)();
#endif
}

// GLX_VERSION_1_1

static const char *REGAL_CALL http_glXGetClientString(Display *dpy, int name)
{
    const char * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetClientString)(dpy, name);
#endif
    return ret;
}

static const char *REGAL_CALL http_glXQueryExtensionsString(Display *dpy, int screen)
{
    const char * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryExtensionsString)(dpy, screen);
#endif
    return ret;
}

static const char *REGAL_CALL http_glXQueryServerString(Display *dpy, int screen, int name)
{
    const char * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryServerString)(dpy, screen, name);
#endif
    return ret;
}

// GLX_VERSION_1_2

static Display *REGAL_CALL http_glXGetCurrentDisplay(void)
{
    Display * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetCurrentDisplay)();
#endif
    return ret;
}

// GLX_VERSION_1_3

static GLXFBConfig *REGAL_CALL http_glXChooseFBConfig(Display *dpy, int screen, const int *attrib_list, int *nelements)
{
    GLXFBConfig * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXChooseFBConfig)(dpy, screen, attrib_list, nelements);
#endif
    return ret;
}

static GLXContext REGAL_CALL http_glXCreateNewContext(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct)
{
    GLXContext  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXCreateNewContext)(dpy, config, render_type, share_list, direct);
#endif
    return ret;
}

static GLXPbuffer REGAL_CALL http_glXCreatePbuffer(Display *dpy, GLXFBConfig config, const int *attrib_list)
{
    GLXPbuffer  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXCreatePbuffer)(dpy, config, attrib_list);
#endif
    return ret;
}

static GLXPixmap REGAL_CALL http_glXCreatePixmap(Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list)
{
    GLXPixmap  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXCreatePixmap)(dpy, config, pixmap, attrib_list);
#endif
    return ret;
}

static GLXWindow REGAL_CALL http_glXCreateWindow(Display *dpy, GLXFBConfig config, Window win, const int *attrib_list)
{
    GLXWindow  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXCreateWindow)(dpy, config, win, attrib_list);
#endif
    return ret;
}

static void REGAL_CALL http_glXDestroyPbuffer(Display *dpy, GLXPbuffer pbuf)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXDestroyPbuffer)(dpy, pbuf);
#endif
}

static void REGAL_CALL http_glXDestroyPixmap(Display *dpy, GLXPixmap pixmap)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXDestroyPixmap)(dpy, pixmap);
#endif
}

static void REGAL_CALL http_glXDestroyWindow(Display *dpy, GLXWindow win)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXDestroyWindow)(dpy, win);
#endif
}

static GLXDrawable REGAL_CALL http_glXGetCurrentReadDrawable(void)
{
    GLXDrawable  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetCurrentReadDrawable)();
#endif
    return ret;
}

static int REGAL_CALL http_glXGetFBConfigAttrib(Display *dpy, GLXFBConfig config, int attribute, int *value)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetFBConfigAttrib)(dpy, config, attribute, value);
#endif
    return ret;
}

static GLXFBConfig *REGAL_CALL http_glXGetFBConfigs(Display *dpy, int screen, int *nelements)
{
    GLXFBConfig * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetFBConfigs)(dpy, screen, nelements);
#endif
    return ret;
}

static void REGAL_CALL http_glXGetSelectedEvent(Display *dpy, GLXDrawable draw, unsigned long *event_mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXGetSelectedEvent)(dpy, draw, event_mask);
#endif
}

static XVisualInfo *REGAL_CALL http_glXGetVisualFromFBConfig(Display *dpy, GLXFBConfig config)
{
    XVisualInfo * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetVisualFromFBConfig)(dpy, config);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXMakeContextCurrent(Display *display, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXMakeContextCurrent)(display, draw, read, ctx);
#endif
    return ret;
}

static int REGAL_CALL http_glXQueryContext(Display *dpy, GLXContext ctx, int attribute, int *value)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryContext)(dpy, ctx, attribute, value);
#endif
    return ret;
}

static void REGAL_CALL http_glXQueryDrawable(Display *dpy, GLXDrawable draw, int attribute, unsigned int *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXQueryDrawable)(dpy, draw, attribute, value);
#endif
}

static void REGAL_CALL http_glXSelectEvent(Display *dpy, GLXDrawable draw, unsigned long event_mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXSelectEvent)(dpy, draw, event_mask);
#endif
}

// GLX_VERSION_1_4

static __GLXextFuncPtr REGAL_CALL http_glXGetProcAddress(const GLubyte *procName)
{
    __GLXextFuncPtr  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetProcAddress)(procName);
#endif
    return ret;
}

// GLX_AMD_gpu_association

static void REGAL_CALL http_glXBlitContextFramebufferAMD(GLXContext dstCtx, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXBlitContextFramebufferAMD)(dstCtx, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
#endif
}

static GLXContext REGAL_CALL http_glXCreateAssociatedContextAMD(unsigned int id, GLXContext share_list)
{
    GLXContext  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXCreateAssociatedContextAMD)(id, share_list);
#endif
    return ret;
}

static GLXContext REGAL_CALL http_glXCreateAssociatedContextAttribsAMD(unsigned int id, GLXContext share_context, const int *attribList)
{
    GLXContext  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXCreateAssociatedContextAttribsAMD)(id, share_context, attribList);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXDeleteAssociatedContextAMD(GLXContext ctx)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXDeleteAssociatedContextAMD)(ctx);
#endif
    return ret;
}

static unsigned int REGAL_CALL http_glXGetContextGPUIDAMD(GLXContext ctx)
{
    unsigned int  ret = (unsigned int) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetContextGPUIDAMD)(ctx);
#endif
    return ret;
}

static GLXContext REGAL_CALL http_glXGetCurrentAssociatedContextAMD(void)
{
    GLXContext  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetCurrentAssociatedContextAMD)();
#endif
    return ret;
}

static unsigned int REGAL_CALL http_glXGetGPUIDsAMD(unsigned int maxCount, unsigned int *ids)
{
    unsigned int  ret = (unsigned int) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetGPUIDsAMD)(maxCount, ids);
#endif
    return ret;
}

static int REGAL_CALL http_glXGetGPUInfoAMD(unsigned int id, int property, GLenum dataType, unsigned int size, GLvoid *data)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetGPUInfoAMD)(id, property, dataType, size, data);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXMakeAssociatedContextCurrentAMD(GLXContext ctx)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXMakeAssociatedContextCurrentAMD)(ctx);
#endif
    return ret;
}

// GLX_ARB_create_context

static GLXContext REGAL_CALL http_glXCreateContextAttribsARB(Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list)
{
    GLXContext  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXCreateContextAttribsARB)(dpy, config, share_context, direct, attrib_list);
#endif
    return ret;
}

// GLX_ARB_get_proc_address

static __GLXextFuncPtr REGAL_CALL http_glXGetProcAddressARB(const GLubyte *procName)
{
    __GLXextFuncPtr  ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetProcAddressARB)(procName);
#endif
    return ret;
}

// GLX_ATI_render_texture

static void REGAL_CALL http_glXBindTexImageATI(Display *dpy, GLXPbuffer pbuf, int buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXBindTexImageATI)(dpy, pbuf, buffer);
#endif
}

static void REGAL_CALL http_glXDrawableAttribATI(Display *dpy, GLXDrawable draw, const int *attrib_list)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXDrawableAttribATI)(dpy, draw, attrib_list);
#endif
}

static void REGAL_CALL http_glXReleaseTexImageATI(Display *dpy, GLXPbuffer pbuf, int buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXReleaseTexImageATI)(dpy, pbuf, buffer);
#endif
}

// GLX_EXT_import_context

static void REGAL_CALL http_glXFreeContextEXT(Display *dpy, GLXContext context)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXFreeContextEXT)(dpy, context);
#endif
}

static GLXContextID REGAL_CALL http_glXGetContextIDEXT(const GLXContext context)
{
    GLXContextID  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetContextIDEXT)(context);
#endif
    return ret;
}

static GLXContext REGAL_CALL http_glXImportContextEXT(Display *dpy, GLXContextID contextID)
{
    GLXContext  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXImportContextEXT)(dpy, contextID);
#endif
    return ret;
}

static int REGAL_CALL http_glXQueryContextInfoEXT(Display *dpy, GLXContext context, int attribute, int *value)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryContextInfoEXT)(dpy, context, attribute, value);
#endif
    return ret;
}

// GLX_EXT_swap_control

static void REGAL_CALL http_glXSwapIntervalEXT(Display *dpy, GLXDrawable drawable, int interval)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXSwapIntervalEXT)(dpy, drawable, interval);
#endif
}

// GLX_EXT_texture_from_pixmap

static void REGAL_CALL http_glXBindTexImageEXT(Display *display, GLXDrawable drawable, int buffer, const int *attrib_list)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXBindTexImageEXT)(display, drawable, buffer, attrib_list);
#endif
}

static void REGAL_CALL http_glXReleaseTexImageEXT(Display *display, GLXDrawable drawable, int buffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXReleaseTexImageEXT)(display, drawable, buffer);
#endif
}

// GLX_MESA_agp_offset

static unsigned int REGAL_CALL http_glXGetAGPOffsetMESA(const void *pointer)
{
    unsigned int  ret = (unsigned int) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetAGPOffsetMESA)(pointer);
#endif
    return ret;
}

// GLX_MESA_copy_sub_buffer

static void REGAL_CALL http_glXCopySubBufferMESA(Display *dpy, GLXDrawable drawable, int x, int y, int width, int height)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXCopySubBufferMESA)(dpy, drawable, x, y, width, height);
#endif
}

// GLX_MESA_pixmap_colormap

static GLXPixmap REGAL_CALL http_glXCreateGLXPixmapMESA(Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap)
{
    GLXPixmap  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXCreateGLXPixmapMESA)(dpy, visual, pixmap, cmap);
#endif
    return ret;
}

// GLX_MESA_query_renderer

static Bool REGAL_CALL http_glXQueryCurrentRendererIntegerMESA(int attribute, unsigned int *value)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryCurrentRendererIntegerMESA)(attribute, value);
#endif
    return ret;
}

static const char *REGAL_CALL http_glXQueryCurrentRendererStringMESA(int attribute)
{
    const char * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryCurrentRendererStringMESA)(attribute);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXQueryRendererIntegerMESA(Display *dpy, int screen, int renderer, int attribute, unsigned int *value)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryRendererIntegerMESA)(dpy, screen, renderer, attribute, value);
#endif
    return ret;
}

static const char *REGAL_CALL http_glXQueryRendererStringMESA(Display *dpy, int screen, int renderer, int attribute)
{
    const char * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryRendererStringMESA)(dpy, screen, renderer, attribute);
#endif
    return ret;
}

// GLX_MESA_release_buffers

static Bool REGAL_CALL http_glXReleaseBuffersMESA(Display *dpy, GLXDrawable d)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXReleaseBuffersMESA)(dpy, d);
#endif
    return ret;
}

// GLX_MESA_set_3dfx_mode

static GLboolean REGAL_CALL http_glXSet3DfxModeMESA(GLint mode)
{
    GLboolean  ret = GL_FALSE;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXSet3DfxModeMESA)(mode);
#endif
    return ret;
}

// GLX_MESA_swap_control

static int REGAL_CALL http_glXGetSwapIntervalMESA(void)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetSwapIntervalMESA)();
#endif
    return ret;
}

static int REGAL_CALL http_glXSwapIntervalMESA(unsigned int interval)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXSwapIntervalMESA)(interval);
#endif
    return ret;
}

// GLX_NV_copy_buffer

static void REGAL_CALL http_glXCopyBufferSubDataNV(Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXCopyBufferSubDataNV)(dpy, readCtx, writeCtx, readTarget, writeTarget, readOffset, writeOffset, size);
#endif
}

static void REGAL_CALL http_glXNamedCopyBufferSubDataNV(Display *dpy, GLXContext readCtx, GLXContext writeCtx, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXNamedCopyBufferSubDataNV)(dpy, readCtx, writeCtx, readBuffer, writeBuffer, readOffset, writeOffset, size);
#endif
}

// GLX_NV_copy_image

static void REGAL_CALL http_glXCopyImageSubDataNV(Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXCopyImageSubDataNV)(dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
#endif
}

// GLX_NV_delay_before_swap

static Bool REGAL_CALL http_glXDelayBeforeSwapNV(Display *dpy, GLXDrawable drawable, GLfloat seconds)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXDelayBeforeSwapNV)(dpy, drawable, seconds);
#endif
    return ret;
}

// GLX_NV_present_video

static int REGAL_CALL http_glXBindVideoDeviceNV(Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXBindVideoDeviceNV)(dpy, video_slot, video_device, attrib_list);
#endif
    return ret;
}

static unsigned int *REGAL_CALL http_glXEnumerateVideoDevicesNV(Display *dpy, int screen, int *nelements)
{
    unsigned int * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXEnumerateVideoDevicesNV)(dpy, screen, nelements);
#endif
    return ret;
}

// GLX_NV_swap_group

static Bool REGAL_CALL http_glXBindSwapBarrierNV(Display *dpy, GLuint group, GLuint barrier)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXBindSwapBarrierNV)(dpy, group, barrier);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXJoinSwapGroupNV(Display *dpy, GLXDrawable drawable, GLuint group)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXJoinSwapGroupNV)(dpy, drawable, group);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXQueryFrameCountNV(Display *dpy, int screen, GLuint *count)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryFrameCountNV)(dpy, screen, count);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXQueryMaxSwapGroupsNV(Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryMaxSwapGroupsNV)(dpy, screen, maxGroups, maxBarriers);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXQuerySwapGroupNV(Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQuerySwapGroupNV)(dpy, drawable, group, barrier);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXResetFrameCountNV(Display *dpy, int screen)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXResetFrameCountNV)(dpy, screen);
#endif
    return ret;
}

// GLX_NV_vertex_array_range

static void *REGAL_CALL http_glXAllocateMemoryNV(GLsizei size, GLfloat readFrequency, GLfloat writeFrequency, GLfloat priority)
{
    void * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXAllocateMemoryNV)(size, readFrequency, writeFrequency, priority);
#endif
    return ret;
}

static void REGAL_CALL http_glXFreeMemoryNV(void *pointer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXFreeMemoryNV)(pointer);
#endif
}

// GLX_NV_video_capture

static int REGAL_CALL http_glXBindVideoCaptureDeviceNV(Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXBindVideoCaptureDeviceNV)(dpy, video_capture_slot, device);
#endif
    return ret;
}

static GLXVideoCaptureDeviceNV *REGAL_CALL http_glXEnumerateVideoCaptureDevicesNV(Display *dpy, int screen, int *nelements)
{
    GLXVideoCaptureDeviceNV * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXEnumerateVideoCaptureDevicesNV)(dpy, screen, nelements);
#endif
    return ret;
}

static void REGAL_CALL http_glXLockVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXLockVideoCaptureDeviceNV)(dpy, device);
#endif
}

static int REGAL_CALL http_glXQueryVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryVideoCaptureDeviceNV)(dpy, device, attribute, value);
#endif
    return ret;
}

static void REGAL_CALL http_glXReleaseVideoCaptureDeviceNV(Display *dpy, GLXVideoCaptureDeviceNV device)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXReleaseVideoCaptureDeviceNV)(dpy, device);
#endif
}

// GLX_NV_video_output

static int REGAL_CALL http_glXBindVideoImageNV(Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXBindVideoImageNV)(dpy, VideoDevice, pbuf, iVideoBuffer);
#endif
    return ret;
}

static int REGAL_CALL http_glXGetVideoDeviceNV(Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetVideoDeviceNV)(dpy, screen, numVideoDevices, pVideoDevice);
#endif
    return ret;
}

static int REGAL_CALL http_glXGetVideoInfoNV(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetVideoInfoNV)(dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo);
#endif
    return ret;
}

static int REGAL_CALL http_glXReleaseVideoDeviceNV(Display *dpy, int screen, GLXVideoDeviceNV VideoDevice)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXReleaseVideoDeviceNV)(dpy, screen, VideoDevice);
#endif
    return ret;
}

static int REGAL_CALL http_glXReleaseVideoImageNV(Display *dpy, GLXPbuffer pbuf)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXReleaseVideoImageNV)(dpy, pbuf);
#endif
    return ret;
}

static int REGAL_CALL http_glXSendPbufferToVideoNV(Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXSendPbufferToVideoNV)(dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock);
#endif
    return ret;
}

// GLX_OML_sync_control

static Bool REGAL_CALL http_glXGetMscRateOML(Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetMscRateOML)(dpy, drawable, numerator, denominator);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXGetSyncValuesOML(Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetSyncValuesOML)(dpy, drawable, ust, msc, sbc);
#endif
    return ret;
}

static int64_t REGAL_CALL http_glXSwapBuffersMscOML(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder)
{
    int64_t  ret = (int64_t) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXSwapBuffersMscOML)(dpy, drawable, target_msc, divisor, remainder);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXWaitForMscOML(Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXWaitForMscOML)(dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc);
#endif
    return ret;
}

static Bool REGAL_CALL http_glXWaitForSbcOML(Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXWaitForSbcOML)(dpy, drawable, target_sbc, ust, msc, sbc);
#endif
    return ret;
}

// GLX_SGIX_fbconfig

static GLXFBConfigSGIX *REGAL_CALL http_glXChooseFBConfigSGIX(Display *dpy, int screen, const int *attrib_list, int *nelements)
{
    GLXFBConfigSGIX * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXChooseFBConfigSGIX)(dpy, screen, attrib_list, nelements);
#endif
    return ret;
}

static GLXContext REGAL_CALL http_glXCreateContextWithConfigSGIX(Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct)
{
    GLXContext  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXCreateContextWithConfigSGIX)(dpy, config, render_type, share_list, direct);
#endif
    return ret;
}

static GLXPixmap REGAL_CALL http_glXCreateGLXPixmapWithConfigSGIX(Display *dpy, GLXFBConfig config, Pixmap pixmap)
{
    GLXPixmap  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXCreateGLXPixmapWithConfigSGIX)(dpy, config, pixmap);
#endif
    return ret;
}

static int REGAL_CALL http_glXGetFBConfigAttribSGIX(Display *dpy, GLXFBConfigSGIX config, int attribute, int *value)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetFBConfigAttribSGIX)(dpy, config, attribute, value);
#endif
    return ret;
}

static GLXFBConfigSGIX REGAL_CALL http_glXGetFBConfigFromVisualSGIX(Display *dpy, XVisualInfo *vis)
{
    GLXFBConfigSGIX  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetFBConfigFromVisualSGIX)(dpy, vis);
#endif
    return ret;
}

static XVisualInfo *REGAL_CALL http_glXGetVisualFromFBConfigSGIX(Display *dpy, GLXFBConfig config)
{
    XVisualInfo * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetVisualFromFBConfigSGIX)(dpy, config);
#endif
    return ret;
}

// GLX_SGIX_pbuffer

static GLXPbuffer REGAL_CALL http_glXCreateGLXPbufferSGIX(Display *dpy, GLXFBConfig config, unsigned int width, unsigned int height, int *attrib_list)
{
    GLXPbuffer  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXCreateGLXPbufferSGIX)(dpy, config, width, height, attrib_list);
#endif
    return ret;
}

static void REGAL_CALL http_glXDestroyGLXPbufferSGIX(Display *dpy, GLXPbuffer pbuf)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXDestroyGLXPbufferSGIX)(dpy, pbuf);
#endif
}

static void REGAL_CALL http_glXGetSelectedEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long *mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXGetSelectedEventSGIX)(dpy, drawable, mask);
#endif
}

static void REGAL_CALL http_glXQueryGLXPbufferSGIX(Display *dpy, GLXPbuffer pbuf, int attribute, unsigned int *value)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXQueryGLXPbufferSGIX)(dpy, pbuf, attribute, value);
#endif
}

static void REGAL_CALL http_glXSelectEventSGIX(Display *dpy, GLXDrawable drawable, unsigned long mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXSelectEventSGIX)(dpy, drawable, mask);
#endif
}

// GLX_SGIX_swap_barrier

static void REGAL_CALL http_glXBindSwapBarrierSGIX(Display *dpy, GLXDrawable drawable, int barrier)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXBindSwapBarrierSGIX)(dpy, drawable, barrier);
#endif
}

static Bool REGAL_CALL http_glXQueryMaxSwapBarriersSGIX(Display *dpy, int screen, int *max)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryMaxSwapBarriersSGIX)(dpy, screen, max);
#endif
    return ret;
}

// GLX_SGIX_swap_group

static void REGAL_CALL http_glXJoinSwapGroupSGIX(Display *dpy, GLXDrawable drawable, GLXDrawable member)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXJoinSwapGroupSGIX)(dpy, drawable, member);
#endif
}

// GLX_SGIX_video_resize

static int REGAL_CALL http_glXBindChannelToWindowSGIX(Display *display, int screen, int channel, Window window)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXBindChannelToWindowSGIX)(display, screen, channel, window);
#endif
    return ret;
}

static int REGAL_CALL http_glXChannelRectSGIX(Display *display, int screen, int channel, int x, int y, int w, int h)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXChannelRectSGIX)(display, screen, channel, x, y, w, h);
#endif
    return ret;
}

static int REGAL_CALL http_glXChannelRectSyncSGIX(Display *display, int screen, int channel, GLenum synctype)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXChannelRectSyncSGIX)(display, screen, channel, synctype);
#endif
    return ret;
}

static int REGAL_CALL http_glXQueryChannelDeltasSGIX(Display *display, int screen, int channel, int *x, int *y, int *w, int *h)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryChannelDeltasSGIX)(display, screen, channel, x, y, w, h);
#endif
    return ret;
}

static int REGAL_CALL http_glXQueryChannelRectSGIX(Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXQueryChannelRectSGIX)(display, screen, channel, dx, dy, dw, dh);
#endif
    return ret;
}

// GLX_SGI_cushion

static void REGAL_CALL http_glXCushionSGI(Display *dpy, Window window, float cushion)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->glXCushionSGI)(dpy, window, cushion);
#endif
}

// GLX_SGI_make_current_read

static GLXDrawable REGAL_CALL http_glXGetCurrentReadDrawableSGI(void)
{
    GLXDrawable  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetCurrentReadDrawableSGI)();
#endif
    return ret;
}

static Bool REGAL_CALL http_glXMakeCurrentReadSGI(Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx)
{
    Bool  ret = (Bool) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXMakeCurrentReadSGI)(dpy, draw, read, ctx);
#endif
    return ret;
}

// GLX_SGI_swap_control

static int REGAL_CALL http_glXSwapIntervalSGI(int interval)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXSwapIntervalSGI)(interval);
#endif
    return ret;
}

// GLX_SGI_video_sync

static int REGAL_CALL http_glXGetVideoSyncSGI(unsigned int *count)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetVideoSyncSGI)(count);
#endif
    return ret;
}

static int REGAL_CALL http_glXWaitVideoSyncSGI(int divisor, int remainder, unsigned int *count)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXWaitVideoSyncSGI)(divisor, remainder, count);
#endif
    return ret;
}

// GLX_SUN_get_transparent_index

static Status REGAL_CALL http_glXGetTransparentIndexSUN(Display *dpy, Window overlay, Window underlay, unsigned long *pTransparentIndex)
{
    Status  ret = (Status) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetTransparentIndexSUN)(dpy, overlay, underlay, pTransparentIndex);
#endif
    return ret;
}

// GLX_SUN_video_resize

static int REGAL_CALL http_glXGetVideoResizeSUN(Display *display, GLXDrawable window, float *factor)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXGetVideoResizeSUN)(display, window, factor);
#endif
    return ret;
}

static int REGAL_CALL http_glXVideoResizeSUN(Display *display, GLXDrawable window, float factor)
{
    int  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->glXVideoResizeSUN)(display, window, factor);
#endif
    return ret;
}

#endif // REGAL_SYS_GLX

#if REGAL_SYS_OSX

// CGL_VERSION_1_0

static CGLError REGAL_CALL http_CGLChoosePixelFormat(const CGLPixelFormatAttribute *attribs, CGLPixelFormatObj *pix, GLint *npix)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLChoosePixelFormat)(attribs, pix, npix);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLClearDrawable(CGLContextObj ctx)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLClearDrawable)(ctx);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLCopyContext(CGLContextObj src, CGLContextObj dst, GLbitfield mask)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLCopyContext)(src, dst, mask);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLCreateContext(CGLPixelFormatObj pix, CGLContextObj share, CGLContextObj *ctx)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLCreateContext)(pix, share, ctx);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLDescribePixelFormat(CGLPixelFormatObj pix, GLint pix_num, CGLPixelFormatAttribute attrib, GLint *value)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLDescribePixelFormat)(pix, pix_num, attrib, value);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLDescribeRenderer(CGLRendererInfoObj rend, GLint rend_num, CGLRendererProperty prop, GLint *value)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLDescribeRenderer)(rend, rend_num, prop, value);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLDestroyContext(CGLContextObj ctx)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLDestroyContext)(ctx);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLDestroyPixelFormat(CGLPixelFormatObj pix)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLDestroyPixelFormat)(pix);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLDestroyRendererInfo(CGLRendererInfoObj rend)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLDestroyRendererInfo)(rend);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLDisable(CGLContextObj ctx, CGLContextEnable pname)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLDisable)(ctx, pname);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLEnable(CGLContextObj ctx, CGLContextEnable pname)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLEnable)(ctx, pname);
#endif
    return ret;
}

static const char *REGAL_CALL http_CGLErrorString(CGLError error)
{
    const char * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLErrorString)(error);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLFlushDrawable(CGLContextObj ctx)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.frame++;
      switch( _context->http.runState ) {
         case RS_Run:
           break;
         default:
          _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLFlushDrawable)(ctx);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastFrame = _context->http.count.call;
      #endif
    }
    return ret;
}

static CGLError REGAL_CALL http_CGLGetOffScreen(CGLContextObj ctx, GLsizei *width, GLsizei *height, GLsizei *rowbytes, void **baseaddr)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLGetOffScreen)(ctx, width, height, rowbytes, baseaddr);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLGetOption(CGLGlobalOption pname, GLint *param)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLGetOption)(pname, param);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLGetParameter(CGLContextObj ctx, CGLContextParameter pname, GLint *params)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLGetParameter)(ctx, pname, params);
#endif
    return ret;
}

static void REGAL_CALL http_CGLGetVersion(GLint *majorvers, GLint *minorvers)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->CGLGetVersion)(majorvers, minorvers);
#endif
}

static CGLError REGAL_CALL http_CGLGetVirtualScreen(CGLContextObj ctx, GLint *screen)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLGetVirtualScreen)(ctx, screen);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLIsEnabled(CGLContextObj ctx, CGLContextEnable pname, GLint *enable)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLIsEnabled)(ctx, pname, enable);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLQueryRendererInfo(GLuint display_mask, CGLRendererInfoObj *rend, GLint *nrend)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLQueryRendererInfo)(display_mask, rend, nrend);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLSetFullScreen(CGLContextObj ctx)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLSetFullScreen)(ctx);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLSetOffScreen(CGLContextObj ctx, GLsizei width, GLsizei height, GLsizei rowbytes, void *baseaddr)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLSetOffScreen)(ctx, width, height, rowbytes, baseaddr);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLSetOption(CGLGlobalOption pname, GLint param)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLSetOption)(pname, param);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLSetParameter(CGLContextObj ctx, CGLContextParameter pname, const GLint *params)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLSetParameter)(ctx, pname, params);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLSetVirtualScreen(CGLContextObj ctx, GLint screen)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLSetVirtualScreen)(ctx, screen);
#endif
    return ret;
}

// CGL_VERSION_1_1

static CGLError REGAL_CALL http_CGLCreatePBuffer(GLsizei width, GLsizei height, GLenum target, GLenum internalFormat, GLint max_level, CGLPBufferObj *pbuffer)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLCreatePBuffer)(width, height, target, internalFormat, max_level, pbuffer);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLDescribePBuffer(CGLPBufferObj pbuffer, GLsizei *width, GLsizei *height, GLenum *target, GLenum *internalFormat, GLint *mipmap)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLDescribePBuffer)(pbuffer, width, height, target, internalFormat, mipmap);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLDestroyPBuffer(CGLPBufferObj pbuffer)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLDestroyPBuffer)(pbuffer);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLGetPBuffer(CGLContextObj ctx, CGLPBufferObj *pbuffer, GLenum *face, GLint *level, GLint *screen)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLGetPBuffer)(ctx, pbuffer, face, level, screen);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLSetPBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum face, GLint level, GLint screen)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLSetPBuffer)(ctx, pbuffer, face, level, screen);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLTexImagePBuffer(CGLContextObj ctx, CGLPBufferObj pbuffer, GLenum source)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLTexImagePBuffer)(ctx, pbuffer, source);
#endif
    return ret;
}

// CGL_VERSION_1_2

static GLuint REGAL_CALL http_CGLGetContextRetainCount(CGLContextObj ctx)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLGetContextRetainCount)(ctx);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLGetGlobalOption(CGLGlobalOption pname, GLint *params)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLGetGlobalOption)(pname, params);
#endif
    return ret;
}

static GLuint REGAL_CALL http_CGLGetPBufferRetainCount(CGLPBufferObj pbuffer)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLGetPBufferRetainCount)(pbuffer);
#endif
    return ret;
}

static CGLPixelFormatObj REGAL_CALL http_CGLGetPixelFormat(CGLContextObj ctx)
{
    CGLPixelFormatObj  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLGetPixelFormat)(ctx);
#endif
    return ret;
}

static GLuint REGAL_CALL http_CGLGetPixelFormatRetainCount(CGLPixelFormatObj pix)
{
    GLuint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLGetPixelFormatRetainCount)(pix);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLLockContext(CGLContextObj ctx)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLLockContext)(ctx);
#endif
    return ret;
}

static void REGAL_CALL http_CGLReleaseContext(CGLContextObj ctx)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->CGLReleaseContext)(ctx);
#endif
}

static void REGAL_CALL http_CGLReleasePBuffer(CGLPBufferObj pbuffer)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->CGLReleasePBuffer)(pbuffer);
#endif
}

static void REGAL_CALL http_CGLReleasePixelFormat(CGLPixelFormatObj pix)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->CGLReleasePixelFormat)(pix);
#endif
}

static CGLContextObj REGAL_CALL http_CGLRetainContext(CGLContextObj ctx)
{
    CGLContextObj  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLRetainContext)(ctx);
#endif
    return ret;
}

static CGLPBufferObj REGAL_CALL http_CGLRetainPBuffer(CGLPBufferObj pbuffer)
{
    CGLPBufferObj  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLRetainPBuffer)(pbuffer);
#endif
    return ret;
}

static CGLPixelFormatObj REGAL_CALL http_CGLRetainPixelFormat(CGLPixelFormatObj pix)
{
    CGLPixelFormatObj  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLRetainPixelFormat)(pix);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLSetGlobalOption(CGLGlobalOption pname, const GLint *params)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLSetGlobalOption)(pname, params);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLUnlockContext(CGLContextObj ctx)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLUnlockContext)(ctx);
#endif
    return ret;
}

// CGL_VERSION_1_3

static CGLContextObj REGAL_CALL http_CGLGetCurrentContext(void)
{
    CGLContextObj  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLGetCurrentContext)();
#endif
    return ret;
}

static CGLShareGroupObj REGAL_CALL http_CGLGetShareGroup(CGLContextObj ctx)
{
    CGLShareGroupObj  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLGetShareGroup)(ctx);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLGetSurface(CGLContextObj ctx, CGSConnectionID *conn, CGSWindowID *win, CGSSurfaceID *srf)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLGetSurface)(ctx, conn, win, srf);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLSetCurrentContext(CGLContextObj ctx)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLSetCurrentContext)(ctx);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLSetSurface(CGLContextObj ctx, CGSConnectionID conn, CGSWindowID win, CGSSurfaceID srf)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLSetSurface)(ctx, conn, win, srf);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLTexImageIOSurface2D(CGLContextObj ctx, GLenum target, GLenum internal_format, GLsizei width, GLsizei height, GLenum format, GLenum type, IOSurfaceRef ioSurface, GLuint plane)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLTexImageIOSurface2D)(ctx, target, internal_format, width, height, format, type, ioSurface, plane);
#endif
    return ret;
}

static CGLError REGAL_CALL http_CGLUpdateContext(CGLContextObj ctx)
{
    CGLError  ret = (CGLError) 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->CGLUpdateContext)(ctx);
#endif
    return ret;
}

#endif // REGAL_SYS_OSX

#if REGAL_SYS_EGL

// EGL_ANGLE_query_surface_pointer

static EGLBoolean REGAL_CALL http_eglQuerySurfacePointerANGLE(EGLDisplay dpy, EGLSurface surface, EGLint attribute, GLvoid **value)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglQuerySurfacePointerANGLE)(dpy, surface, attribute, value);
#endif
    return ret;
}

// EGL_KHR_fence_sync

static EGLint REGAL_CALL http_eglClientWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR GLsync, EGLint flags, EGLTimeKHR timeout)
{
    EGLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglClientWaitSyncKHR)(dpy, GLsync, flags, timeout);
#endif
    return ret;
}

static EGLSyncKHR REGAL_CALL http_eglCreateSyncKHR(EGLDisplay dpy, EGLenum type, const EGLint *attrib_list)
{
    EGLSyncKHR  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglCreateSyncKHR)(dpy, type, attrib_list);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglDestroySyncKHR(EGLDisplay dpy, EGLSyncKHR GLsync)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglDestroySyncKHR)(dpy, GLsync);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR GLsync, EGLint attribute, EGLint *value)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglGetSyncAttribKHR)(dpy, GLsync, attribute, value);
#endif
    return ret;
}

// EGL_KHR_image_base

static EGLImageKHR REGAL_CALL http_eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *attrib_list)
{
    EGLImageKHR  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglCreateImageKHR)(dpy, ctx, target, buffer, attrib_list);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR image)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglDestroyImageKHR)(dpy, image);
#endif
    return ret;
}

// EGL_KHR_lock_surface

static EGLBoolean REGAL_CALL http_eglLockSurfaceKHR(EGLDisplay display, EGLSurface surface, const EGLint *attrib_list)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglLockSurfaceKHR)(display, surface, attrib_list);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglUnlockSurfaceKHR(EGLDisplay display, EGLSurface surface)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglUnlockSurfaceKHR)(display, surface);
#endif
    return ret;
}

// EGL_KHR_stream_consumer_gltexture

static EGLBoolean REGAL_CALL http_eglStreamConsumerAcquireKHR(EGLDisplay dpy, EGLStreamKHR stream)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglStreamConsumerAcquireKHR)(dpy, stream);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy, EGLStreamKHR stream)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglStreamConsumerGLTextureExternalKHR)(dpy, stream);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglStreamConsumerReleaseKHR(EGLDisplay dpy, EGLStreamKHR stream)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglStreamConsumerReleaseKHR)(dpy, stream);
#endif
    return ret;
}

// EGL_KHR_stream_cross_process_fd

static EGLStreamKHR REGAL_CALL http_eglCreateStreamFromFileDescriptorKHR(EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor)
{
    EGLStreamKHR  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglCreateStreamFromFileDescriptorKHR)(dpy, file_descriptor);
#endif
    return ret;
}

static EGLNativeFileDescriptorKHR REGAL_CALL http_eglGetStreamFileDescriptorKHR(EGLDisplay dpy, EGLStreamKHR stream)
{
    EGLNativeFileDescriptorKHR  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglGetStreamFileDescriptorKHR)(dpy, stream);
#endif
    return ret;
}

// EGL_KHR_stream_producer_eglsurface

static EGLSurface REGAL_CALL http_eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config, EGLStreamKHR stream, const EGLint *attrib_list)
{
    EGLSurface  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglCreateStreamProducerSurfaceKHR)(dpy, config, stream, attrib_list);
#endif
    return ret;
}

// EGL_KHR_wait_sync

static EGLint REGAL_CALL http_eglWaitSyncKHR(EGLDisplay dpy, EGLSyncKHR GLsync, EGLint flags)
{
    EGLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglWaitSyncKHR)(dpy, GLsync, flags);
#endif
    return ret;
}

// EGL_MESA_drm_image

static EGLImageKHR REGAL_CALL http_eglCreateDRMImageMESA(EGLDisplay dpy, const EGLint *attrib_list)
{
    EGLImageKHR  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglCreateDRMImageMESA)(dpy, attrib_list);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglExportDRMImageMESA(EGLDisplay dpy, EGLImageKHR image, EGLint *name, EGLint *handle, EGLint *stride)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglExportDRMImageMESA)(dpy, image, name, handle, stride);
#endif
    return ret;
}

// EGL_NV_coverage_sample

static void REGAL_CALL http_eglCoverageMaskNV(GLboolean mask)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->eglCoverageMaskNV)(mask);
#endif
}

static void REGAL_CALL http_eglCoverageOperationNV(GLenum operation)
{
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    _next->call(&_next->eglCoverageOperationNV)(operation);
#endif
}

// EGL_NV_post_sub_buffer

static EGLBoolean REGAL_CALL http_eglPostSubBufferNV(EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglPostSubBufferNV)(dpy, surface, x, y, width, height);
#endif
    return ret;
}

// EGL_NV_sync

static EGLint REGAL_CALL http_eglClientWaitSyncNV(EGLSyncNV GLsync, EGLint flags, EGLTimeNV timeout)
{
    EGLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglClientWaitSyncNV)(GLsync, flags, timeout);
#endif
    return ret;
}

static EGLSyncNV REGAL_CALL http_eglCreateFenceSyncNV(EGLDisplay dpy, EGLenum condition, const EGLint *attrib_list)
{
    EGLSyncNV  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglCreateFenceSyncNV)(dpy, condition, attrib_list);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglDestroySyncNV(EGLSyncNV GLsync)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglDestroySyncNV)(GLsync);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglFenceNV(EGLSyncNV GLsync)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglFenceNV)(GLsync);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglGetSyncAttribNV(EGLSyncNV GLsync, EGLint attribute, EGLint *value)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglGetSyncAttribNV)(GLsync, attribute, value);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglSignalSyncNV(EGLSyncNV GLsync, EGLenum mode)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglSignalSyncNV)(GLsync, mode);
#endif
    return ret;
}

// EGL_NV_system_time

static EGLuint64NV REGAL_CALL http_eglGetSystemTimeFrequencyNV(void)
{
    EGLuint64NV  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglGetSystemTimeFrequencyNV)();
#endif
    return ret;
}

static EGLuint64NV REGAL_CALL http_eglGetSystemTimeNV(void)
{
    EGLuint64NV  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglGetSystemTimeNV)();
#endif
    return ret;
}

// EGL_VERSION_1_0

static EGLBoolean REGAL_CALL http_eglChooseConfig(EGLDisplay dpy, const EGLint *attrib_list, EGLConfig *configs, EGLint config_size, EGLint *num_config)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglChooseConfig)(dpy, attrib_list, configs, config_size, num_config);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglCopyBuffers)(dpy, surface, target);
#endif
    return ret;
}

static EGLContext REGAL_CALL http_eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list)
{
    EGLContext  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglCreateContext)(dpy, config, share_context, attrib_list);
#endif
    return ret;
}

static EGLSurface REGAL_CALL http_eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *attrib_list)
{
    EGLSurface  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglCreatePbufferSurface)(dpy, config, attrib_list);
#endif
    return ret;
}

static EGLSurface REGAL_CALL http_eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *attrib_list)
{
    EGLSurface  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglCreatePixmapSurface)(dpy, config, pixmap, attrib_list);
#endif
    return ret;
}

static EGLSurface REGAL_CALL http_eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *attrib_list)
{
    EGLSurface  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglCreateWindowSurface)(dpy, config, win, attrib_list);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglDestroyContext(EGLDisplay dpy, EGLContext ctx)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglDestroyContext)(dpy, ctx);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglDestroySurface(EGLDisplay dpy, EGLSurface surface)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglDestroySurface)(dpy, surface);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglGetConfigAttrib)(dpy, config, attribute, value);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglGetConfigs(EGLDisplay dpy, EGLConfig *configs, EGLint config_size, EGLint *num_config)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglGetConfigs)(dpy, configs, config_size, num_config);
#endif
    return ret;
}

static EGLContext REGAL_CALL http_eglGetCurrentContext(void)
{
    EGLContext  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglGetCurrentContext)();
#endif
    return ret;
}

static EGLDisplay REGAL_CALL http_eglGetCurrentDisplay(void)
{
    EGLDisplay  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglGetCurrentDisplay)();
#endif
    return ret;
}

static EGLSurface REGAL_CALL http_eglGetCurrentSurface(EGLint readdraw)
{
    EGLSurface  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglGetCurrentSurface)(readdraw);
#endif
    return ret;
}

static EGLDisplay REGAL_CALL http_eglGetDisplay(EGLNativeDisplayType display_id)
{
    EGLDisplay  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglGetDisplay)(display_id);
#endif
    return ret;
}

static EGLint REGAL_CALL http_eglGetError(void)
{
    EGLint  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglGetError)();
#endif
    return ret;
}

static __eglMustCastToProperFunctionPointerType REGAL_CALL http_eglGetProcAddress(const char *procname)
{
    __eglMustCastToProperFunctionPointerType  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglGetProcAddress)(procname);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglInitialize)(dpy, major, minor);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglMakeCurrent)(dpy, draw, read, ctx);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *value)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglQueryContext)(dpy, ctx, attribute, value);
#endif
    return ret;
}

static const char *REGAL_CALL http_eglQueryString(EGLDisplay dpy, EGLint name)
{
    const char * ret = NULL;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglQueryString)(dpy, name);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *value)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglQuerySurface)(dpy, surface, attribute, value);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.frame++;
      switch( _context->http.runState ) {
         case RS_Run:
           break;
         default:
          _context->http.runState = RS_Pause;
      }
      #endif
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglSwapBuffers)(dpy, surface);
#endif
    if( _context ) {
      #if REGAL_HTTP
      _context->http.count.lastFrame = _context->http.count.call;
      #endif
    }
    return ret;
}

static EGLBoolean REGAL_CALL http_eglTerminate(EGLDisplay dpy)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglTerminate)(dpy);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglWaitGL(void)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglWaitGL)();
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglWaitNative(EGLint engine)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglWaitNative)(engine);
#endif
    return ret;
}

// EGL_VERSION_1_1

static EGLBoolean REGAL_CALL http_eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglBindTexImage)(dpy, surface, buffer);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglReleaseTexImage)(dpy, surface, buffer);
#endif
    return ret;
}

// EGL_VERSION_1_2

static EGLBoolean REGAL_CALL http_eglBindAPI(EGLenum api)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglBindAPI)(api);
#endif
    return ret;
}

static EGLSurface REGAL_CALL http_eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *attrib_list)
{
    EGLSurface  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglCreatePbufferFromClientBuffer)(dpy, buftype, buffer, config, attrib_list);
#endif
    return ret;
}

static EGLenum REGAL_CALL http_eglQueryAPI(void)
{
    EGLenum  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglQueryAPI)();
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglReleaseThread(void)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglReleaseThread)();
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglSurfaceAttrib)(dpy, surface, attribute, value);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglSwapInterval(EGLDisplay dpy, EGLint interval)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglSwapInterval)(dpy, interval);
#endif
    return ret;
}

static EGLBoolean REGAL_CALL http_eglWaitClient(void)
{
    EGLBoolean  ret = 0;
    RegalContext *_context = REGAL_GET_CONTEXT();
    if( _context ) {
#if REGAL_HTTP
      if( _context->http.runState == RS_Next ) {
        _context->http.runState = RS_Pause;
      }
      _context->http.YieldToHttpServer( _context );
#endif
    }
#if REGAL_HTTP
    DispatchTableGlobal *_next = dispatcherGlobal.http.next();
    RegalAssert(_next);
    ret = _next->call(&_next->eglWaitClient)();
#endif
    return ret;
}

#endif // REGAL_SYS_EGL

void InitDispatchTableHttp(DispatchTableGL &tbl)
{

  // GL_VERSION_1_0

  tbl.glAccum = http_glAccum;
  tbl.glAlphaFunc = http_glAlphaFunc;
  tbl.glBegin = http_glBegin;
  tbl.glBitmap = http_glBitmap;
  tbl.glBlendFunc = http_glBlendFunc;
  tbl.glCallList = http_glCallList;
  tbl.glCallLists = http_glCallLists;
  tbl.glClear = http_glClear;
  tbl.glClearAccum = http_glClearAccum;
  tbl.glClearColor = http_glClearColor;
  tbl.glClearDepth = http_glClearDepth;
  tbl.glClearIndex = http_glClearIndex;
  tbl.glClearStencil = http_glClearStencil;
  tbl.glClipPlane = http_glClipPlane;
  tbl.glColor3b = http_glColor3b;
  tbl.glColor3bv = http_glColor3bv;
  tbl.glColor3d = http_glColor3d;
  tbl.glColor3dv = http_glColor3dv;
  tbl.glColor3f = http_glColor3f;
  tbl.glColor3fv = http_glColor3fv;
  tbl.glColor3i = http_glColor3i;
  tbl.glColor3iv = http_glColor3iv;
  tbl.glColor3s = http_glColor3s;
  tbl.glColor3sv = http_glColor3sv;
  tbl.glColor3ub = http_glColor3ub;
  tbl.glColor3ubv = http_glColor3ubv;
  tbl.glColor3ui = http_glColor3ui;
  tbl.glColor3uiv = http_glColor3uiv;
  tbl.glColor3us = http_glColor3us;
  tbl.glColor3usv = http_glColor3usv;
  tbl.glColor4b = http_glColor4b;
  tbl.glColor4bv = http_glColor4bv;
  tbl.glColor4d = http_glColor4d;
  tbl.glColor4dv = http_glColor4dv;
  tbl.glColor4f = http_glColor4f;
  tbl.glColor4fv = http_glColor4fv;
  tbl.glColor4i = http_glColor4i;
  tbl.glColor4iv = http_glColor4iv;
  tbl.glColor4s = http_glColor4s;
  tbl.glColor4sv = http_glColor4sv;
  tbl.glColor4ub = http_glColor4ub;
  tbl.glColor4ubv = http_glColor4ubv;
  tbl.glColor4ui = http_glColor4ui;
  tbl.glColor4uiv = http_glColor4uiv;
  tbl.glColor4us = http_glColor4us;
  tbl.glColor4usv = http_glColor4usv;
  tbl.glColorMask = http_glColorMask;
  tbl.glColorMaterial = http_glColorMaterial;
  tbl.glCopyPixels = http_glCopyPixels;
  tbl.glCullFace = http_glCullFace;
  tbl.glDeleteLists = http_glDeleteLists;
  tbl.glDepthFunc = http_glDepthFunc;
  tbl.glDepthMask = http_glDepthMask;
  tbl.glDepthRange = http_glDepthRange;
  tbl.glDisable = http_glDisable;
  tbl.glDrawBuffer = http_glDrawBuffer;
  tbl.glDrawPixels = http_glDrawPixels;
  tbl.glEdgeFlag = http_glEdgeFlag;
  tbl.glEdgeFlagv = http_glEdgeFlagv;
  tbl.glEnable = http_glEnable;
  tbl.glEnd = http_glEnd;
  tbl.glEndList = http_glEndList;
  tbl.glEvalCoord1d = http_glEvalCoord1d;
  tbl.glEvalCoord1dv = http_glEvalCoord1dv;
  tbl.glEvalCoord1f = http_glEvalCoord1f;
  tbl.glEvalCoord1fv = http_glEvalCoord1fv;
  tbl.glEvalCoord2d = http_glEvalCoord2d;
  tbl.glEvalCoord2dv = http_glEvalCoord2dv;
  tbl.glEvalCoord2f = http_glEvalCoord2f;
  tbl.glEvalCoord2fv = http_glEvalCoord2fv;
  tbl.glEvalMesh1 = http_glEvalMesh1;
  tbl.glEvalMesh2 = http_glEvalMesh2;
  tbl.glEvalPoint1 = http_glEvalPoint1;
  tbl.glEvalPoint2 = http_glEvalPoint2;
  tbl.glFeedbackBuffer = http_glFeedbackBuffer;
  tbl.glFinish = http_glFinish;
  tbl.glFlush = http_glFlush;
  tbl.glFogf = http_glFogf;
  tbl.glFogfv = http_glFogfv;
  tbl.glFogi = http_glFogi;
  tbl.glFogiv = http_glFogiv;
  tbl.glFrontFace = http_glFrontFace;
  tbl.glFrustum = http_glFrustum;
  tbl.glGenLists = http_glGenLists;
  tbl.glGetBooleanv = http_glGetBooleanv;
  tbl.glGetClipPlane = http_glGetClipPlane;
  tbl.glGetDoublev = http_glGetDoublev;
  tbl.glGetError = http_glGetError;
  tbl.glGetFloatv = http_glGetFloatv;
  tbl.glGetIntegerv = http_glGetIntegerv;
  tbl.glGetLightfv = http_glGetLightfv;
  tbl.glGetLightiv = http_glGetLightiv;
  tbl.glGetMapdv = http_glGetMapdv;
  tbl.glGetMapfv = http_glGetMapfv;
  tbl.glGetMapiv = http_glGetMapiv;
  tbl.glGetMaterialfv = http_glGetMaterialfv;
  tbl.glGetMaterialiv = http_glGetMaterialiv;
  tbl.glGetPixelMapfv = http_glGetPixelMapfv;
  tbl.glGetPixelMapuiv = http_glGetPixelMapuiv;
  tbl.glGetPixelMapusv = http_glGetPixelMapusv;
  tbl.glGetPolygonStipple = http_glGetPolygonStipple;
  tbl.glGetString = http_glGetString;
  tbl.glGetTexEnvfv = http_glGetTexEnvfv;
  tbl.glGetTexEnviv = http_glGetTexEnviv;
  tbl.glGetTexGendv = http_glGetTexGendv;
  tbl.glGetTexGenfv = http_glGetTexGenfv;
  tbl.glGetTexGeniv = http_glGetTexGeniv;
  tbl.glGetTexImage = http_glGetTexImage;
  tbl.glGetTexLevelParameterfv = http_glGetTexLevelParameterfv;
  tbl.glGetTexLevelParameteriv = http_glGetTexLevelParameteriv;
  tbl.glGetTexParameterfv = http_glGetTexParameterfv;
  tbl.glGetTexParameteriv = http_glGetTexParameteriv;
  tbl.glHint = http_glHint;
  tbl.glIndexMask = http_glIndexMask;
  tbl.glIndexd = http_glIndexd;
  tbl.glIndexdv = http_glIndexdv;
  tbl.glIndexf = http_glIndexf;
  tbl.glIndexfv = http_glIndexfv;
  tbl.glIndexi = http_glIndexi;
  tbl.glIndexiv = http_glIndexiv;
  tbl.glIndexs = http_glIndexs;
  tbl.glIndexsv = http_glIndexsv;
  tbl.glInitNames = http_glInitNames;
  tbl.glIsEnabled = http_glIsEnabled;
  tbl.glIsList = http_glIsList;
  tbl.glLightModelf = http_glLightModelf;
  tbl.glLightModelfv = http_glLightModelfv;
  tbl.glLightModeli = http_glLightModeli;
  tbl.glLightModeliv = http_glLightModeliv;
  tbl.glLightf = http_glLightf;
  tbl.glLightfv = http_glLightfv;
  tbl.glLighti = http_glLighti;
  tbl.glLightiv = http_glLightiv;
  tbl.glLineStipple = http_glLineStipple;
  tbl.glLineWidth = http_glLineWidth;
  tbl.glListBase = http_glListBase;
  tbl.glLoadIdentity = http_glLoadIdentity;
  tbl.glLoadMatrixd = http_glLoadMatrixd;
  tbl.glLoadMatrixf = http_glLoadMatrixf;
  tbl.glLoadName = http_glLoadName;
  tbl.glLogicOp = http_glLogicOp;
  tbl.glMap1d = http_glMap1d;
  tbl.glMap1f = http_glMap1f;
  tbl.glMap2d = http_glMap2d;
  tbl.glMap2f = http_glMap2f;
  tbl.glMapGrid1d = http_glMapGrid1d;
  tbl.glMapGrid1f = http_glMapGrid1f;
  tbl.glMapGrid2d = http_glMapGrid2d;
  tbl.glMapGrid2f = http_glMapGrid2f;
  tbl.glMaterialf = http_glMaterialf;
  tbl.glMaterialfv = http_glMaterialfv;
  tbl.glMateriali = http_glMateriali;
  tbl.glMaterialiv = http_glMaterialiv;
  tbl.glMatrixMode = http_glMatrixMode;
  tbl.glMultMatrixd = http_glMultMatrixd;
  tbl.glMultMatrixf = http_glMultMatrixf;
  tbl.glNewList = http_glNewList;
  tbl.glNormal3b = http_glNormal3b;
  tbl.glNormal3bv = http_glNormal3bv;
  tbl.glNormal3d = http_glNormal3d;
  tbl.glNormal3dv = http_glNormal3dv;
  tbl.glNormal3f = http_glNormal3f;
  tbl.glNormal3fv = http_glNormal3fv;
  tbl.glNormal3i = http_glNormal3i;
  tbl.glNormal3iv = http_glNormal3iv;
  tbl.glNormal3s = http_glNormal3s;
  tbl.glNormal3sv = http_glNormal3sv;
  tbl.glOrtho = http_glOrtho;
  tbl.glPassThrough = http_glPassThrough;
  tbl.glPixelMapfv = http_glPixelMapfv;
  tbl.glPixelMapuiv = http_glPixelMapuiv;
  tbl.glPixelMapusv = http_glPixelMapusv;
  tbl.glPixelStoref = http_glPixelStoref;
  tbl.glPixelStorei = http_glPixelStorei;
  tbl.glPixelTransferf = http_glPixelTransferf;
  tbl.glPixelTransferi = http_glPixelTransferi;
  tbl.glPixelZoom = http_glPixelZoom;
  tbl.glPointSize = http_glPointSize;
  tbl.glPolygonMode = http_glPolygonMode;
  tbl.glPolygonStipple = http_glPolygonStipple;
  tbl.glPopAttrib = http_glPopAttrib;
  tbl.glPopMatrix = http_glPopMatrix;
  tbl.glPopName = http_glPopName;
  tbl.glPushAttrib = http_glPushAttrib;
  tbl.glPushMatrix = http_glPushMatrix;
  tbl.glPushName = http_glPushName;
  tbl.glRasterPos2d = http_glRasterPos2d;
  tbl.glRasterPos2dv = http_glRasterPos2dv;
  tbl.glRasterPos2f = http_glRasterPos2f;
  tbl.glRasterPos2fv = http_glRasterPos2fv;
  tbl.glRasterPos2i = http_glRasterPos2i;
  tbl.glRasterPos2iv = http_glRasterPos2iv;
  tbl.glRasterPos2s = http_glRasterPos2s;
  tbl.glRasterPos2sv = http_glRasterPos2sv;
  tbl.glRasterPos3d = http_glRasterPos3d;
  tbl.glRasterPos3dv = http_glRasterPos3dv;
  tbl.glRasterPos3f = http_glRasterPos3f;
  tbl.glRasterPos3fv = http_glRasterPos3fv;
  tbl.glRasterPos3i = http_glRasterPos3i;
  tbl.glRasterPos3iv = http_glRasterPos3iv;
  tbl.glRasterPos3s = http_glRasterPos3s;
  tbl.glRasterPos3sv = http_glRasterPos3sv;
  tbl.glRasterPos4d = http_glRasterPos4d;
  tbl.glRasterPos4dv = http_glRasterPos4dv;
  tbl.glRasterPos4f = http_glRasterPos4f;
  tbl.glRasterPos4fv = http_glRasterPos4fv;
  tbl.glRasterPos4i = http_glRasterPos4i;
  tbl.glRasterPos4iv = http_glRasterPos4iv;
  tbl.glRasterPos4s = http_glRasterPos4s;
  tbl.glRasterPos4sv = http_glRasterPos4sv;
  tbl.glReadBuffer = http_glReadBuffer;
  tbl.glReadPixels = http_glReadPixels;
  tbl.glRectd = http_glRectd;
  tbl.glRectdv = http_glRectdv;
  tbl.glRectf = http_glRectf;
  tbl.glRectfv = http_glRectfv;
  tbl.glRecti = http_glRecti;
  tbl.glRectiv = http_glRectiv;
  tbl.glRects = http_glRects;
  tbl.glRectsv = http_glRectsv;
  tbl.glRenderMode = http_glRenderMode;
  tbl.glRotated = http_glRotated;
  tbl.glRotatef = http_glRotatef;
  tbl.glScaled = http_glScaled;
  tbl.glScalef = http_glScalef;
  tbl.glScissor = http_glScissor;
  tbl.glSelectBuffer = http_glSelectBuffer;
  tbl.glShadeModel = http_glShadeModel;
  tbl.glStencilFunc = http_glStencilFunc;
  tbl.glStencilMask = http_glStencilMask;
  tbl.glStencilOp = http_glStencilOp;
  tbl.glTexCoord1d = http_glTexCoord1d;
  tbl.glTexCoord1dv = http_glTexCoord1dv;
  tbl.glTexCoord1f = http_glTexCoord1f;
  tbl.glTexCoord1fv = http_glTexCoord1fv;
  tbl.glTexCoord1i = http_glTexCoord1i;
  tbl.glTexCoord1iv = http_glTexCoord1iv;
  tbl.glTexCoord1s = http_glTexCoord1s;
  tbl.glTexCoord1sv = http_glTexCoord1sv;
  tbl.glTexCoord2d = http_glTexCoord2d;
  tbl.glTexCoord2dv = http_glTexCoord2dv;
  tbl.glTexCoord2f = http_glTexCoord2f;
  tbl.glTexCoord2fv = http_glTexCoord2fv;
  tbl.glTexCoord2i = http_glTexCoord2i;
  tbl.glTexCoord2iv = http_glTexCoord2iv;
  tbl.glTexCoord2s = http_glTexCoord2s;
  tbl.glTexCoord2sv = http_glTexCoord2sv;
  tbl.glTexCoord3d = http_glTexCoord3d;
  tbl.glTexCoord3dv = http_glTexCoord3dv;
  tbl.glTexCoord3f = http_glTexCoord3f;
  tbl.glTexCoord3fv = http_glTexCoord3fv;
  tbl.glTexCoord3i = http_glTexCoord3i;
  tbl.glTexCoord3iv = http_glTexCoord3iv;
  tbl.glTexCoord3s = http_glTexCoord3s;
  tbl.glTexCoord3sv = http_glTexCoord3sv;
  tbl.glTexCoord4d = http_glTexCoord4d;
  tbl.glTexCoord4dv = http_glTexCoord4dv;
  tbl.glTexCoord4f = http_glTexCoord4f;
  tbl.glTexCoord4fv = http_glTexCoord4fv;
  tbl.glTexCoord4i = http_glTexCoord4i;
  tbl.glTexCoord4iv = http_glTexCoord4iv;
  tbl.glTexCoord4s = http_glTexCoord4s;
  tbl.glTexCoord4sv = http_glTexCoord4sv;
  tbl.glTexEnvf = http_glTexEnvf;
  tbl.glTexEnvfv = http_glTexEnvfv;
  tbl.glTexEnvi = http_glTexEnvi;
  tbl.glTexEnviv = http_glTexEnviv;
  tbl.glTexGend = http_glTexGend;
  tbl.glTexGendv = http_glTexGendv;
  tbl.glTexGenf = http_glTexGenf;
  tbl.glTexGenfv = http_glTexGenfv;
  tbl.glTexGeni = http_glTexGeni;
  tbl.glTexGeniv = http_glTexGeniv;
  tbl.glTexImage1D = http_glTexImage1D;
  tbl.glTexImage2D = http_glTexImage2D;
  tbl.glTexParameterf = http_glTexParameterf;
  tbl.glTexParameterfv = http_glTexParameterfv;
  tbl.glTexParameteri = http_glTexParameteri;
  tbl.glTexParameteriv = http_glTexParameteriv;
  tbl.glTranslated = http_glTranslated;
  tbl.glTranslatef = http_glTranslatef;
  tbl.glVertex2d = http_glVertex2d;
  tbl.glVertex2dv = http_glVertex2dv;
  tbl.glVertex2f = http_glVertex2f;
  tbl.glVertex2fv = http_glVertex2fv;
  tbl.glVertex2i = http_glVertex2i;
  tbl.glVertex2iv = http_glVertex2iv;
  tbl.glVertex2s = http_glVertex2s;
  tbl.glVertex2sv = http_glVertex2sv;
  tbl.glVertex3d = http_glVertex3d;
  tbl.glVertex3dv = http_glVertex3dv;
  tbl.glVertex3f = http_glVertex3f;
  tbl.glVertex3fv = http_glVertex3fv;
  tbl.glVertex3i = http_glVertex3i;
  tbl.glVertex3iv = http_glVertex3iv;
  tbl.glVertex3s = http_glVertex3s;
  tbl.glVertex3sv = http_glVertex3sv;
  tbl.glVertex4d = http_glVertex4d;
  tbl.glVertex4dv = http_glVertex4dv;
  tbl.glVertex4f = http_glVertex4f;
  tbl.glVertex4fv = http_glVertex4fv;
  tbl.glVertex4i = http_glVertex4i;
  tbl.glVertex4iv = http_glVertex4iv;
  tbl.glVertex4s = http_glVertex4s;
  tbl.glVertex4sv = http_glVertex4sv;
  tbl.glViewport = http_glViewport;

  // GL_VERSION_1_1

  tbl.glAreTexturesResident = http_glAreTexturesResident;
  tbl.glArrayElement = http_glArrayElement;
  tbl.glBindTexture = http_glBindTexture;
  tbl.glColorPointer = http_glColorPointer;
  tbl.glCopyTexImage1D = http_glCopyTexImage1D;
  tbl.glCopyTexImage2D = http_glCopyTexImage2D;
  tbl.glCopyTexSubImage1D = http_glCopyTexSubImage1D;
  tbl.glCopyTexSubImage2D = http_glCopyTexSubImage2D;
  tbl.glDeleteTextures = http_glDeleteTextures;
  tbl.glDisableClientState = http_glDisableClientState;
  tbl.glDrawArrays = http_glDrawArrays;
  tbl.glDrawElements = http_glDrawElements;
  tbl.glEdgeFlagPointer = http_glEdgeFlagPointer;
  tbl.glEnableClientState = http_glEnableClientState;
  tbl.glGenTextures = http_glGenTextures;
  tbl.glGetPointerv = http_glGetPointerv;
  tbl.glIndexPointer = http_glIndexPointer;
  tbl.glIndexub = http_glIndexub;
  tbl.glIndexubv = http_glIndexubv;
  tbl.glInterleavedArrays = http_glInterleavedArrays;
  tbl.glIsTexture = http_glIsTexture;
  tbl.glNormalPointer = http_glNormalPointer;
  tbl.glPolygonOffset = http_glPolygonOffset;
  tbl.glPopClientAttrib = http_glPopClientAttrib;
  tbl.glPrioritizeTextures = http_glPrioritizeTextures;
  tbl.glPushClientAttrib = http_glPushClientAttrib;
  tbl.glTexCoordPointer = http_glTexCoordPointer;
  tbl.glTexSubImage1D = http_glTexSubImage1D;
  tbl.glTexSubImage2D = http_glTexSubImage2D;
  tbl.glVertexPointer = http_glVertexPointer;

  // GL_VERSION_1_2

  tbl.glBlendColor = http_glBlendColor;
  tbl.glBlendEquation = http_glBlendEquation;
  tbl.glCopyTexSubImage3D = http_glCopyTexSubImage3D;
  tbl.glDrawRangeElements = http_glDrawRangeElements;
  tbl.glTexImage3D = http_glTexImage3D;
  tbl.glTexSubImage3D = http_glTexSubImage3D;

  // GL_VERSION_1_3

  tbl.glActiveTexture = http_glActiveTexture;
  tbl.glClientActiveTexture = http_glClientActiveTexture;
  tbl.glCompressedTexImage1D = http_glCompressedTexImage1D;
  tbl.glCompressedTexImage2D = http_glCompressedTexImage2D;
  tbl.glCompressedTexImage3D = http_glCompressedTexImage3D;
  tbl.glCompressedTexSubImage1D = http_glCompressedTexSubImage1D;
  tbl.glCompressedTexSubImage2D = http_glCompressedTexSubImage2D;
  tbl.glCompressedTexSubImage3D = http_glCompressedTexSubImage3D;
  tbl.glGetCompressedTexImage = http_glGetCompressedTexImage;
  tbl.glLoadTransposeMatrixd = http_glLoadTransposeMatrixd;
  tbl.glLoadTransposeMatrixf = http_glLoadTransposeMatrixf;
  tbl.glMultTransposeMatrixd = http_glMultTransposeMatrixd;
  tbl.glMultTransposeMatrixf = http_glMultTransposeMatrixf;
  tbl.glMultiTexCoord1d = http_glMultiTexCoord1d;
  tbl.glMultiTexCoord1dv = http_glMultiTexCoord1dv;
  tbl.glMultiTexCoord1f = http_glMultiTexCoord1f;
  tbl.glMultiTexCoord1fv = http_glMultiTexCoord1fv;
  tbl.glMultiTexCoord1i = http_glMultiTexCoord1i;
  tbl.glMultiTexCoord1iv = http_glMultiTexCoord1iv;
  tbl.glMultiTexCoord1s = http_glMultiTexCoord1s;
  tbl.glMultiTexCoord1sv = http_glMultiTexCoord1sv;
  tbl.glMultiTexCoord2d = http_glMultiTexCoord2d;
  tbl.glMultiTexCoord2dv = http_glMultiTexCoord2dv;
  tbl.glMultiTexCoord2f = http_glMultiTexCoord2f;
  tbl.glMultiTexCoord2fv = http_glMultiTexCoord2fv;
  tbl.glMultiTexCoord2i = http_glMultiTexCoord2i;
  tbl.glMultiTexCoord2iv = http_glMultiTexCoord2iv;
  tbl.glMultiTexCoord2s = http_glMultiTexCoord2s;
  tbl.glMultiTexCoord2sv = http_glMultiTexCoord2sv;
  tbl.glMultiTexCoord3d = http_glMultiTexCoord3d;
  tbl.glMultiTexCoord3dv = http_glMultiTexCoord3dv;
  tbl.glMultiTexCoord3f = http_glMultiTexCoord3f;
  tbl.glMultiTexCoord3fv = http_glMultiTexCoord3fv;
  tbl.glMultiTexCoord3i = http_glMultiTexCoord3i;
  tbl.glMultiTexCoord3iv = http_glMultiTexCoord3iv;
  tbl.glMultiTexCoord3s = http_glMultiTexCoord3s;
  tbl.glMultiTexCoord3sv = http_glMultiTexCoord3sv;
  tbl.glMultiTexCoord4d = http_glMultiTexCoord4d;
  tbl.glMultiTexCoord4dv = http_glMultiTexCoord4dv;
  tbl.glMultiTexCoord4f = http_glMultiTexCoord4f;
  tbl.glMultiTexCoord4fv = http_glMultiTexCoord4fv;
  tbl.glMultiTexCoord4i = http_glMultiTexCoord4i;
  tbl.glMultiTexCoord4iv = http_glMultiTexCoord4iv;
  tbl.glMultiTexCoord4s = http_glMultiTexCoord4s;
  tbl.glMultiTexCoord4sv = http_glMultiTexCoord4sv;
  tbl.glSampleCoverage = http_glSampleCoverage;

  // GL_VERSION_1_4

  tbl.glBlendFuncSeparate = http_glBlendFuncSeparate;
  tbl.glFogCoordPointer = http_glFogCoordPointer;
  tbl.glFogCoordd = http_glFogCoordd;
  tbl.glFogCoorddv = http_glFogCoorddv;
  tbl.glFogCoordf = http_glFogCoordf;
  tbl.glFogCoordfv = http_glFogCoordfv;
  tbl.glMultiDrawArrays = http_glMultiDrawArrays;
  tbl.glMultiDrawElements = http_glMultiDrawElements;
  tbl.glPointParameterf = http_glPointParameterf;
  tbl.glPointParameterfv = http_glPointParameterfv;
  tbl.glPointParameteri = http_glPointParameteri;
  tbl.glPointParameteriv = http_glPointParameteriv;
  tbl.glSecondaryColor3b = http_glSecondaryColor3b;
  tbl.glSecondaryColor3bv = http_glSecondaryColor3bv;
  tbl.glSecondaryColor3d = http_glSecondaryColor3d;
  tbl.glSecondaryColor3dv = http_glSecondaryColor3dv;
  tbl.glSecondaryColor3f = http_glSecondaryColor3f;
  tbl.glSecondaryColor3fv = http_glSecondaryColor3fv;
  tbl.glSecondaryColor3i = http_glSecondaryColor3i;
  tbl.glSecondaryColor3iv = http_glSecondaryColor3iv;
  tbl.glSecondaryColor3s = http_glSecondaryColor3s;
  tbl.glSecondaryColor3sv = http_glSecondaryColor3sv;
  tbl.glSecondaryColor3ub = http_glSecondaryColor3ub;
  tbl.glSecondaryColor3ubv = http_glSecondaryColor3ubv;
  tbl.glSecondaryColor3ui = http_glSecondaryColor3ui;
  tbl.glSecondaryColor3uiv = http_glSecondaryColor3uiv;
  tbl.glSecondaryColor3us = http_glSecondaryColor3us;
  tbl.glSecondaryColor3usv = http_glSecondaryColor3usv;
  tbl.glSecondaryColorPointer = http_glSecondaryColorPointer;
  tbl.glWindowPos2d = http_glWindowPos2d;
  tbl.glWindowPos2dv = http_glWindowPos2dv;
  tbl.glWindowPos2f = http_glWindowPos2f;
  tbl.glWindowPos2fv = http_glWindowPos2fv;
  tbl.glWindowPos2i = http_glWindowPos2i;
  tbl.glWindowPos2iv = http_glWindowPos2iv;
  tbl.glWindowPos2s = http_glWindowPos2s;
  tbl.glWindowPos2sv = http_glWindowPos2sv;
  tbl.glWindowPos3d = http_glWindowPos3d;
  tbl.glWindowPos3dv = http_glWindowPos3dv;
  tbl.glWindowPos3f = http_glWindowPos3f;
  tbl.glWindowPos3fv = http_glWindowPos3fv;
  tbl.glWindowPos3i = http_glWindowPos3i;
  tbl.glWindowPos3iv = http_glWindowPos3iv;
  tbl.glWindowPos3s = http_glWindowPos3s;
  tbl.glWindowPos3sv = http_glWindowPos3sv;

  // GL_VERSION_1_5

  tbl.glBeginQuery = http_glBeginQuery;
  tbl.glBindBuffer = http_glBindBuffer;
  tbl.glBufferData = http_glBufferData;
  tbl.glBufferSubData = http_glBufferSubData;
  tbl.glDeleteBuffers = http_glDeleteBuffers;
  tbl.glDeleteQueries = http_glDeleteQueries;
  tbl.glEndQuery = http_glEndQuery;
  tbl.glGenBuffers = http_glGenBuffers;
  tbl.glGenQueries = http_glGenQueries;
  tbl.glGetBufferParameteriv = http_glGetBufferParameteriv;
  tbl.glGetBufferPointerv = http_glGetBufferPointerv;
  tbl.glGetBufferSubData = http_glGetBufferSubData;
  tbl.glGetQueryObjectiv = http_glGetQueryObjectiv;
  tbl.glGetQueryObjectuiv = http_glGetQueryObjectuiv;
  tbl.glGetQueryiv = http_glGetQueryiv;
  tbl.glIsBuffer = http_glIsBuffer;
  tbl.glIsQuery = http_glIsQuery;
  tbl.glMapBuffer = http_glMapBuffer;
  tbl.glUnmapBuffer = http_glUnmapBuffer;

  // GL_VERSION_2_0

  tbl.glAttachShader = http_glAttachShader;
  tbl.glBindAttribLocation = http_glBindAttribLocation;
  tbl.glBlendEquationSeparate = http_glBlendEquationSeparate;
  tbl.glCompileShader = http_glCompileShader;
  tbl.glCreateProgram = http_glCreateProgram;
  tbl.glCreateShader = http_glCreateShader;
  tbl.glDeleteProgram = http_glDeleteProgram;
  tbl.glDeleteShader = http_glDeleteShader;
  tbl.glDetachShader = http_glDetachShader;
  tbl.glDisableVertexAttribArray = http_glDisableVertexAttribArray;
  tbl.glDrawBuffers = http_glDrawBuffers;
  tbl.glEnableVertexAttribArray = http_glEnableVertexAttribArray;
  tbl.glGetActiveAttrib = http_glGetActiveAttrib;
  tbl.glGetActiveUniform = http_glGetActiveUniform;
  tbl.glGetAttachedShaders = http_glGetAttachedShaders;
  tbl.glGetAttribLocation = http_glGetAttribLocation;
  tbl.glGetProgramInfoLog = http_glGetProgramInfoLog;
  tbl.glGetProgramiv = http_glGetProgramiv;
  tbl.glGetShaderInfoLog = http_glGetShaderInfoLog;
  tbl.glGetShaderSource = http_glGetShaderSource;
  tbl.glGetShaderiv = http_glGetShaderiv;
  tbl.glGetUniformLocation = http_glGetUniformLocation;
  tbl.glGetUniformfv = http_glGetUniformfv;
  tbl.glGetUniformiv = http_glGetUniformiv;
  tbl.glGetVertexAttribPointerv = http_glGetVertexAttribPointerv;
  tbl.glGetVertexAttribdv = http_glGetVertexAttribdv;
  tbl.glGetVertexAttribfv = http_glGetVertexAttribfv;
  tbl.glGetVertexAttribiv = http_glGetVertexAttribiv;
  tbl.glIsProgram = http_glIsProgram;
  tbl.glIsShader = http_glIsShader;
  tbl.glLinkProgram = http_glLinkProgram;
  tbl.glShaderSource = http_glShaderSource;
  tbl.glStencilFuncSeparate = http_glStencilFuncSeparate;
  tbl.glStencilMaskSeparate = http_glStencilMaskSeparate;
  tbl.glStencilOpSeparate = http_glStencilOpSeparate;
  tbl.glUniform1f = http_glUniform1f;
  tbl.glUniform1fv = http_glUniform1fv;
  tbl.glUniform1i = http_glUniform1i;
  tbl.glUniform1iv = http_glUniform1iv;
  tbl.glUniform2f = http_glUniform2f;
  tbl.glUniform2fv = http_glUniform2fv;
  tbl.glUniform2i = http_glUniform2i;
  tbl.glUniform2iv = http_glUniform2iv;
  tbl.glUniform3f = http_glUniform3f;
  tbl.glUniform3fv = http_glUniform3fv;
  tbl.glUniform3i = http_glUniform3i;
  tbl.glUniform3iv = http_glUniform3iv;
  tbl.glUniform4f = http_glUniform4f;
  tbl.glUniform4fv = http_glUniform4fv;
  tbl.glUniform4i = http_glUniform4i;
  tbl.glUniform4iv = http_glUniform4iv;
  tbl.glUniformMatrix2fv = http_glUniformMatrix2fv;
  tbl.glUniformMatrix3fv = http_glUniformMatrix3fv;
  tbl.glUniformMatrix4fv = http_glUniformMatrix4fv;
  tbl.glUseProgram = http_glUseProgram;
  tbl.glValidateProgram = http_glValidateProgram;
  tbl.glVertexAttrib1d = http_glVertexAttrib1d;
  tbl.glVertexAttrib1dv = http_glVertexAttrib1dv;
  tbl.glVertexAttrib1f = http_glVertexAttrib1f;
  tbl.glVertexAttrib1fv = http_glVertexAttrib1fv;
  tbl.glVertexAttrib1s = http_glVertexAttrib1s;
  tbl.glVertexAttrib1sv = http_glVertexAttrib1sv;
  tbl.glVertexAttrib2d = http_glVertexAttrib2d;
  tbl.glVertexAttrib2dv = http_glVertexAttrib2dv;
  tbl.glVertexAttrib2f = http_glVertexAttrib2f;
  tbl.glVertexAttrib2fv = http_glVertexAttrib2fv;
  tbl.glVertexAttrib2s = http_glVertexAttrib2s;
  tbl.glVertexAttrib2sv = http_glVertexAttrib2sv;
  tbl.glVertexAttrib3d = http_glVertexAttrib3d;
  tbl.glVertexAttrib3dv = http_glVertexAttrib3dv;
  tbl.glVertexAttrib3f = http_glVertexAttrib3f;
  tbl.glVertexAttrib3fv = http_glVertexAttrib3fv;
  tbl.glVertexAttrib3s = http_glVertexAttrib3s;
  tbl.glVertexAttrib3sv = http_glVertexAttrib3sv;
  tbl.glVertexAttrib4Nbv = http_glVertexAttrib4Nbv;
  tbl.glVertexAttrib4Niv = http_glVertexAttrib4Niv;
  tbl.glVertexAttrib4Nsv = http_glVertexAttrib4Nsv;
  tbl.glVertexAttrib4Nub = http_glVertexAttrib4Nub;
  tbl.glVertexAttrib4Nubv = http_glVertexAttrib4Nubv;
  tbl.glVertexAttrib4Nuiv = http_glVertexAttrib4Nuiv;
  tbl.glVertexAttrib4Nusv = http_glVertexAttrib4Nusv;
  tbl.glVertexAttrib4bv = http_glVertexAttrib4bv;
  tbl.glVertexAttrib4d = http_glVertexAttrib4d;
  tbl.glVertexAttrib4dv = http_glVertexAttrib4dv;
  tbl.glVertexAttrib4f = http_glVertexAttrib4f;
  tbl.glVertexAttrib4fv = http_glVertexAttrib4fv;
  tbl.glVertexAttrib4iv = http_glVertexAttrib4iv;
  tbl.glVertexAttrib4s = http_glVertexAttrib4s;
  tbl.glVertexAttrib4sv = http_glVertexAttrib4sv;
  tbl.glVertexAttrib4ubv = http_glVertexAttrib4ubv;
  tbl.glVertexAttrib4uiv = http_glVertexAttrib4uiv;
  tbl.glVertexAttrib4usv = http_glVertexAttrib4usv;
  tbl.glVertexAttribPointer = http_glVertexAttribPointer;

  // GL_VERSION_2_1

  tbl.glUniformMatrix2x3fv = http_glUniformMatrix2x3fv;
  tbl.glUniformMatrix2x4fv = http_glUniformMatrix2x4fv;
  tbl.glUniformMatrix3x2fv = http_glUniformMatrix3x2fv;
  tbl.glUniformMatrix3x4fv = http_glUniformMatrix3x4fv;
  tbl.glUniformMatrix4x2fv = http_glUniformMatrix4x2fv;
  tbl.glUniformMatrix4x3fv = http_glUniformMatrix4x3fv;

  // GL_VERSION_3_0

  tbl.glBeginConditionalRender = http_glBeginConditionalRender;
  tbl.glBeginTransformFeedback = http_glBeginTransformFeedback;
  tbl.glBindFragDataLocation = http_glBindFragDataLocation;
  tbl.glClampColor = http_glClampColor;
  tbl.glClearBufferfi = http_glClearBufferfi;
  tbl.glClearBufferfv = http_glClearBufferfv;
  tbl.glClearBufferiv = http_glClearBufferiv;
  tbl.glClearBufferuiv = http_glClearBufferuiv;
  tbl.glColorMaski = http_glColorMaski;
  tbl.glDisablei = http_glDisablei;
  tbl.glEnablei = http_glEnablei;
  tbl.glEndConditionalRender = http_glEndConditionalRender;
  tbl.glEndTransformFeedback = http_glEndTransformFeedback;
  tbl.glGetBooleani_v = http_glGetBooleani_v;
  tbl.glGetFragDataLocation = http_glGetFragDataLocation;
  tbl.glGetStringi = http_glGetStringi;
  tbl.glGetTexParameterIiv = http_glGetTexParameterIiv;
  tbl.glGetTexParameterIuiv = http_glGetTexParameterIuiv;
  tbl.glGetTransformFeedbackVarying = http_glGetTransformFeedbackVarying;
  tbl.glGetUniformuiv = http_glGetUniformuiv;
  tbl.glGetVertexAttribIiv = http_glGetVertexAttribIiv;
  tbl.glGetVertexAttribIuiv = http_glGetVertexAttribIuiv;
  tbl.glIsEnabledi = http_glIsEnabledi;
  tbl.glTexParameterIiv = http_glTexParameterIiv;
  tbl.glTexParameterIuiv = http_glTexParameterIuiv;
  tbl.glTransformFeedbackVaryings = http_glTransformFeedbackVaryings;
  tbl.glUniform1ui = http_glUniform1ui;
  tbl.glUniform1uiv = http_glUniform1uiv;
  tbl.glUniform2ui = http_glUniform2ui;
  tbl.glUniform2uiv = http_glUniform2uiv;
  tbl.glUniform3ui = http_glUniform3ui;
  tbl.glUniform3uiv = http_glUniform3uiv;
  tbl.glUniform4ui = http_glUniform4ui;
  tbl.glUniform4uiv = http_glUniform4uiv;
  tbl.glVertexAttribI1i = http_glVertexAttribI1i;
  tbl.glVertexAttribI1iv = http_glVertexAttribI1iv;
  tbl.glVertexAttribI1ui = http_glVertexAttribI1ui;
  tbl.glVertexAttribI1uiv = http_glVertexAttribI1uiv;
  tbl.glVertexAttribI2i = http_glVertexAttribI2i;
  tbl.glVertexAttribI2iv = http_glVertexAttribI2iv;
  tbl.glVertexAttribI2ui = http_glVertexAttribI2ui;
  tbl.glVertexAttribI2uiv = http_glVertexAttribI2uiv;
  tbl.glVertexAttribI3i = http_glVertexAttribI3i;
  tbl.glVertexAttribI3iv = http_glVertexAttribI3iv;
  tbl.glVertexAttribI3ui = http_glVertexAttribI3ui;
  tbl.glVertexAttribI3uiv = http_glVertexAttribI3uiv;
  tbl.glVertexAttribI4bv = http_glVertexAttribI4bv;
  tbl.glVertexAttribI4i = http_glVertexAttribI4i;
  tbl.glVertexAttribI4iv = http_glVertexAttribI4iv;
  tbl.glVertexAttribI4sv = http_glVertexAttribI4sv;
  tbl.glVertexAttribI4ubv = http_glVertexAttribI4ubv;
  tbl.glVertexAttribI4ui = http_glVertexAttribI4ui;
  tbl.glVertexAttribI4uiv = http_glVertexAttribI4uiv;
  tbl.glVertexAttribI4usv = http_glVertexAttribI4usv;
  tbl.glVertexAttribIPointer = http_glVertexAttribIPointer;

  // GL_VERSION_3_1

  tbl.glDrawArraysInstanced = http_glDrawArraysInstanced;
  tbl.glDrawElementsInstanced = http_glDrawElementsInstanced;
  tbl.glPrimitiveRestartIndex = http_glPrimitiveRestartIndex;
  tbl.glTexBuffer = http_glTexBuffer;

  // GL_VERSION_3_2

  tbl.glFramebufferTexture = http_glFramebufferTexture;
  tbl.glGetBufferParameteri64v = http_glGetBufferParameteri64v;
  tbl.glGetInteger64i_v = http_glGetInteger64i_v;

  // GL_VERSION_3_3

  tbl.glVertexAttribDivisor = http_glVertexAttribDivisor;

  // GL_VERSION_4_0

  tbl.glBlendEquationSeparatei = http_glBlendEquationSeparatei;
  tbl.glBlendEquationi = http_glBlendEquationi;
  tbl.glBlendFuncSeparatei = http_glBlendFuncSeparatei;
  tbl.glBlendFunci = http_glBlendFunci;

  // GL_3DFX_tbuffer

  tbl.glTbufferMask3DFX = http_glTbufferMask3DFX;

  // GL_AMD_debug_output

  tbl.glDebugMessageCallbackAMD = http_glDebugMessageCallbackAMD;
  tbl.glDebugMessageEnableAMD = http_glDebugMessageEnableAMD;
  tbl.glDebugMessageInsertAMD = http_glDebugMessageInsertAMD;
  tbl.glGetDebugMessageLogAMD = http_glGetDebugMessageLogAMD;

  // GL_AMD_draw_buffers_blend

  tbl.glBlendEquationIndexedAMD = http_glBlendEquationIndexedAMD;
  tbl.glBlendEquationSeparateIndexedAMD = http_glBlendEquationSeparateIndexedAMD;
  tbl.glBlendFuncIndexedAMD = http_glBlendFuncIndexedAMD;
  tbl.glBlendFuncSeparateIndexedAMD = http_glBlendFuncSeparateIndexedAMD;

  // GL_AMD_interleaved_elements

  tbl.glVertexAttribParameteriAMD = http_glVertexAttribParameteriAMD;

  // GL_AMD_multi_draw_indirect

  tbl.glMultiDrawArraysIndirectAMD = http_glMultiDrawArraysIndirectAMD;
  tbl.glMultiDrawElementsIndirectAMD = http_glMultiDrawElementsIndirectAMD;

  // GL_AMD_name_gen_delete

  tbl.glDeleteNamesAMD = http_glDeleteNamesAMD;
  tbl.glGenNamesAMD = http_glGenNamesAMD;
  tbl.glIsNameAMD = http_glIsNameAMD;

  // GL_AMD_performance_monitor

  tbl.glBeginPerfMonitorAMD = http_glBeginPerfMonitorAMD;
  tbl.glDeletePerfMonitorsAMD = http_glDeletePerfMonitorsAMD;
  tbl.glEndPerfMonitorAMD = http_glEndPerfMonitorAMD;
  tbl.glGenPerfMonitorsAMD = http_glGenPerfMonitorsAMD;
  tbl.glGetPerfMonitorCounterDataAMD = http_glGetPerfMonitorCounterDataAMD;
  tbl.glGetPerfMonitorCounterInfoAMD = http_glGetPerfMonitorCounterInfoAMD;
  tbl.glGetPerfMonitorCounterStringAMD = http_glGetPerfMonitorCounterStringAMD;
  tbl.glGetPerfMonitorCountersAMD = http_glGetPerfMonitorCountersAMD;
  tbl.glGetPerfMonitorGroupStringAMD = http_glGetPerfMonitorGroupStringAMD;
  tbl.glGetPerfMonitorGroupsAMD = http_glGetPerfMonitorGroupsAMD;
  tbl.glSelectPerfMonitorCountersAMD = http_glSelectPerfMonitorCountersAMD;

  // GL_AMD_sample_positions

  tbl.glSetMultisamplefvAMD = http_glSetMultisamplefvAMD;

  // GL_AMD_sparse_texture

  tbl.glTexStorageSparseAMD = http_glTexStorageSparseAMD;
  tbl.glTextureStorageSparseAMD = http_glTextureStorageSparseAMD;

  // GL_AMD_stencil_operation_extended

  tbl.glStencilOpValueAMD = http_glStencilOpValueAMD;

  // GL_AMD_vertex_shader_tessellator

  tbl.glTessellationFactorAMD = http_glTessellationFactorAMD;
  tbl.glTessellationModeAMD = http_glTessellationModeAMD;

  // GL_ANGLE_framebuffer_blit

  tbl.glBlitFramebufferANGLE = http_glBlitFramebufferANGLE;

  // GL_ANGLE_framebuffer_multisample

  tbl.glRenderbufferStorageMultisampleANGLE = http_glRenderbufferStorageMultisampleANGLE;

  // GL_ANGLE_instanced_arrays

  tbl.glDrawArraysInstancedANGLE = http_glDrawArraysInstancedANGLE;
  tbl.glDrawElementsInstancedANGLE = http_glDrawElementsInstancedANGLE;
  tbl.glVertexAttribDivisorANGLE = http_glVertexAttribDivisorANGLE;

  // GL_ANGLE_timer_query

  tbl.glBeginQueryANGLE = http_glBeginQueryANGLE;
  tbl.glDeleteQueriesANGLE = http_glDeleteQueriesANGLE;
  tbl.glEndQueryANGLE = http_glEndQueryANGLE;
  tbl.glGenQueriesANGLE = http_glGenQueriesANGLE;
  tbl.glGetQueryObjecti64vANGLE = http_glGetQueryObjecti64vANGLE;
  tbl.glGetQueryObjectivANGLE = http_glGetQueryObjectivANGLE;
  tbl.glGetQueryObjectui64vANGLE = http_glGetQueryObjectui64vANGLE;
  tbl.glGetQueryObjectuivANGLE = http_glGetQueryObjectuivANGLE;
  tbl.glGetQueryivANGLE = http_glGetQueryivANGLE;
  tbl.glIsQueryANGLE = http_glIsQueryANGLE;
  tbl.glQueryCounterANGLE = http_glQueryCounterANGLE;

  // GL_ANGLE_translated_shader_source

  tbl.glGetTranslatedShaderSourceANGLE = http_glGetTranslatedShaderSourceANGLE;

  // GL_APPLE_copy_texture_levels

  tbl.glCopyTextureLevelsAPPLE = http_glCopyTextureLevelsAPPLE;

  // GL_APPLE_element_array

  tbl.glDrawElementArrayAPPLE = http_glDrawElementArrayAPPLE;
  tbl.glDrawRangeElementArrayAPPLE = http_glDrawRangeElementArrayAPPLE;
  tbl.glElementPointerAPPLE = http_glElementPointerAPPLE;
  tbl.glMultiDrawElementArrayAPPLE = http_glMultiDrawElementArrayAPPLE;
  tbl.glMultiDrawRangeElementArrayAPPLE = http_glMultiDrawRangeElementArrayAPPLE;

  // GL_APPLE_fence

  tbl.glDeleteFencesAPPLE = http_glDeleteFencesAPPLE;
  tbl.glFinishFenceAPPLE = http_glFinishFenceAPPLE;
  tbl.glFinishObjectAPPLE = http_glFinishObjectAPPLE;
  tbl.glGenFencesAPPLE = http_glGenFencesAPPLE;
  tbl.glIsFenceAPPLE = http_glIsFenceAPPLE;
  tbl.glSetFenceAPPLE = http_glSetFenceAPPLE;
  tbl.glTestFenceAPPLE = http_glTestFenceAPPLE;
  tbl.glTestObjectAPPLE = http_glTestObjectAPPLE;

  // GL_APPLE_flush_buffer_range

  tbl.glBufferParameteriAPPLE = http_glBufferParameteriAPPLE;
  tbl.glFlushMappedBufferRangeAPPLE = http_glFlushMappedBufferRangeAPPLE;

  // GL_APPLE_flush_render

  tbl.glFinishRenderAPPLE = http_glFinishRenderAPPLE;
  tbl.glFlushRenderAPPLE = http_glFlushRenderAPPLE;
  tbl.glSwapAPPLE = http_glSwapAPPLE;

  // GL_APPLE_framebuffer_multisample

  tbl.glRenderbufferStorageMultisampleAPPLE = http_glRenderbufferStorageMultisampleAPPLE;
  tbl.glResolveMultisampleFramebufferAPPLE = http_glResolveMultisampleFramebufferAPPLE;

  // GL_APPLE_object_purgeable

  tbl.glGetObjectParameterivAPPLE = http_glGetObjectParameterivAPPLE;
  tbl.glObjectPurgeableAPPLE = http_glObjectPurgeableAPPLE;
  tbl.glObjectUnpurgeableAPPLE = http_glObjectUnpurgeableAPPLE;

  // GL_APPLE_sync

  tbl.glClientWaitSyncAPPLE = http_glClientWaitSyncAPPLE;
  tbl.glDeleteSyncAPPLE = http_glDeleteSyncAPPLE;
  tbl.glFenceSyncAPPLE = http_glFenceSyncAPPLE;
  tbl.glGetInteger64vAPPLE = http_glGetInteger64vAPPLE;
  tbl.glGetSyncivAPPLE = http_glGetSyncivAPPLE;
  tbl.glIsSyncAPPLE = http_glIsSyncAPPLE;
  tbl.glWaitSyncAPPLE = http_glWaitSyncAPPLE;

  // GL_APPLE_texture_range

  tbl.glGetTexParameterPointervAPPLE = http_glGetTexParameterPointervAPPLE;
  tbl.glTextureRangeAPPLE = http_glTextureRangeAPPLE;

  // GL_APPLE_vertex_array_object

  tbl.glBindVertexArrayAPPLE = http_glBindVertexArrayAPPLE;
  tbl.glDeleteVertexArraysAPPLE = http_glDeleteVertexArraysAPPLE;
  tbl.glGenVertexArraysAPPLE = http_glGenVertexArraysAPPLE;
  tbl.glIsVertexArrayAPPLE = http_glIsVertexArrayAPPLE;

  // GL_APPLE_vertex_array_range

  tbl.glFlushVertexArrayRangeAPPLE = http_glFlushVertexArrayRangeAPPLE;
  tbl.glVertexArrayParameteriAPPLE = http_glVertexArrayParameteriAPPLE;
  tbl.glVertexArrayRangeAPPLE = http_glVertexArrayRangeAPPLE;

  // GL_APPLE_vertex_program_evaluators

  tbl.glDisableVertexAttribAPPLE = http_glDisableVertexAttribAPPLE;
  tbl.glEnableVertexAttribAPPLE = http_glEnableVertexAttribAPPLE;
  tbl.glIsVertexAttribEnabledAPPLE = http_glIsVertexAttribEnabledAPPLE;
  tbl.glMapVertexAttrib1dAPPLE = http_glMapVertexAttrib1dAPPLE;
  tbl.glMapVertexAttrib1fAPPLE = http_glMapVertexAttrib1fAPPLE;
  tbl.glMapVertexAttrib2dAPPLE = http_glMapVertexAttrib2dAPPLE;
  tbl.glMapVertexAttrib2fAPPLE = http_glMapVertexAttrib2fAPPLE;

  // GL_ARB_ES2_compatibility

  tbl.glClearDepthf = http_glClearDepthf;
  tbl.glDepthRangef = http_glDepthRangef;
  tbl.glGetShaderPrecisionFormat = http_glGetShaderPrecisionFormat;
  tbl.glReleaseShaderCompiler = http_glReleaseShaderCompiler;
  tbl.glShaderBinary = http_glShaderBinary;

  // GL_ARB_ES3_1_compatibility

  tbl.glMemoryBarrierByRegion = http_glMemoryBarrierByRegion;

  // GL_ARB_base_instance

  tbl.glDrawArraysInstancedBaseInstance = http_glDrawArraysInstancedBaseInstance;
  tbl.glDrawElementsInstancedBaseInstance = http_glDrawElementsInstancedBaseInstance;
  tbl.glDrawElementsInstancedBaseVertexBaseInstance = http_glDrawElementsInstancedBaseVertexBaseInstance;

  // GL_ARB_bindless_texture

  tbl.glGetImageHandleARB = http_glGetImageHandleARB;
  tbl.glGetTextureHandleARB = http_glGetTextureHandleARB;
  tbl.glGetTextureSamplerHandleARB = http_glGetTextureSamplerHandleARB;
  tbl.glGetVertexAttribLui64vARB = http_glGetVertexAttribLui64vARB;
  tbl.glIsImageHandleResidentARB = http_glIsImageHandleResidentARB;
  tbl.glIsTextureHandleResidentARB = http_glIsTextureHandleResidentARB;
  tbl.glMakeImageHandleNonResidentARB = http_glMakeImageHandleNonResidentARB;
  tbl.glMakeImageHandleResidentARB = http_glMakeImageHandleResidentARB;
  tbl.glMakeTextureHandleNonResidentARB = http_glMakeTextureHandleNonResidentARB;
  tbl.glMakeTextureHandleResidentARB = http_glMakeTextureHandleResidentARB;
  tbl.glProgramUniformHandleui64ARB = http_glProgramUniformHandleui64ARB;
  tbl.glProgramUniformHandleui64vARB = http_glProgramUniformHandleui64vARB;
  tbl.glUniformHandleui64ARB = http_glUniformHandleui64ARB;
  tbl.glUniformHandleui64vARB = http_glUniformHandleui64vARB;
  tbl.glVertexAttribL1ui64ARB = http_glVertexAttribL1ui64ARB;
  tbl.glVertexAttribL1ui64vARB = http_glVertexAttribL1ui64vARB;

  // GL_ARB_blend_func_extended

  tbl.glBindFragDataLocationIndexed = http_glBindFragDataLocationIndexed;
  tbl.glGetFragDataIndex = http_glGetFragDataIndex;

  // GL_ARB_buffer_storage

  tbl.glBufferStorage = http_glBufferStorage;
  tbl.glNamedBufferStorageEXT = http_glNamedBufferStorageEXT;

  // GL_ARB_cl_event

  tbl.glCreateSyncFromCLeventARB = http_glCreateSyncFromCLeventARB;

  // GL_ARB_clear_buffer_object

  tbl.glClearBufferData = http_glClearBufferData;
  tbl.glClearBufferSubData = http_glClearBufferSubData;
  tbl.glClearNamedBufferDataEXT = http_glClearNamedBufferDataEXT;
  tbl.glClearNamedBufferSubDataEXT = http_glClearNamedBufferSubDataEXT;

  // GL_ARB_clear_texture

  tbl.glClearTexImage = http_glClearTexImage;
  tbl.glClearTexSubImage = http_glClearTexSubImage;

  // GL_ARB_clip_control

  tbl.glClipControl = http_glClipControl;

  // GL_ARB_color_buffer_float

  tbl.glClampColorARB = http_glClampColorARB;

  // GL_ARB_compute_shader

  tbl.glDispatchCompute = http_glDispatchCompute;
  tbl.glDispatchComputeIndirect = http_glDispatchComputeIndirect;

  // GL_ARB_compute_variable_group_size

  tbl.glDispatchComputeGroupSizeARB = http_glDispatchComputeGroupSizeARB;

  // GL_ARB_copy_buffer

  tbl.glCopyBufferSubData = http_glCopyBufferSubData;

  // GL_ARB_copy_image

  tbl.glCopyImageSubData = http_glCopyImageSubData;

  // GL_ARB_debug_output

  tbl.glDebugMessageCallbackARB = http_glDebugMessageCallbackARB;
  tbl.glDebugMessageControlARB = http_glDebugMessageControlARB;
  tbl.glDebugMessageInsertARB = http_glDebugMessageInsertARB;
  tbl.glGetDebugMessageLogARB = http_glGetDebugMessageLogARB;

  // GL_ARB_direct_state_access

  tbl.glBindTextureUnit = http_glBindTextureUnit;
  tbl.glBlitNamedFramebuffer = http_glBlitNamedFramebuffer;
  tbl.glCheckNamedFramebufferStatus = http_glCheckNamedFramebufferStatus;
  tbl.glClearNamedBufferData = http_glClearNamedBufferData;
  tbl.glClearNamedBufferSubData = http_glClearNamedBufferSubData;
  tbl.glClearNamedFramebufferfi = http_glClearNamedFramebufferfi;
  tbl.glClearNamedFramebufferfv = http_glClearNamedFramebufferfv;
  tbl.glClearNamedFramebufferiv = http_glClearNamedFramebufferiv;
  tbl.glClearNamedFramebufferuiv = http_glClearNamedFramebufferuiv;
  tbl.glCompressedTextureSubImage1D = http_glCompressedTextureSubImage1D;
  tbl.glCompressedTextureSubImage2D = http_glCompressedTextureSubImage2D;
  tbl.glCompressedTextureSubImage3D = http_glCompressedTextureSubImage3D;
  tbl.glCopyNamedBufferSubData = http_glCopyNamedBufferSubData;
  tbl.glCopyTextureSubImage1D = http_glCopyTextureSubImage1D;
  tbl.glCopyTextureSubImage2D = http_glCopyTextureSubImage2D;
  tbl.glCopyTextureSubImage3D = http_glCopyTextureSubImage3D;
  tbl.glCreateBuffers = http_glCreateBuffers;
  tbl.glCreateFramebuffers = http_glCreateFramebuffers;
  tbl.glCreateProgramPipelines = http_glCreateProgramPipelines;
  tbl.glCreateQueries = http_glCreateQueries;
  tbl.glCreateRenderbuffers = http_glCreateRenderbuffers;
  tbl.glCreateSamplers = http_glCreateSamplers;
  tbl.glCreateTextures = http_glCreateTextures;
  tbl.glCreateTransformFeedbacks = http_glCreateTransformFeedbacks;
  tbl.glCreateVertexArrays = http_glCreateVertexArrays;
  tbl.glDisableVertexArrayAttrib = http_glDisableVertexArrayAttrib;
  tbl.glEnableVertexArrayAttrib = http_glEnableVertexArrayAttrib;
  tbl.glFlushMappedNamedBufferRange = http_glFlushMappedNamedBufferRange;
  tbl.glGenerateTextureMipmap = http_glGenerateTextureMipmap;
  tbl.glGetCompressedTextureImage = http_glGetCompressedTextureImage;
  tbl.glGetNamedBufferParameteri64v = http_glGetNamedBufferParameteri64v;
  tbl.glGetNamedBufferParameteriv = http_glGetNamedBufferParameteriv;
  tbl.glGetNamedBufferPointerv = http_glGetNamedBufferPointerv;
  tbl.glGetNamedBufferSubData = http_glGetNamedBufferSubData;
  tbl.glGetNamedFramebufferAttachmentParameteriv = http_glGetNamedFramebufferAttachmentParameteriv;
  tbl.glGetNamedFramebufferParameteriv = http_glGetNamedFramebufferParameteriv;
  tbl.glGetNamedRenderbufferParameteriv = http_glGetNamedRenderbufferParameteriv;
  tbl.glGetTextureImage = http_glGetTextureImage;
  tbl.glGetTextureLevelParameterfv = http_glGetTextureLevelParameterfv;
  tbl.glGetTextureLevelParameteriv = http_glGetTextureLevelParameteriv;
  tbl.glGetTextureParameterIiv = http_glGetTextureParameterIiv;
  tbl.glGetTextureParameterIuiv = http_glGetTextureParameterIuiv;
  tbl.glGetTextureParameterfv = http_glGetTextureParameterfv;
  tbl.glGetTextureParameteriv = http_glGetTextureParameteriv;
  tbl.glGetTransformFeedbacki64_v = http_glGetTransformFeedbacki64_v;
  tbl.glGetTransformFeedbacki_v = http_glGetTransformFeedbacki_v;
  tbl.glGetTransformFeedbackiv = http_glGetTransformFeedbackiv;
  tbl.glGetVertexArrayIndexed64iv = http_glGetVertexArrayIndexed64iv;
  tbl.glGetVertexArrayIndexediv = http_glGetVertexArrayIndexediv;
  tbl.glGetVertexArrayiv = http_glGetVertexArrayiv;
  tbl.glInvalidateNamedFramebufferData = http_glInvalidateNamedFramebufferData;
  tbl.glInvalidateNamedFramebufferSubData = http_glInvalidateNamedFramebufferSubData;
  tbl.glMapNamedBuffer = http_glMapNamedBuffer;
  tbl.glMapNamedBufferRange = http_glMapNamedBufferRange;
  tbl.glNamedBufferData = http_glNamedBufferData;
  tbl.glNamedBufferStorage = http_glNamedBufferStorage;
  tbl.glNamedBufferSubData = http_glNamedBufferSubData;
  tbl.glNamedFramebufferDrawBuffer = http_glNamedFramebufferDrawBuffer;
  tbl.glNamedFramebufferDrawBuffers = http_glNamedFramebufferDrawBuffers;
  tbl.glNamedFramebufferParameteri = http_glNamedFramebufferParameteri;
  tbl.glNamedFramebufferReadBuffer = http_glNamedFramebufferReadBuffer;
  tbl.glNamedFramebufferRenderbuffer = http_glNamedFramebufferRenderbuffer;
  tbl.glNamedFramebufferTexture = http_glNamedFramebufferTexture;
  tbl.glNamedFramebufferTextureLayer = http_glNamedFramebufferTextureLayer;
  tbl.glNamedRenderbufferStorage = http_glNamedRenderbufferStorage;
  tbl.glNamedRenderbufferStorageMultisample = http_glNamedRenderbufferStorageMultisample;
  tbl.glTextureBuffer = http_glTextureBuffer;
  tbl.glTextureBufferRange = http_glTextureBufferRange;
  tbl.glTextureParameterIiv = http_glTextureParameterIiv;
  tbl.glTextureParameterIuiv = http_glTextureParameterIuiv;
  tbl.glTextureParameterf = http_glTextureParameterf;
  tbl.glTextureParameterfv = http_glTextureParameterfv;
  tbl.glTextureParameteri = http_glTextureParameteri;
  tbl.glTextureParameteriv = http_glTextureParameteriv;
  tbl.glTextureStorage1D = http_glTextureStorage1D;
  tbl.glTextureStorage2D = http_glTextureStorage2D;
  tbl.glTextureStorage2DMultisample = http_glTextureStorage2DMultisample;
  tbl.glTextureStorage3D = http_glTextureStorage3D;
  tbl.glTextureStorage3DMultisample = http_glTextureStorage3DMultisample;
  tbl.glTextureSubImage1D = http_glTextureSubImage1D;
  tbl.glTextureSubImage2D = http_glTextureSubImage2D;
  tbl.glTextureSubImage3D = http_glTextureSubImage3D;
  tbl.glTransformFeedbackBufferBase = http_glTransformFeedbackBufferBase;
  tbl.glTransformFeedbackBufferRange = http_glTransformFeedbackBufferRange;
  tbl.glUnmapNamedBuffer = http_glUnmapNamedBuffer;
  tbl.glVertexArrayAttribBinding = http_glVertexArrayAttribBinding;
  tbl.glVertexArrayAttribFormat = http_glVertexArrayAttribFormat;
  tbl.glVertexArrayAttribIFormat = http_glVertexArrayAttribIFormat;
  tbl.glVertexArrayAttribLFormat = http_glVertexArrayAttribLFormat;
  tbl.glVertexArrayBindingDivisor = http_glVertexArrayBindingDivisor;
  tbl.glVertexArrayElementBuffer = http_glVertexArrayElementBuffer;
  tbl.glVertexArrayVertexBuffer = http_glVertexArrayVertexBuffer;
  tbl.glVertexArrayVertexBuffers = http_glVertexArrayVertexBuffers;

  // GL_ARB_draw_buffers

  tbl.glDrawBuffersARB = http_glDrawBuffersARB;

  // GL_ARB_draw_buffers_blend

  tbl.glBlendEquationSeparateiARB = http_glBlendEquationSeparateiARB;
  tbl.glBlendEquationiARB = http_glBlendEquationiARB;
  tbl.glBlendFuncSeparateiARB = http_glBlendFuncSeparateiARB;
  tbl.glBlendFunciARB = http_glBlendFunciARB;

  // GL_ARB_draw_elements_base_vertex

  tbl.glDrawElementsBaseVertex = http_glDrawElementsBaseVertex;
  tbl.glDrawElementsInstancedBaseVertex = http_glDrawElementsInstancedBaseVertex;
  tbl.glDrawRangeElementsBaseVertex = http_glDrawRangeElementsBaseVertex;
  tbl.glMultiDrawElementsBaseVertex = http_glMultiDrawElementsBaseVertex;

  // GL_ARB_draw_indirect

  tbl.glDrawArraysIndirect = http_glDrawArraysIndirect;
  tbl.glDrawElementsIndirect = http_glDrawElementsIndirect;

  // GL_ARB_draw_instanced

  tbl.glDrawArraysInstancedARB = http_glDrawArraysInstancedARB;
  tbl.glDrawElementsInstancedARB = http_glDrawElementsInstancedARB;

  // GL_ARB_framebuffer_no_attachments

  tbl.glFramebufferParameteri = http_glFramebufferParameteri;
  tbl.glGetFramebufferParameteriv = http_glGetFramebufferParameteriv;
  tbl.glGetNamedFramebufferParameterivEXT = http_glGetNamedFramebufferParameterivEXT;
  tbl.glNamedFramebufferParameteriEXT = http_glNamedFramebufferParameteriEXT;

  // GL_ARB_framebuffer_object

  tbl.glBindFramebuffer = http_glBindFramebuffer;
  tbl.glBindRenderbuffer = http_glBindRenderbuffer;
  tbl.glBlitFramebuffer = http_glBlitFramebuffer;
  tbl.glCheckFramebufferStatus = http_glCheckFramebufferStatus;
  tbl.glDeleteFramebuffers = http_glDeleteFramebuffers;
  tbl.glDeleteRenderbuffers = http_glDeleteRenderbuffers;
  tbl.glFramebufferRenderbuffer = http_glFramebufferRenderbuffer;
  tbl.glFramebufferTexture1D = http_glFramebufferTexture1D;
  tbl.glFramebufferTexture2D = http_glFramebufferTexture2D;
  tbl.glFramebufferTexture3D = http_glFramebufferTexture3D;
  tbl.glFramebufferTextureLayer = http_glFramebufferTextureLayer;
  tbl.glGenFramebuffers = http_glGenFramebuffers;
  tbl.glGenRenderbuffers = http_glGenRenderbuffers;
  tbl.glGenerateMipmap = http_glGenerateMipmap;
  tbl.glGetFramebufferAttachmentParameteriv = http_glGetFramebufferAttachmentParameteriv;
  tbl.glGetRenderbufferParameteriv = http_glGetRenderbufferParameteriv;
  tbl.glIsFramebuffer = http_glIsFramebuffer;
  tbl.glIsRenderbuffer = http_glIsRenderbuffer;
  tbl.glRenderbufferStorage = http_glRenderbufferStorage;
  tbl.glRenderbufferStorageMultisample = http_glRenderbufferStorageMultisample;

  // GL_ARB_geometry_shader4

  tbl.glFramebufferTextureARB = http_glFramebufferTextureARB;
  tbl.glFramebufferTextureFaceARB = http_glFramebufferTextureFaceARB;
  tbl.glFramebufferTextureLayerARB = http_glFramebufferTextureLayerARB;
  tbl.glProgramParameteriARB = http_glProgramParameteriARB;

  // GL_ARB_get_program_binary

  tbl.glGetProgramBinary = http_glGetProgramBinary;
  tbl.glProgramBinary = http_glProgramBinary;
  tbl.glProgramParameteri = http_glProgramParameteri;

  // GL_ARB_get_texture_sub_image

  tbl.glGetCompressedTextureSubImage = http_glGetCompressedTextureSubImage;
  tbl.glGetTextureSubImage = http_glGetTextureSubImage;

  // GL_ARB_gpu_shader_fp64

  tbl.glGetUniformdv = http_glGetUniformdv;
  tbl.glUniform1d = http_glUniform1d;
  tbl.glUniform1dv = http_glUniform1dv;
  tbl.glUniform2d = http_glUniform2d;
  tbl.glUniform2dv = http_glUniform2dv;
  tbl.glUniform3d = http_glUniform3d;
  tbl.glUniform3dv = http_glUniform3dv;
  tbl.glUniform4d = http_glUniform4d;
  tbl.glUniform4dv = http_glUniform4dv;
  tbl.glUniformMatrix2dv = http_glUniformMatrix2dv;
  tbl.glUniformMatrix2x3dv = http_glUniformMatrix2x3dv;
  tbl.glUniformMatrix2x4dv = http_glUniformMatrix2x4dv;
  tbl.glUniformMatrix3dv = http_glUniformMatrix3dv;
  tbl.glUniformMatrix3x2dv = http_glUniformMatrix3x2dv;
  tbl.glUniformMatrix3x4dv = http_glUniformMatrix3x4dv;
  tbl.glUniformMatrix4dv = http_glUniformMatrix4dv;
  tbl.glUniformMatrix4x2dv = http_glUniformMatrix4x2dv;
  tbl.glUniformMatrix4x3dv = http_glUniformMatrix4x3dv;

  // GL_ARB_imaging

  tbl.glColorSubTable = http_glColorSubTable;
  tbl.glColorTable = http_glColorTable;
  tbl.glColorTableParameterfv = http_glColorTableParameterfv;
  tbl.glColorTableParameteriv = http_glColorTableParameteriv;
  tbl.glConvolutionFilter1D = http_glConvolutionFilter1D;
  tbl.glConvolutionFilter2D = http_glConvolutionFilter2D;
  tbl.glConvolutionParameterf = http_glConvolutionParameterf;
  tbl.glConvolutionParameterfv = http_glConvolutionParameterfv;
  tbl.glConvolutionParameteri = http_glConvolutionParameteri;
  tbl.glConvolutionParameteriv = http_glConvolutionParameteriv;
  tbl.glCopyColorSubTable = http_glCopyColorSubTable;
  tbl.glCopyColorTable = http_glCopyColorTable;
  tbl.glCopyConvolutionFilter1D = http_glCopyConvolutionFilter1D;
  tbl.glCopyConvolutionFilter2D = http_glCopyConvolutionFilter2D;
  tbl.glGetColorTable = http_glGetColorTable;
  tbl.glGetColorTableParameterfv = http_glGetColorTableParameterfv;
  tbl.glGetColorTableParameteriv = http_glGetColorTableParameteriv;
  tbl.glGetConvolutionFilter = http_glGetConvolutionFilter;
  tbl.glGetConvolutionParameterfv = http_glGetConvolutionParameterfv;
  tbl.glGetConvolutionParameteriv = http_glGetConvolutionParameteriv;
  tbl.glGetHistogram = http_glGetHistogram;
  tbl.glGetHistogramParameterfv = http_glGetHistogramParameterfv;
  tbl.glGetHistogramParameteriv = http_glGetHistogramParameteriv;
  tbl.glGetMinmax = http_glGetMinmax;
  tbl.glGetMinmaxParameterfv = http_glGetMinmaxParameterfv;
  tbl.glGetMinmaxParameteriv = http_glGetMinmaxParameteriv;
  tbl.glGetSeparableFilter = http_glGetSeparableFilter;
  tbl.glHistogram = http_glHistogram;
  tbl.glMinmax = http_glMinmax;
  tbl.glResetHistogram = http_glResetHistogram;
  tbl.glResetMinmax = http_glResetMinmax;
  tbl.glSeparableFilter2D = http_glSeparableFilter2D;

  // GL_ARB_indirect_parameters

  tbl.glMultiDrawArraysIndirectCountARB = http_glMultiDrawArraysIndirectCountARB;
  tbl.glMultiDrawElementsIndirectCountARB = http_glMultiDrawElementsIndirectCountARB;

  // GL_ARB_instanced_arrays

  tbl.glVertexAttribDivisorARB = http_glVertexAttribDivisorARB;

  // GL_ARB_internalformat_query

  tbl.glGetInternalformativ = http_glGetInternalformativ;

  // GL_ARB_internalformat_query2

  tbl.glGetInternalformati64v = http_glGetInternalformati64v;

  // GL_ARB_invalidate_subdata

  tbl.glInvalidateBufferData = http_glInvalidateBufferData;
  tbl.glInvalidateBufferSubData = http_glInvalidateBufferSubData;
  tbl.glInvalidateFramebuffer = http_glInvalidateFramebuffer;
  tbl.glInvalidateSubFramebuffer = http_glInvalidateSubFramebuffer;
  tbl.glInvalidateTexImage = http_glInvalidateTexImage;
  tbl.glInvalidateTexSubImage = http_glInvalidateTexSubImage;

  // GL_ARB_map_buffer_range

  tbl.glFlushMappedBufferRange = http_glFlushMappedBufferRange;
  tbl.glMapBufferRange = http_glMapBufferRange;

  // GL_ARB_matrix_palette

  tbl.glCurrentPaletteMatrixARB = http_glCurrentPaletteMatrixARB;
  tbl.glMatrixIndexPointerARB = http_glMatrixIndexPointerARB;
  tbl.glMatrixIndexubvARB = http_glMatrixIndexubvARB;
  tbl.glMatrixIndexuivARB = http_glMatrixIndexuivARB;
  tbl.glMatrixIndexusvARB = http_glMatrixIndexusvARB;

  // GL_ARB_multi_bind

  tbl.glBindBuffersBase = http_glBindBuffersBase;
  tbl.glBindBuffersRange = http_glBindBuffersRange;
  tbl.glBindImageTextures = http_glBindImageTextures;
  tbl.glBindSamplers = http_glBindSamplers;
  tbl.glBindTextures = http_glBindTextures;
  tbl.glBindVertexBuffers = http_glBindVertexBuffers;

  // GL_ARB_multi_draw_indirect

  tbl.glMultiDrawArraysIndirect = http_glMultiDrawArraysIndirect;
  tbl.glMultiDrawElementsIndirect = http_glMultiDrawElementsIndirect;

  // GL_ARB_multisample

  tbl.glSampleCoverageARB = http_glSampleCoverageARB;

  // GL_ARB_multitexture

  tbl.glActiveTextureARB = http_glActiveTextureARB;
  tbl.glClientActiveTextureARB = http_glClientActiveTextureARB;
  tbl.glMultiTexCoord1dARB = http_glMultiTexCoord1dARB;
  tbl.glMultiTexCoord1dvARB = http_glMultiTexCoord1dvARB;
  tbl.glMultiTexCoord1fARB = http_glMultiTexCoord1fARB;
  tbl.glMultiTexCoord1fvARB = http_glMultiTexCoord1fvARB;
  tbl.glMultiTexCoord1iARB = http_glMultiTexCoord1iARB;
  tbl.glMultiTexCoord1ivARB = http_glMultiTexCoord1ivARB;
  tbl.glMultiTexCoord1sARB = http_glMultiTexCoord1sARB;
  tbl.glMultiTexCoord1svARB = http_glMultiTexCoord1svARB;
  tbl.glMultiTexCoord2dARB = http_glMultiTexCoord2dARB;
  tbl.glMultiTexCoord2dvARB = http_glMultiTexCoord2dvARB;
  tbl.glMultiTexCoord2fARB = http_glMultiTexCoord2fARB;
  tbl.glMultiTexCoord2fvARB = http_glMultiTexCoord2fvARB;
  tbl.glMultiTexCoord2iARB = http_glMultiTexCoord2iARB;
  tbl.glMultiTexCoord2ivARB = http_glMultiTexCoord2ivARB;
  tbl.glMultiTexCoord2sARB = http_glMultiTexCoord2sARB;
  tbl.glMultiTexCoord2svARB = http_glMultiTexCoord2svARB;
  tbl.glMultiTexCoord3dARB = http_glMultiTexCoord3dARB;
  tbl.glMultiTexCoord3dvARB = http_glMultiTexCoord3dvARB;
  tbl.glMultiTexCoord3fARB = http_glMultiTexCoord3fARB;
  tbl.glMultiTexCoord3fvARB = http_glMultiTexCoord3fvARB;
  tbl.glMultiTexCoord3iARB = http_glMultiTexCoord3iARB;
  tbl.glMultiTexCoord3ivARB = http_glMultiTexCoord3ivARB;
  tbl.glMultiTexCoord3sARB = http_glMultiTexCoord3sARB;
  tbl.glMultiTexCoord3svARB = http_glMultiTexCoord3svARB;
  tbl.glMultiTexCoord4dARB = http_glMultiTexCoord4dARB;
  tbl.glMultiTexCoord4dvARB = http_glMultiTexCoord4dvARB;
  tbl.glMultiTexCoord4fARB = http_glMultiTexCoord4fARB;
  tbl.glMultiTexCoord4fvARB = http_glMultiTexCoord4fvARB;
  tbl.glMultiTexCoord4iARB = http_glMultiTexCoord4iARB;
  tbl.glMultiTexCoord4ivARB = http_glMultiTexCoord4ivARB;
  tbl.glMultiTexCoord4sARB = http_glMultiTexCoord4sARB;
  tbl.glMultiTexCoord4svARB = http_glMultiTexCoord4svARB;

  // GL_ARB_occlusion_query

  tbl.glBeginQueryARB = http_glBeginQueryARB;
  tbl.glDeleteQueriesARB = http_glDeleteQueriesARB;
  tbl.glEndQueryARB = http_glEndQueryARB;
  tbl.glGenQueriesARB = http_glGenQueriesARB;
  tbl.glGetQueryObjectivARB = http_glGetQueryObjectivARB;
  tbl.glGetQueryObjectuivARB = http_glGetQueryObjectuivARB;
  tbl.glGetQueryivARB = http_glGetQueryivARB;
  tbl.glIsQueryARB = http_glIsQueryARB;

  // GL_ARB_point_parameters

  tbl.glPointParameterfARB = http_glPointParameterfARB;
  tbl.glPointParameterfvARB = http_glPointParameterfvARB;

  // GL_ARB_program_interface_query

  tbl.glGetProgramInterfaceiv = http_glGetProgramInterfaceiv;
  tbl.glGetProgramResourceIndex = http_glGetProgramResourceIndex;
  tbl.glGetProgramResourceLocation = http_glGetProgramResourceLocation;
  tbl.glGetProgramResourceLocationIndex = http_glGetProgramResourceLocationIndex;
  tbl.glGetProgramResourceName = http_glGetProgramResourceName;
  tbl.glGetProgramResourceiv = http_glGetProgramResourceiv;

  // GL_ARB_provoking_vertex

  tbl.glProvokingVertex = http_glProvokingVertex;

  // GL_ARB_robustness

  tbl.glGetGraphicsResetStatusARB = http_glGetGraphicsResetStatusARB;
  tbl.glGetnColorTableARB = http_glGetnColorTableARB;
  tbl.glGetnCompressedTexImageARB = http_glGetnCompressedTexImageARB;
  tbl.glGetnConvolutionFilterARB = http_glGetnConvolutionFilterARB;
  tbl.glGetnHistogramARB = http_glGetnHistogramARB;
  tbl.glGetnMapdvARB = http_glGetnMapdvARB;
  tbl.glGetnMapfvARB = http_glGetnMapfvARB;
  tbl.glGetnMapivARB = http_glGetnMapivARB;
  tbl.glGetnMinmaxARB = http_glGetnMinmaxARB;
  tbl.glGetnPixelMapfvARB = http_glGetnPixelMapfvARB;
  tbl.glGetnPixelMapuivARB = http_glGetnPixelMapuivARB;
  tbl.glGetnPixelMapusvARB = http_glGetnPixelMapusvARB;
  tbl.glGetnPolygonStippleARB = http_glGetnPolygonStippleARB;
  tbl.glGetnSeparableFilterARB = http_glGetnSeparableFilterARB;
  tbl.glGetnTexImageARB = http_glGetnTexImageARB;
  tbl.glGetnUniformdvARB = http_glGetnUniformdvARB;
  tbl.glGetnUniformfvARB = http_glGetnUniformfvARB;
  tbl.glGetnUniformivARB = http_glGetnUniformivARB;
  tbl.glGetnUniformuivARB = http_glGetnUniformuivARB;
  tbl.glReadnPixelsARB = http_glReadnPixelsARB;

  // GL_ARB_sample_shading

  tbl.glMinSampleShading = http_glMinSampleShading;
  tbl.glMinSampleShadingARB = http_glMinSampleShadingARB;

  // GL_ARB_sampler_objects

  tbl.glBindSampler = http_glBindSampler;
  tbl.glDeleteSamplers = http_glDeleteSamplers;
  tbl.glGenSamplers = http_glGenSamplers;
  tbl.glGetSamplerParameterIiv = http_glGetSamplerParameterIiv;
  tbl.glGetSamplerParameterIuiv = http_glGetSamplerParameterIuiv;
  tbl.glGetSamplerParameterfv = http_glGetSamplerParameterfv;
  tbl.glGetSamplerParameteriv = http_glGetSamplerParameteriv;
  tbl.glIsSampler = http_glIsSampler;
  tbl.glSamplerParameterIiv = http_glSamplerParameterIiv;
  tbl.glSamplerParameterIuiv = http_glSamplerParameterIuiv;
  tbl.glSamplerParameterf = http_glSamplerParameterf;
  tbl.glSamplerParameterfv = http_glSamplerParameterfv;
  tbl.glSamplerParameteri = http_glSamplerParameteri;
  tbl.glSamplerParameteriv = http_glSamplerParameteriv;

  // GL_ARB_separate_shader_objects

  tbl.glActiveShaderProgram = http_glActiveShaderProgram;
  tbl.glBindProgramPipeline = http_glBindProgramPipeline;
  tbl.glCreateShaderProgramv = http_glCreateShaderProgramv;
  tbl.glDeleteProgramPipelines = http_glDeleteProgramPipelines;
  tbl.glGenProgramPipelines = http_glGenProgramPipelines;
  tbl.glGetProgramPipelineInfoLog = http_glGetProgramPipelineInfoLog;
  tbl.glGetProgramPipelineiv = http_glGetProgramPipelineiv;
  tbl.glIsProgramPipeline = http_glIsProgramPipeline;
  tbl.glProgramUniform1d = http_glProgramUniform1d;
  tbl.glProgramUniform1dv = http_glProgramUniform1dv;
  tbl.glProgramUniform1f = http_glProgramUniform1f;
  tbl.glProgramUniform1fv = http_glProgramUniform1fv;
  tbl.glProgramUniform1i = http_glProgramUniform1i;
  tbl.glProgramUniform1iv = http_glProgramUniform1iv;
  tbl.glProgramUniform1ui = http_glProgramUniform1ui;
  tbl.glProgramUniform1uiv = http_glProgramUniform1uiv;
  tbl.glProgramUniform2d = http_glProgramUniform2d;
  tbl.glProgramUniform2dv = http_glProgramUniform2dv;
  tbl.glProgramUniform2f = http_glProgramUniform2f;
  tbl.glProgramUniform2fv = http_glProgramUniform2fv;
  tbl.glProgramUniform2i = http_glProgramUniform2i;
  tbl.glProgramUniform2iv = http_glProgramUniform2iv;
  tbl.glProgramUniform2ui = http_glProgramUniform2ui;
  tbl.glProgramUniform2uiv = http_glProgramUniform2uiv;
  tbl.glProgramUniform3d = http_glProgramUniform3d;
  tbl.glProgramUniform3dv = http_glProgramUniform3dv;
  tbl.glProgramUniform3f = http_glProgramUniform3f;
  tbl.glProgramUniform3fv = http_glProgramUniform3fv;
  tbl.glProgramUniform3i = http_glProgramUniform3i;
  tbl.glProgramUniform3iv = http_glProgramUniform3iv;
  tbl.glProgramUniform3ui = http_glProgramUniform3ui;
  tbl.glProgramUniform3uiv = http_glProgramUniform3uiv;
  tbl.glProgramUniform4d = http_glProgramUniform4d;
  tbl.glProgramUniform4dv = http_glProgramUniform4dv;
  tbl.glProgramUniform4f = http_glProgramUniform4f;
  tbl.glProgramUniform4fv = http_glProgramUniform4fv;
  tbl.glProgramUniform4i = http_glProgramUniform4i;
  tbl.glProgramUniform4iv = http_glProgramUniform4iv;
  tbl.glProgramUniform4ui = http_glProgramUniform4ui;
  tbl.glProgramUniform4uiv = http_glProgramUniform4uiv;
  tbl.glProgramUniformMatrix2dv = http_glProgramUniformMatrix2dv;
  tbl.glProgramUniformMatrix2fv = http_glProgramUniformMatrix2fv;
  tbl.glProgramUniformMatrix2x3dv = http_glProgramUniformMatrix2x3dv;
  tbl.glProgramUniformMatrix2x3fv = http_glProgramUniformMatrix2x3fv;
  tbl.glProgramUniformMatrix2x4dv = http_glProgramUniformMatrix2x4dv;
  tbl.glProgramUniformMatrix2x4fv = http_glProgramUniformMatrix2x4fv;
  tbl.glProgramUniformMatrix3dv = http_glProgramUniformMatrix3dv;
  tbl.glProgramUniformMatrix3fv = http_glProgramUniformMatrix3fv;
  tbl.glProgramUniformMatrix3x2dv = http_glProgramUniformMatrix3x2dv;
  tbl.glProgramUniformMatrix3x2fv = http_glProgramUniformMatrix3x2fv;
  tbl.glProgramUniformMatrix3x4dv = http_glProgramUniformMatrix3x4dv;
  tbl.glProgramUniformMatrix3x4fv = http_glProgramUniformMatrix3x4fv;
  tbl.glProgramUniformMatrix4dv = http_glProgramUniformMatrix4dv;
  tbl.glProgramUniformMatrix4fv = http_glProgramUniformMatrix4fv;
  tbl.glProgramUniformMatrix4x2dv = http_glProgramUniformMatrix4x2dv;
  tbl.glProgramUniformMatrix4x2fv = http_glProgramUniformMatrix4x2fv;
  tbl.glProgramUniformMatrix4x3dv = http_glProgramUniformMatrix4x3dv;
  tbl.glProgramUniformMatrix4x3fv = http_glProgramUniformMatrix4x3fv;
  tbl.glUseProgramStages = http_glUseProgramStages;
  tbl.glValidateProgramPipeline = http_glValidateProgramPipeline;

  // GL_ARB_shader_atomic_counters

  tbl.glGetActiveAtomicCounterBufferiv = http_glGetActiveAtomicCounterBufferiv;

  // GL_ARB_shader_image_load_store

  tbl.glBindImageTexture = http_glBindImageTexture;
  tbl.glMemoryBarrier = http_glMemoryBarrier;

  // GL_ARB_shader_objects

  tbl.glAttachObjectARB = http_glAttachObjectARB;
  tbl.glCompileShaderARB = http_glCompileShaderARB;
  tbl.glCreateProgramObjectARB = http_glCreateProgramObjectARB;
  tbl.glCreateShaderObjectARB = http_glCreateShaderObjectARB;
  tbl.glDeleteObjectARB = http_glDeleteObjectARB;
  tbl.glDetachObjectARB = http_glDetachObjectARB;
  tbl.glGetActiveUniformARB = http_glGetActiveUniformARB;
  tbl.glGetAttachedObjectsARB = http_glGetAttachedObjectsARB;
  tbl.glGetHandleARB = http_glGetHandleARB;
  tbl.glGetInfoLogARB = http_glGetInfoLogARB;
  tbl.glGetObjectParameterfvARB = http_glGetObjectParameterfvARB;
  tbl.glGetObjectParameterivARB = http_glGetObjectParameterivARB;
  tbl.glGetShaderSourceARB = http_glGetShaderSourceARB;
  tbl.glGetUniformLocationARB = http_glGetUniformLocationARB;
  tbl.glGetUniformfvARB = http_glGetUniformfvARB;
  tbl.glGetUniformivARB = http_glGetUniformivARB;
  tbl.glLinkProgramARB = http_glLinkProgramARB;
  tbl.glShaderSourceARB = http_glShaderSourceARB;
  tbl.glUniform1fARB = http_glUniform1fARB;
  tbl.glUniform1fvARB = http_glUniform1fvARB;
  tbl.glUniform1iARB = http_glUniform1iARB;
  tbl.glUniform1ivARB = http_glUniform1ivARB;
  tbl.glUniform2fARB = http_glUniform2fARB;
  tbl.glUniform2fvARB = http_glUniform2fvARB;
  tbl.glUniform2iARB = http_glUniform2iARB;
  tbl.glUniform2ivARB = http_glUniform2ivARB;
  tbl.glUniform3fARB = http_glUniform3fARB;
  tbl.glUniform3fvARB = http_glUniform3fvARB;
  tbl.glUniform3iARB = http_glUniform3iARB;
  tbl.glUniform3ivARB = http_glUniform3ivARB;
  tbl.glUniform4fARB = http_glUniform4fARB;
  tbl.glUniform4fvARB = http_glUniform4fvARB;
  tbl.glUniform4iARB = http_glUniform4iARB;
  tbl.glUniform4ivARB = http_glUniform4ivARB;
  tbl.glUniformMatrix2fvARB = http_glUniformMatrix2fvARB;
  tbl.glUniformMatrix3fvARB = http_glUniformMatrix3fvARB;
  tbl.glUniformMatrix4fvARB = http_glUniformMatrix4fvARB;
  tbl.glUseProgramObjectARB = http_glUseProgramObjectARB;
  tbl.glValidateProgramARB = http_glValidateProgramARB;

  // GL_ARB_shader_storage_buffer_object

  tbl.glShaderStorageBlockBinding = http_glShaderStorageBlockBinding;

  // GL_ARB_shader_subroutine

  tbl.glGetActiveSubroutineName = http_glGetActiveSubroutineName;
  tbl.glGetActiveSubroutineUniformName = http_glGetActiveSubroutineUniformName;
  tbl.glGetActiveSubroutineUniformiv = http_glGetActiveSubroutineUniformiv;
  tbl.glGetProgramStageiv = http_glGetProgramStageiv;
  tbl.glGetProgramSubroutineParameteruivNV = http_glGetProgramSubroutineParameteruivNV;
  tbl.glGetSubroutineIndex = http_glGetSubroutineIndex;
  tbl.glGetSubroutineUniformLocation = http_glGetSubroutineUniformLocation;
  tbl.glGetUniformSubroutineuiv = http_glGetUniformSubroutineuiv;
  tbl.glProgramSubroutineParametersuivNV = http_glProgramSubroutineParametersuivNV;
  tbl.glUniformSubroutinesuiv = http_glUniformSubroutinesuiv;

  // GL_ARB_shading_language_include

  tbl.glCompileShaderIncludeARB = http_glCompileShaderIncludeARB;
  tbl.glDeleteNamedStringARB = http_glDeleteNamedStringARB;
  tbl.glGetNamedStringARB = http_glGetNamedStringARB;
  tbl.glGetNamedStringivARB = http_glGetNamedStringivARB;
  tbl.glIsNamedStringARB = http_glIsNamedStringARB;
  tbl.glNamedStringARB = http_glNamedStringARB;

  // GL_ARB_sparse_buffer

  tbl.glBufferPageCommitmentARB = http_glBufferPageCommitmentARB;

  // GL_ARB_sparse_texture

  tbl.glTexPageCommitmentARB = http_glTexPageCommitmentARB;
  tbl.glTexturePageCommitmentEXT = http_glTexturePageCommitmentEXT;

  // GL_ARB_sync

  tbl.glClientWaitSync = http_glClientWaitSync;
  tbl.glDeleteSync = http_glDeleteSync;
  tbl.glFenceSync = http_glFenceSync;
  tbl.glGetInteger64v = http_glGetInteger64v;
  tbl.glGetSynciv = http_glGetSynciv;
  tbl.glIsSync = http_glIsSync;
  tbl.glWaitSync = http_glWaitSync;

  // GL_ARB_tessellation_shader

  tbl.glPatchParameterfv = http_glPatchParameterfv;
  tbl.glPatchParameteri = http_glPatchParameteri;

  // GL_ARB_texture_barrier

  tbl.glTextureBarrier = http_glTextureBarrier;

  // GL_ARB_texture_buffer_object

  tbl.glTexBufferARB = http_glTexBufferARB;

  // GL_ARB_texture_buffer_range

  tbl.glTexBufferRange = http_glTexBufferRange;
  tbl.glTextureBufferRangeEXT = http_glTextureBufferRangeEXT;

  // GL_ARB_texture_compression

  tbl.glCompressedTexImage1DARB = http_glCompressedTexImage1DARB;
  tbl.glCompressedTexImage2DARB = http_glCompressedTexImage2DARB;
  tbl.glCompressedTexImage3DARB = http_glCompressedTexImage3DARB;
  tbl.glCompressedTexSubImage1DARB = http_glCompressedTexSubImage1DARB;
  tbl.glCompressedTexSubImage2DARB = http_glCompressedTexSubImage2DARB;
  tbl.glCompressedTexSubImage3DARB = http_glCompressedTexSubImage3DARB;
  tbl.glGetCompressedTexImageARB = http_glGetCompressedTexImageARB;

  // GL_ARB_texture_multisample

  tbl.glGetMultisamplefv = http_glGetMultisamplefv;
  tbl.glSampleMaski = http_glSampleMaski;
  tbl.glTexImage2DMultisample = http_glTexImage2DMultisample;
  tbl.glTexImage3DMultisample = http_glTexImage3DMultisample;

  // GL_ARB_texture_storage

  tbl.glTexStorage1D = http_glTexStorage1D;
  tbl.glTexStorage2D = http_glTexStorage2D;
  tbl.glTexStorage3D = http_glTexStorage3D;
  tbl.glTextureStorage1DEXT = http_glTextureStorage1DEXT;
  tbl.glTextureStorage2DEXT = http_glTextureStorage2DEXT;
  tbl.glTextureStorage3DEXT = http_glTextureStorage3DEXT;

  // GL_ARB_texture_storage_multisample

  tbl.glTexStorage2DMultisample = http_glTexStorage2DMultisample;
  tbl.glTexStorage3DMultisample = http_glTexStorage3DMultisample;
  tbl.glTextureStorage2DMultisampleEXT = http_glTextureStorage2DMultisampleEXT;
  tbl.glTextureStorage3DMultisampleEXT = http_glTextureStorage3DMultisampleEXT;

  // GL_ARB_texture_view

  tbl.glTextureView = http_glTextureView;

  // GL_ARB_timer_query

  tbl.glGetQueryObjecti64v = http_glGetQueryObjecti64v;
  tbl.glGetQueryObjectui64v = http_glGetQueryObjectui64v;
  tbl.glQueryCounter = http_glQueryCounter;

  // GL_ARB_transform_feedback2

  tbl.glBindTransformFeedback = http_glBindTransformFeedback;
  tbl.glDeleteTransformFeedbacks = http_glDeleteTransformFeedbacks;
  tbl.glDrawTransformFeedback = http_glDrawTransformFeedback;
  tbl.glGenTransformFeedbacks = http_glGenTransformFeedbacks;
  tbl.glIsTransformFeedback = http_glIsTransformFeedback;
  tbl.glPauseTransformFeedback = http_glPauseTransformFeedback;
  tbl.glResumeTransformFeedback = http_glResumeTransformFeedback;

  // GL_ARB_transform_feedback3

  tbl.glBeginQueryIndexed = http_glBeginQueryIndexed;
  tbl.glDrawTransformFeedbackStream = http_glDrawTransformFeedbackStream;
  tbl.glEndQueryIndexed = http_glEndQueryIndexed;
  tbl.glGetQueryIndexediv = http_glGetQueryIndexediv;

  // GL_ARB_transform_feedback_instanced

  tbl.glDrawTransformFeedbackInstanced = http_glDrawTransformFeedbackInstanced;
  tbl.glDrawTransformFeedbackStreamInstanced = http_glDrawTransformFeedbackStreamInstanced;

  // GL_ARB_transpose_matrix

  tbl.glLoadTransposeMatrixdARB = http_glLoadTransposeMatrixdARB;
  tbl.glLoadTransposeMatrixfARB = http_glLoadTransposeMatrixfARB;
  tbl.glMultTransposeMatrixdARB = http_glMultTransposeMatrixdARB;
  tbl.glMultTransposeMatrixfARB = http_glMultTransposeMatrixfARB;

  // GL_ARB_uniform_buffer_object

  tbl.glBindBufferBase = http_glBindBufferBase;
  tbl.glBindBufferRange = http_glBindBufferRange;
  tbl.glGetActiveUniformBlockName = http_glGetActiveUniformBlockName;
  tbl.glGetActiveUniformBlockiv = http_glGetActiveUniformBlockiv;
  tbl.glGetActiveUniformName = http_glGetActiveUniformName;
  tbl.glGetActiveUniformsiv = http_glGetActiveUniformsiv;
  tbl.glGetIntegeri_v = http_glGetIntegeri_v;
  tbl.glGetUniformBlockIndex = http_glGetUniformBlockIndex;
  tbl.glGetUniformIndices = http_glGetUniformIndices;
  tbl.glUniformBlockBinding = http_glUniformBlockBinding;

  // GL_ARB_vertex_array_object

  tbl.glBindVertexArray = http_glBindVertexArray;
  tbl.glDeleteVertexArrays = http_glDeleteVertexArrays;
  tbl.glGenVertexArrays = http_glGenVertexArrays;
  tbl.glIsVertexArray = http_glIsVertexArray;

  // GL_ARB_vertex_attrib_64bit

  tbl.glGetVertexAttribLdv = http_glGetVertexAttribLdv;
  tbl.glVertexAttribL1d = http_glVertexAttribL1d;
  tbl.glVertexAttribL1dv = http_glVertexAttribL1dv;
  tbl.glVertexAttribL2d = http_glVertexAttribL2d;
  tbl.glVertexAttribL2dv = http_glVertexAttribL2dv;
  tbl.glVertexAttribL3d = http_glVertexAttribL3d;
  tbl.glVertexAttribL3dv = http_glVertexAttribL3dv;
  tbl.glVertexAttribL4d = http_glVertexAttribL4d;
  tbl.glVertexAttribL4dv = http_glVertexAttribL4dv;
  tbl.glVertexAttribLPointer = http_glVertexAttribLPointer;

  // GL_ARB_vertex_attrib_binding

  tbl.glBindVertexBuffer = http_glBindVertexBuffer;
  tbl.glVertexArrayBindVertexBufferEXT = http_glVertexArrayBindVertexBufferEXT;
  tbl.glVertexArrayVertexAttribBindingEXT = http_glVertexArrayVertexAttribBindingEXT;
  tbl.glVertexArrayVertexAttribFormatEXT = http_glVertexArrayVertexAttribFormatEXT;
  tbl.glVertexArrayVertexAttribIFormatEXT = http_glVertexArrayVertexAttribIFormatEXT;
  tbl.glVertexArrayVertexAttribLFormatEXT = http_glVertexArrayVertexAttribLFormatEXT;
  tbl.glVertexArrayVertexBindingDivisorEXT = http_glVertexArrayVertexBindingDivisorEXT;
  tbl.glVertexAttribBinding = http_glVertexAttribBinding;
  tbl.glVertexAttribFormat = http_glVertexAttribFormat;
  tbl.glVertexAttribIFormat = http_glVertexAttribIFormat;
  tbl.glVertexAttribLFormat = http_glVertexAttribLFormat;
  tbl.glVertexBindingDivisor = http_glVertexBindingDivisor;

  // GL_ARB_vertex_blend

  tbl.glVertexBlendARB = http_glVertexBlendARB;
  tbl.glWeightPointerARB = http_glWeightPointerARB;
  tbl.glWeightbvARB = http_glWeightbvARB;
  tbl.glWeightdvARB = http_glWeightdvARB;
  tbl.glWeightfvARB = http_glWeightfvARB;
  tbl.glWeightivARB = http_glWeightivARB;
  tbl.glWeightsvARB = http_glWeightsvARB;
  tbl.glWeightubvARB = http_glWeightubvARB;
  tbl.glWeightuivARB = http_glWeightuivARB;
  tbl.glWeightusvARB = http_glWeightusvARB;

  // GL_ARB_vertex_buffer_object

  tbl.glBindBufferARB = http_glBindBufferARB;
  tbl.glBufferDataARB = http_glBufferDataARB;
  tbl.glBufferSubDataARB = http_glBufferSubDataARB;
  tbl.glDeleteBuffersARB = http_glDeleteBuffersARB;
  tbl.glGenBuffersARB = http_glGenBuffersARB;
  tbl.glGetBufferParameterivARB = http_glGetBufferParameterivARB;
  tbl.glGetBufferPointervARB = http_glGetBufferPointervARB;
  tbl.glGetBufferSubDataARB = http_glGetBufferSubDataARB;
  tbl.glIsBufferARB = http_glIsBufferARB;
  tbl.glMapBufferARB = http_glMapBufferARB;
  tbl.glUnmapBufferARB = http_glUnmapBufferARB;

  // GL_ARB_vertex_program

  tbl.glBindProgramARB = http_glBindProgramARB;
  tbl.glDeleteProgramsARB = http_glDeleteProgramsARB;
  tbl.glDisableVertexAttribArrayARB = http_glDisableVertexAttribArrayARB;
  tbl.glEnableVertexAttribArrayARB = http_glEnableVertexAttribArrayARB;
  tbl.glGenProgramsARB = http_glGenProgramsARB;
  tbl.glGetProgramEnvParameterdvARB = http_glGetProgramEnvParameterdvARB;
  tbl.glGetProgramEnvParameterfvARB = http_glGetProgramEnvParameterfvARB;
  tbl.glGetProgramLocalParameterdvARB = http_glGetProgramLocalParameterdvARB;
  tbl.glGetProgramLocalParameterfvARB = http_glGetProgramLocalParameterfvARB;
  tbl.glGetProgramStringARB = http_glGetProgramStringARB;
  tbl.glGetProgramivARB = http_glGetProgramivARB;
  tbl.glGetVertexAttribPointervARB = http_glGetVertexAttribPointervARB;
  tbl.glGetVertexAttribdvARB = http_glGetVertexAttribdvARB;
  tbl.glGetVertexAttribfvARB = http_glGetVertexAttribfvARB;
  tbl.glGetVertexAttribivARB = http_glGetVertexAttribivARB;
  tbl.glIsProgramARB = http_glIsProgramARB;
  tbl.glProgramEnvParameter4dARB = http_glProgramEnvParameter4dARB;
  tbl.glProgramEnvParameter4dvARB = http_glProgramEnvParameter4dvARB;
  tbl.glProgramEnvParameter4fARB = http_glProgramEnvParameter4fARB;
  tbl.glProgramEnvParameter4fvARB = http_glProgramEnvParameter4fvARB;
  tbl.glProgramLocalParameter4dARB = http_glProgramLocalParameter4dARB;
  tbl.glProgramLocalParameter4dvARB = http_glProgramLocalParameter4dvARB;
  tbl.glProgramLocalParameter4fARB = http_glProgramLocalParameter4fARB;
  tbl.glProgramLocalParameter4fvARB = http_glProgramLocalParameter4fvARB;
  tbl.glProgramStringARB = http_glProgramStringARB;
  tbl.glVertexAttrib1dARB = http_glVertexAttrib1dARB;
  tbl.glVertexAttrib1dvARB = http_glVertexAttrib1dvARB;
  tbl.glVertexAttrib1fARB = http_glVertexAttrib1fARB;
  tbl.glVertexAttrib1fvARB = http_glVertexAttrib1fvARB;
  tbl.glVertexAttrib1sARB = http_glVertexAttrib1sARB;
  tbl.glVertexAttrib1svARB = http_glVertexAttrib1svARB;
  tbl.glVertexAttrib2dARB = http_glVertexAttrib2dARB;
  tbl.glVertexAttrib2dvARB = http_glVertexAttrib2dvARB;
  tbl.glVertexAttrib2fARB = http_glVertexAttrib2fARB;
  tbl.glVertexAttrib2fvARB = http_glVertexAttrib2fvARB;
  tbl.glVertexAttrib2sARB = http_glVertexAttrib2sARB;
  tbl.glVertexAttrib2svARB = http_glVertexAttrib2svARB;
  tbl.glVertexAttrib3dARB = http_glVertexAttrib3dARB;
  tbl.glVertexAttrib3dvARB = http_glVertexAttrib3dvARB;
  tbl.glVertexAttrib3fARB = http_glVertexAttrib3fARB;
  tbl.glVertexAttrib3fvARB = http_glVertexAttrib3fvARB;
  tbl.glVertexAttrib3sARB = http_glVertexAttrib3sARB;
  tbl.glVertexAttrib3svARB = http_glVertexAttrib3svARB;
  tbl.glVertexAttrib4NbvARB = http_glVertexAttrib4NbvARB;
  tbl.glVertexAttrib4NivARB = http_glVertexAttrib4NivARB;
  tbl.glVertexAttrib4NsvARB = http_glVertexAttrib4NsvARB;
  tbl.glVertexAttrib4NubARB = http_glVertexAttrib4NubARB;
  tbl.glVertexAttrib4NubvARB = http_glVertexAttrib4NubvARB;
  tbl.glVertexAttrib4NuivARB = http_glVertexAttrib4NuivARB;
  tbl.glVertexAttrib4NusvARB = http_glVertexAttrib4NusvARB;
  tbl.glVertexAttrib4bvARB = http_glVertexAttrib4bvARB;
  tbl.glVertexAttrib4dARB = http_glVertexAttrib4dARB;
  tbl.glVertexAttrib4dvARB = http_glVertexAttrib4dvARB;
  tbl.glVertexAttrib4fARB = http_glVertexAttrib4fARB;
  tbl.glVertexAttrib4fvARB = http_glVertexAttrib4fvARB;
  tbl.glVertexAttrib4ivARB = http_glVertexAttrib4ivARB;
  tbl.glVertexAttrib4sARB = http_glVertexAttrib4sARB;
  tbl.glVertexAttrib4svARB = http_glVertexAttrib4svARB;
  tbl.glVertexAttrib4ubvARB = http_glVertexAttrib4ubvARB;
  tbl.glVertexAttrib4uivARB = http_glVertexAttrib4uivARB;
  tbl.glVertexAttrib4usvARB = http_glVertexAttrib4usvARB;
  tbl.glVertexAttribPointerARB = http_glVertexAttribPointerARB;

  // GL_ARB_vertex_shader

  tbl.glBindAttribLocationARB = http_glBindAttribLocationARB;
  tbl.glGetActiveAttribARB = http_glGetActiveAttribARB;
  tbl.glGetAttribLocationARB = http_glGetAttribLocationARB;

  // GL_ARB_vertex_type_2_10_10_10_rev

  tbl.glColorP3ui = http_glColorP3ui;
  tbl.glColorP3uiv = http_glColorP3uiv;
  tbl.glColorP4ui = http_glColorP4ui;
  tbl.glColorP4uiv = http_glColorP4uiv;
  tbl.glMultiTexCoordP1ui = http_glMultiTexCoordP1ui;
  tbl.glMultiTexCoordP1uiv = http_glMultiTexCoordP1uiv;
  tbl.glMultiTexCoordP2ui = http_glMultiTexCoordP2ui;
  tbl.glMultiTexCoordP2uiv = http_glMultiTexCoordP2uiv;
  tbl.glMultiTexCoordP3ui = http_glMultiTexCoordP3ui;
  tbl.glMultiTexCoordP3uiv = http_glMultiTexCoordP3uiv;
  tbl.glMultiTexCoordP4ui = http_glMultiTexCoordP4ui;
  tbl.glMultiTexCoordP4uiv = http_glMultiTexCoordP4uiv;
  tbl.glNormalP3ui = http_glNormalP3ui;
  tbl.glNormalP3uiv = http_glNormalP3uiv;
  tbl.glSecondaryColorP3ui = http_glSecondaryColorP3ui;
  tbl.glSecondaryColorP3uiv = http_glSecondaryColorP3uiv;
  tbl.glTexCoordP1ui = http_glTexCoordP1ui;
  tbl.glTexCoordP1uiv = http_glTexCoordP1uiv;
  tbl.glTexCoordP2ui = http_glTexCoordP2ui;
  tbl.glTexCoordP2uiv = http_glTexCoordP2uiv;
  tbl.glTexCoordP3ui = http_glTexCoordP3ui;
  tbl.glTexCoordP3uiv = http_glTexCoordP3uiv;
  tbl.glTexCoordP4ui = http_glTexCoordP4ui;
  tbl.glTexCoordP4uiv = http_glTexCoordP4uiv;
  tbl.glVertexAttribP1ui = http_glVertexAttribP1ui;
  tbl.glVertexAttribP1uiv = http_glVertexAttribP1uiv;
  tbl.glVertexAttribP2ui = http_glVertexAttribP2ui;
  tbl.glVertexAttribP2uiv = http_glVertexAttribP2uiv;
  tbl.glVertexAttribP3ui = http_glVertexAttribP3ui;
  tbl.glVertexAttribP3uiv = http_glVertexAttribP3uiv;
  tbl.glVertexAttribP4ui = http_glVertexAttribP4ui;
  tbl.glVertexAttribP4uiv = http_glVertexAttribP4uiv;
  tbl.glVertexP2ui = http_glVertexP2ui;
  tbl.glVertexP2uiv = http_glVertexP2uiv;
  tbl.glVertexP3ui = http_glVertexP3ui;
  tbl.glVertexP3uiv = http_glVertexP3uiv;
  tbl.glVertexP4ui = http_glVertexP4ui;
  tbl.glVertexP4uiv = http_glVertexP4uiv;

  // GL_ARB_viewport_array

  tbl.glDepthRangeArrayv = http_glDepthRangeArrayv;
  tbl.glDepthRangeIndexed = http_glDepthRangeIndexed;
  tbl.glGetDoublei_v = http_glGetDoublei_v;
  tbl.glGetFloati_v = http_glGetFloati_v;
  tbl.glScissorArrayv = http_glScissorArrayv;
  tbl.glScissorIndexed = http_glScissorIndexed;
  tbl.glScissorIndexedv = http_glScissorIndexedv;
  tbl.glViewportArrayv = http_glViewportArrayv;
  tbl.glViewportIndexedf = http_glViewportIndexedf;
  tbl.glViewportIndexedfv = http_glViewportIndexedfv;

  // GL_ARB_window_pos

  tbl.glWindowPos2dARB = http_glWindowPos2dARB;
  tbl.glWindowPos2dvARB = http_glWindowPos2dvARB;
  tbl.glWindowPos2fARB = http_glWindowPos2fARB;
  tbl.glWindowPos2fvARB = http_glWindowPos2fvARB;
  tbl.glWindowPos2iARB = http_glWindowPos2iARB;
  tbl.glWindowPos2ivARB = http_glWindowPos2ivARB;
  tbl.glWindowPos2sARB = http_glWindowPos2sARB;
  tbl.glWindowPos2svARB = http_glWindowPos2svARB;
  tbl.glWindowPos3dARB = http_glWindowPos3dARB;
  tbl.glWindowPos3dvARB = http_glWindowPos3dvARB;
  tbl.glWindowPos3fARB = http_glWindowPos3fARB;
  tbl.glWindowPos3fvARB = http_glWindowPos3fvARB;
  tbl.glWindowPos3iARB = http_glWindowPos3iARB;
  tbl.glWindowPos3ivARB = http_glWindowPos3ivARB;
  tbl.glWindowPos3sARB = http_glWindowPos3sARB;
  tbl.glWindowPos3svARB = http_glWindowPos3svARB;

  // GL_ATI_draw_buffers

  tbl.glDrawBuffersATI = http_glDrawBuffersATI;

  // GL_ATI_element_array

  tbl.glDrawElementArrayATI = http_glDrawElementArrayATI;
  tbl.glDrawRangeElementArrayATI = http_glDrawRangeElementArrayATI;
  tbl.glElementPointerATI = http_glElementPointerATI;

  // GL_ATI_envmap_bumpmap

  tbl.glGetTexBumpParameterfvATI = http_glGetTexBumpParameterfvATI;
  tbl.glGetTexBumpParameterivATI = http_glGetTexBumpParameterivATI;
  tbl.glTexBumpParameterfvATI = http_glTexBumpParameterfvATI;
  tbl.glTexBumpParameterivATI = http_glTexBumpParameterivATI;

  // GL_ATI_fragment_shader

  tbl.glAlphaFragmentOp1ATI = http_glAlphaFragmentOp1ATI;
  tbl.glAlphaFragmentOp2ATI = http_glAlphaFragmentOp2ATI;
  tbl.glAlphaFragmentOp3ATI = http_glAlphaFragmentOp3ATI;
  tbl.glBeginFragmentShaderATI = http_glBeginFragmentShaderATI;
  tbl.glBindFragmentShaderATI = http_glBindFragmentShaderATI;
  tbl.glColorFragmentOp1ATI = http_glColorFragmentOp1ATI;
  tbl.glColorFragmentOp2ATI = http_glColorFragmentOp2ATI;
  tbl.glColorFragmentOp3ATI = http_glColorFragmentOp3ATI;
  tbl.glDeleteFragmentShaderATI = http_glDeleteFragmentShaderATI;
  tbl.glEndFragmentShaderATI = http_glEndFragmentShaderATI;
  tbl.glGenFragmentShadersATI = http_glGenFragmentShadersATI;
  tbl.glPassTexCoordATI = http_glPassTexCoordATI;
  tbl.glSampleMapATI = http_glSampleMapATI;
  tbl.glSetFragmentShaderConstantATI = http_glSetFragmentShaderConstantATI;

  // GL_ATI_map_object_buffer

  tbl.glMapObjectBufferATI = http_glMapObjectBufferATI;
  tbl.glUnmapObjectBufferATI = http_glUnmapObjectBufferATI;

  // GL_ATI_pn_triangles

  tbl.glPNTrianglesfATI = http_glPNTrianglesfATI;
  tbl.glPNTrianglesiATI = http_glPNTrianglesiATI;

  // GL_ATI_separate_stencil

  tbl.glStencilFuncSeparateATI = http_glStencilFuncSeparateATI;
  tbl.glStencilOpSeparateATI = http_glStencilOpSeparateATI;

  // GL_ATI_vertex_array_object

  tbl.glArrayObjectATI = http_glArrayObjectATI;
  tbl.glFreeObjectBufferATI = http_glFreeObjectBufferATI;
  tbl.glGetArrayObjectfvATI = http_glGetArrayObjectfvATI;
  tbl.glGetArrayObjectivATI = http_glGetArrayObjectivATI;
  tbl.glGetObjectBufferfvATI = http_glGetObjectBufferfvATI;
  tbl.glGetObjectBufferivATI = http_glGetObjectBufferivATI;
  tbl.glGetVariantArrayObjectfvATI = http_glGetVariantArrayObjectfvATI;
  tbl.glGetVariantArrayObjectivATI = http_glGetVariantArrayObjectivATI;
  tbl.glIsObjectBufferATI = http_glIsObjectBufferATI;
  tbl.glNewObjectBufferATI = http_glNewObjectBufferATI;
  tbl.glUpdateObjectBufferATI = http_glUpdateObjectBufferATI;
  tbl.glVariantArrayObjectATI = http_glVariantArrayObjectATI;

  // GL_ATI_vertex_attrib_array_object

  tbl.glGetVertexAttribArrayObjectfvATI = http_glGetVertexAttribArrayObjectfvATI;
  tbl.glGetVertexAttribArrayObjectivATI = http_glGetVertexAttribArrayObjectivATI;
  tbl.glVertexAttribArrayObjectATI = http_glVertexAttribArrayObjectATI;

  // GL_ATI_vertex_streams

  tbl.glClientActiveVertexStreamATI = http_glClientActiveVertexStreamATI;
  tbl.glNormalStream3bATI = http_glNormalStream3bATI;
  tbl.glNormalStream3bvATI = http_glNormalStream3bvATI;
  tbl.glNormalStream3dATI = http_glNormalStream3dATI;
  tbl.glNormalStream3dvATI = http_glNormalStream3dvATI;
  tbl.glNormalStream3fATI = http_glNormalStream3fATI;
  tbl.glNormalStream3fvATI = http_glNormalStream3fvATI;
  tbl.glNormalStream3iATI = http_glNormalStream3iATI;
  tbl.glNormalStream3ivATI = http_glNormalStream3ivATI;
  tbl.glNormalStream3sATI = http_glNormalStream3sATI;
  tbl.glNormalStream3svATI = http_glNormalStream3svATI;
  tbl.glVertexBlendEnvfATI = http_glVertexBlendEnvfATI;
  tbl.glVertexBlendEnviATI = http_glVertexBlendEnviATI;
  tbl.glVertexStream1dATI = http_glVertexStream1dATI;
  tbl.glVertexStream1dvATI = http_glVertexStream1dvATI;
  tbl.glVertexStream1fATI = http_glVertexStream1fATI;
  tbl.glVertexStream1fvATI = http_glVertexStream1fvATI;
  tbl.glVertexStream1iATI = http_glVertexStream1iATI;
  tbl.glVertexStream1ivATI = http_glVertexStream1ivATI;
  tbl.glVertexStream1sATI = http_glVertexStream1sATI;
  tbl.glVertexStream1svATI = http_glVertexStream1svATI;
  tbl.glVertexStream2dATI = http_glVertexStream2dATI;
  tbl.glVertexStream2dvATI = http_glVertexStream2dvATI;
  tbl.glVertexStream2fATI = http_glVertexStream2fATI;
  tbl.glVertexStream2fvATI = http_glVertexStream2fvATI;
  tbl.glVertexStream2iATI = http_glVertexStream2iATI;
  tbl.glVertexStream2ivATI = http_glVertexStream2ivATI;
  tbl.glVertexStream2sATI = http_glVertexStream2sATI;
  tbl.glVertexStream2svATI = http_glVertexStream2svATI;
  tbl.glVertexStream3dATI = http_glVertexStream3dATI;
  tbl.glVertexStream3dvATI = http_glVertexStream3dvATI;
  tbl.glVertexStream3fATI = http_glVertexStream3fATI;
  tbl.glVertexStream3fvATI = http_glVertexStream3fvATI;
  tbl.glVertexStream3iATI = http_glVertexStream3iATI;
  tbl.glVertexStream3ivATI = http_glVertexStream3ivATI;
  tbl.glVertexStream3sATI = http_glVertexStream3sATI;
  tbl.glVertexStream3svATI = http_glVertexStream3svATI;
  tbl.glVertexStream4dATI = http_glVertexStream4dATI;
  tbl.glVertexStream4dvATI = http_glVertexStream4dvATI;
  tbl.glVertexStream4fATI = http_glVertexStream4fATI;
  tbl.glVertexStream4fvATI = http_glVertexStream4fvATI;
  tbl.glVertexStream4iATI = http_glVertexStream4iATI;
  tbl.glVertexStream4ivATI = http_glVertexStream4ivATI;
  tbl.glVertexStream4sATI = http_glVertexStream4sATI;
  tbl.glVertexStream4svATI = http_glVertexStream4svATI;

  // GL_EXT_bindable_uniform

  tbl.glGetUniformBufferSizeEXT = http_glGetUniformBufferSizeEXT;
  tbl.glGetUniformOffsetEXT = http_glGetUniformOffsetEXT;
  tbl.glUniformBufferEXT = http_glUniformBufferEXT;

  // GL_EXT_blend_color

  tbl.glBlendColorEXT = http_glBlendColorEXT;

  // GL_EXT_blend_equation_separate

  tbl.glBlendEquationSeparateEXT = http_glBlendEquationSeparateEXT;

  // GL_EXT_blend_func_separate

  tbl.glBlendFuncSeparateEXT = http_glBlendFuncSeparateEXT;

  // GL_EXT_blend_minmax

  tbl.glBlendEquationEXT = http_glBlendEquationEXT;

  // GL_EXT_color_subtable

  tbl.glColorSubTableEXT = http_glColorSubTableEXT;
  tbl.glCopyColorSubTableEXT = http_glCopyColorSubTableEXT;

  // GL_EXT_compiled_vertex_array

  tbl.glLockArraysEXT = http_glLockArraysEXT;
  tbl.glUnlockArraysEXT = http_glUnlockArraysEXT;

  // GL_EXT_convolution

  tbl.glConvolutionFilter1DEXT = http_glConvolutionFilter1DEXT;
  tbl.glConvolutionFilter2DEXT = http_glConvolutionFilter2DEXT;
  tbl.glConvolutionParameterfEXT = http_glConvolutionParameterfEXT;
  tbl.glConvolutionParameterfvEXT = http_glConvolutionParameterfvEXT;
  tbl.glConvolutionParameteriEXT = http_glConvolutionParameteriEXT;
  tbl.glConvolutionParameterivEXT = http_glConvolutionParameterivEXT;
  tbl.glCopyConvolutionFilter1DEXT = http_glCopyConvolutionFilter1DEXT;
  tbl.glCopyConvolutionFilter2DEXT = http_glCopyConvolutionFilter2DEXT;
  tbl.glGetConvolutionFilterEXT = http_glGetConvolutionFilterEXT;
  tbl.glGetConvolutionParameterfvEXT = http_glGetConvolutionParameterfvEXT;
  tbl.glGetConvolutionParameterivEXT = http_glGetConvolutionParameterivEXT;
  tbl.glGetSeparableFilterEXT = http_glGetSeparableFilterEXT;
  tbl.glSeparableFilter2DEXT = http_glSeparableFilter2DEXT;

  // GL_EXT_coordinate_frame

  tbl.glBinormal3bEXT = http_glBinormal3bEXT;
  tbl.glBinormal3bvEXT = http_glBinormal3bvEXT;
  tbl.glBinormal3dEXT = http_glBinormal3dEXT;
  tbl.glBinormal3dvEXT = http_glBinormal3dvEXT;
  tbl.glBinormal3fEXT = http_glBinormal3fEXT;
  tbl.glBinormal3fvEXT = http_glBinormal3fvEXT;
  tbl.glBinormal3iEXT = http_glBinormal3iEXT;
  tbl.glBinormal3ivEXT = http_glBinormal3ivEXT;
  tbl.glBinormal3sEXT = http_glBinormal3sEXT;
  tbl.glBinormal3svEXT = http_glBinormal3svEXT;
  tbl.glBinormalPointerEXT = http_glBinormalPointerEXT;
  tbl.glTangent3bEXT = http_glTangent3bEXT;
  tbl.glTangent3bvEXT = http_glTangent3bvEXT;
  tbl.glTangent3dEXT = http_glTangent3dEXT;
  tbl.glTangent3dvEXT = http_glTangent3dvEXT;
  tbl.glTangent3fEXT = http_glTangent3fEXT;
  tbl.glTangent3fvEXT = http_glTangent3fvEXT;
  tbl.glTangent3iEXT = http_glTangent3iEXT;
  tbl.glTangent3ivEXT = http_glTangent3ivEXT;
  tbl.glTangent3sEXT = http_glTangent3sEXT;
  tbl.glTangent3svEXT = http_glTangent3svEXT;
  tbl.glTangentPointerEXT = http_glTangentPointerEXT;

  // GL_EXT_copy_texture

  tbl.glCopyTexImage1DEXT = http_glCopyTexImage1DEXT;
  tbl.glCopyTexImage2DEXT = http_glCopyTexImage2DEXT;
  tbl.glCopyTexSubImage1DEXT = http_glCopyTexSubImage1DEXT;
  tbl.glCopyTexSubImage2DEXT = http_glCopyTexSubImage2DEXT;
  tbl.glCopyTexSubImage3DEXT = http_glCopyTexSubImage3DEXT;

  // GL_EXT_cull_vertex

  tbl.glCullParameterdvEXT = http_glCullParameterdvEXT;
  tbl.glCullParameterfvEXT = http_glCullParameterfvEXT;

  // GL_EXT_debug_label

  tbl.glGetObjectLabelEXT = http_glGetObjectLabelEXT;
  tbl.glLabelObjectEXT = http_glLabelObjectEXT;

  // GL_EXT_debug_marker

  tbl.glInsertEventMarkerEXT = http_glInsertEventMarkerEXT;
  tbl.glPopGroupMarkerEXT = http_glPopGroupMarkerEXT;
  tbl.glPushGroupMarkerEXT = http_glPushGroupMarkerEXT;

  // GL_EXT_depth_bounds_test

  tbl.glDepthBoundsEXT = http_glDepthBoundsEXT;

  // GL_EXT_direct_state_access

  tbl.glBindMultiTextureEXT = http_glBindMultiTextureEXT;
  tbl.glCheckNamedFramebufferStatusEXT = http_glCheckNamedFramebufferStatusEXT;
  tbl.glClientAttribDefaultEXT = http_glClientAttribDefaultEXT;
  tbl.glCompressedMultiTexImage1DEXT = http_glCompressedMultiTexImage1DEXT;
  tbl.glCompressedMultiTexImage2DEXT = http_glCompressedMultiTexImage2DEXT;
  tbl.glCompressedMultiTexImage3DEXT = http_glCompressedMultiTexImage3DEXT;
  tbl.glCompressedMultiTexSubImage1DEXT = http_glCompressedMultiTexSubImage1DEXT;
  tbl.glCompressedMultiTexSubImage2DEXT = http_glCompressedMultiTexSubImage2DEXT;
  tbl.glCompressedMultiTexSubImage3DEXT = http_glCompressedMultiTexSubImage3DEXT;
  tbl.glCompressedTextureImage1DEXT = http_glCompressedTextureImage1DEXT;
  tbl.glCompressedTextureImage2DEXT = http_glCompressedTextureImage2DEXT;
  tbl.glCompressedTextureImage3DEXT = http_glCompressedTextureImage3DEXT;
  tbl.glCompressedTextureSubImage1DEXT = http_glCompressedTextureSubImage1DEXT;
  tbl.glCompressedTextureSubImage2DEXT = http_glCompressedTextureSubImage2DEXT;
  tbl.glCompressedTextureSubImage3DEXT = http_glCompressedTextureSubImage3DEXT;
  tbl.glCopyMultiTexImage1DEXT = http_glCopyMultiTexImage1DEXT;
  tbl.glCopyMultiTexImage2DEXT = http_glCopyMultiTexImage2DEXT;
  tbl.glCopyMultiTexSubImage1DEXT = http_glCopyMultiTexSubImage1DEXT;
  tbl.glCopyMultiTexSubImage2DEXT = http_glCopyMultiTexSubImage2DEXT;
  tbl.glCopyMultiTexSubImage3DEXT = http_glCopyMultiTexSubImage3DEXT;
  tbl.glCopyTextureImage1DEXT = http_glCopyTextureImage1DEXT;
  tbl.glCopyTextureImage2DEXT = http_glCopyTextureImage2DEXT;
  tbl.glCopyTextureSubImage1DEXT = http_glCopyTextureSubImage1DEXT;
  tbl.glCopyTextureSubImage2DEXT = http_glCopyTextureSubImage2DEXT;
  tbl.glCopyTextureSubImage3DEXT = http_glCopyTextureSubImage3DEXT;
  tbl.glDisableClientStateIndexedEXT = http_glDisableClientStateIndexedEXT;
  tbl.glDisableClientStateiEXT = http_glDisableClientStateiEXT;
  tbl.glDisableVertexArrayAttribEXT = http_glDisableVertexArrayAttribEXT;
  tbl.glDisableVertexArrayEXT = http_glDisableVertexArrayEXT;
  tbl.glEnableClientStateIndexedEXT = http_glEnableClientStateIndexedEXT;
  tbl.glEnableClientStateiEXT = http_glEnableClientStateiEXT;
  tbl.glEnableVertexArrayAttribEXT = http_glEnableVertexArrayAttribEXT;
  tbl.glEnableVertexArrayEXT = http_glEnableVertexArrayEXT;
  tbl.glFlushMappedNamedBufferRangeEXT = http_glFlushMappedNamedBufferRangeEXT;
  tbl.glFramebufferDrawBufferEXT = http_glFramebufferDrawBufferEXT;
  tbl.glFramebufferDrawBuffersEXT = http_glFramebufferDrawBuffersEXT;
  tbl.glFramebufferReadBufferEXT = http_glFramebufferReadBufferEXT;
  tbl.glGenerateMultiTexMipmapEXT = http_glGenerateMultiTexMipmapEXT;
  tbl.glGenerateTextureMipmapEXT = http_glGenerateTextureMipmapEXT;
  tbl.glGetCompressedMultiTexImageEXT = http_glGetCompressedMultiTexImageEXT;
  tbl.glGetCompressedTextureImageEXT = http_glGetCompressedTextureImageEXT;
  tbl.glGetDoubleIndexedvEXT = http_glGetDoubleIndexedvEXT;
  tbl.glGetDoublei_vEXT = http_glGetDoublei_vEXT;
  tbl.glGetFloatIndexedvEXT = http_glGetFloatIndexedvEXT;
  tbl.glGetFloati_vEXT = http_glGetFloati_vEXT;
  tbl.glGetFramebufferParameterivEXT = http_glGetFramebufferParameterivEXT;
  tbl.glGetMultiTexEnvfvEXT = http_glGetMultiTexEnvfvEXT;
  tbl.glGetMultiTexEnvivEXT = http_glGetMultiTexEnvivEXT;
  tbl.glGetMultiTexGendvEXT = http_glGetMultiTexGendvEXT;
  tbl.glGetMultiTexGenfvEXT = http_glGetMultiTexGenfvEXT;
  tbl.glGetMultiTexGenivEXT = http_glGetMultiTexGenivEXT;
  tbl.glGetMultiTexImageEXT = http_glGetMultiTexImageEXT;
  tbl.glGetMultiTexLevelParameterfvEXT = http_glGetMultiTexLevelParameterfvEXT;
  tbl.glGetMultiTexLevelParameterivEXT = http_glGetMultiTexLevelParameterivEXT;
  tbl.glGetMultiTexParameterIivEXT = http_glGetMultiTexParameterIivEXT;
  tbl.glGetMultiTexParameterIuivEXT = http_glGetMultiTexParameterIuivEXT;
  tbl.glGetMultiTexParameterfvEXT = http_glGetMultiTexParameterfvEXT;
  tbl.glGetMultiTexParameterivEXT = http_glGetMultiTexParameterivEXT;
  tbl.glGetNamedBufferParameterivEXT = http_glGetNamedBufferParameterivEXT;
  tbl.glGetNamedBufferPointervEXT = http_glGetNamedBufferPointervEXT;
  tbl.glGetNamedBufferSubDataEXT = http_glGetNamedBufferSubDataEXT;
  tbl.glGetNamedFramebufferAttachmentParameterivEXT = http_glGetNamedFramebufferAttachmentParameterivEXT;
  tbl.glGetNamedProgramLocalParameterIivEXT = http_glGetNamedProgramLocalParameterIivEXT;
  tbl.glGetNamedProgramLocalParameterIuivEXT = http_glGetNamedProgramLocalParameterIuivEXT;
  tbl.glGetNamedProgramLocalParameterdvEXT = http_glGetNamedProgramLocalParameterdvEXT;
  tbl.glGetNamedProgramLocalParameterfvEXT = http_glGetNamedProgramLocalParameterfvEXT;
  tbl.glGetNamedProgramStringEXT = http_glGetNamedProgramStringEXT;
  tbl.glGetNamedProgramivEXT = http_glGetNamedProgramivEXT;
  tbl.glGetNamedRenderbufferParameterivEXT = http_glGetNamedRenderbufferParameterivEXT;
  tbl.glGetPointerIndexedvEXT = http_glGetPointerIndexedvEXT;
  tbl.glGetPointeri_vEXT = http_glGetPointeri_vEXT;
  tbl.glGetTextureImageEXT = http_glGetTextureImageEXT;
  tbl.glGetTextureLevelParameterfvEXT = http_glGetTextureLevelParameterfvEXT;
  tbl.glGetTextureLevelParameterivEXT = http_glGetTextureLevelParameterivEXT;
  tbl.glGetTextureParameterIivEXT = http_glGetTextureParameterIivEXT;
  tbl.glGetTextureParameterIuivEXT = http_glGetTextureParameterIuivEXT;
  tbl.glGetTextureParameterfvEXT = http_glGetTextureParameterfvEXT;
  tbl.glGetTextureParameterivEXT = http_glGetTextureParameterivEXT;
  tbl.glGetVertexArrayIntegeri_vEXT = http_glGetVertexArrayIntegeri_vEXT;
  tbl.glGetVertexArrayIntegervEXT = http_glGetVertexArrayIntegervEXT;
  tbl.glGetVertexArrayPointeri_vEXT = http_glGetVertexArrayPointeri_vEXT;
  tbl.glGetVertexArrayPointervEXT = http_glGetVertexArrayPointervEXT;
  tbl.glMapNamedBufferEXT = http_glMapNamedBufferEXT;
  tbl.glMapNamedBufferRangeEXT = http_glMapNamedBufferRangeEXT;
  tbl.glMatrixFrustumEXT = http_glMatrixFrustumEXT;
  tbl.glMatrixLoadIdentityEXT = http_glMatrixLoadIdentityEXT;
  tbl.glMatrixLoadTransposedEXT = http_glMatrixLoadTransposedEXT;
  tbl.glMatrixLoadTransposefEXT = http_glMatrixLoadTransposefEXT;
  tbl.glMatrixLoaddEXT = http_glMatrixLoaddEXT;
  tbl.glMatrixLoadfEXT = http_glMatrixLoadfEXT;
  tbl.glMatrixMultTransposedEXT = http_glMatrixMultTransposedEXT;
  tbl.glMatrixMultTransposefEXT = http_glMatrixMultTransposefEXT;
  tbl.glMatrixMultdEXT = http_glMatrixMultdEXT;
  tbl.glMatrixMultfEXT = http_glMatrixMultfEXT;
  tbl.glMatrixOrthoEXT = http_glMatrixOrthoEXT;
  tbl.glMatrixPopEXT = http_glMatrixPopEXT;
  tbl.glMatrixPushEXT = http_glMatrixPushEXT;
  tbl.glMatrixRotatedEXT = http_glMatrixRotatedEXT;
  tbl.glMatrixRotatefEXT = http_glMatrixRotatefEXT;
  tbl.glMatrixScaledEXT = http_glMatrixScaledEXT;
  tbl.glMatrixScalefEXT = http_glMatrixScalefEXT;
  tbl.glMatrixTranslatedEXT = http_glMatrixTranslatedEXT;
  tbl.glMatrixTranslatefEXT = http_glMatrixTranslatefEXT;
  tbl.glMultiTexBufferEXT = http_glMultiTexBufferEXT;
  tbl.glMultiTexCoordPointerEXT = http_glMultiTexCoordPointerEXT;
  tbl.glMultiTexEnvfEXT = http_glMultiTexEnvfEXT;
  tbl.glMultiTexEnvfvEXT = http_glMultiTexEnvfvEXT;
  tbl.glMultiTexEnviEXT = http_glMultiTexEnviEXT;
  tbl.glMultiTexEnvivEXT = http_glMultiTexEnvivEXT;
  tbl.glMultiTexGendEXT = http_glMultiTexGendEXT;
  tbl.glMultiTexGendvEXT = http_glMultiTexGendvEXT;
  tbl.glMultiTexGenfEXT = http_glMultiTexGenfEXT;
  tbl.glMultiTexGenfvEXT = http_glMultiTexGenfvEXT;
  tbl.glMultiTexGeniEXT = http_glMultiTexGeniEXT;
  tbl.glMultiTexGenivEXT = http_glMultiTexGenivEXT;
  tbl.glMultiTexImage1DEXT = http_glMultiTexImage1DEXT;
  tbl.glMultiTexImage2DEXT = http_glMultiTexImage2DEXT;
  tbl.glMultiTexImage3DEXT = http_glMultiTexImage3DEXT;
  tbl.glMultiTexParameterIivEXT = http_glMultiTexParameterIivEXT;
  tbl.glMultiTexParameterIuivEXT = http_glMultiTexParameterIuivEXT;
  tbl.glMultiTexParameterfEXT = http_glMultiTexParameterfEXT;
  tbl.glMultiTexParameterfvEXT = http_glMultiTexParameterfvEXT;
  tbl.glMultiTexParameteriEXT = http_glMultiTexParameteriEXT;
  tbl.glMultiTexParameterivEXT = http_glMultiTexParameterivEXT;
  tbl.glMultiTexRenderbufferEXT = http_glMultiTexRenderbufferEXT;
  tbl.glMultiTexSubImage1DEXT = http_glMultiTexSubImage1DEXT;
  tbl.glMultiTexSubImage2DEXT = http_glMultiTexSubImage2DEXT;
  tbl.glMultiTexSubImage3DEXT = http_glMultiTexSubImage3DEXT;
  tbl.glNamedBufferDataEXT = http_glNamedBufferDataEXT;
  tbl.glNamedBufferSubDataEXT = http_glNamedBufferSubDataEXT;
  tbl.glNamedCopyBufferSubDataEXT = http_glNamedCopyBufferSubDataEXT;
  tbl.glNamedFramebufferRenderbufferEXT = http_glNamedFramebufferRenderbufferEXT;
  tbl.glNamedFramebufferTexture1DEXT = http_glNamedFramebufferTexture1DEXT;
  tbl.glNamedFramebufferTexture2DEXT = http_glNamedFramebufferTexture2DEXT;
  tbl.glNamedFramebufferTexture3DEXT = http_glNamedFramebufferTexture3DEXT;
  tbl.glNamedFramebufferTextureEXT = http_glNamedFramebufferTextureEXT;
  tbl.glNamedFramebufferTextureFaceEXT = http_glNamedFramebufferTextureFaceEXT;
  tbl.glNamedFramebufferTextureLayerEXT = http_glNamedFramebufferTextureLayerEXT;
  tbl.glNamedProgramLocalParameter4dEXT = http_glNamedProgramLocalParameter4dEXT;
  tbl.glNamedProgramLocalParameter4dvEXT = http_glNamedProgramLocalParameter4dvEXT;
  tbl.glNamedProgramLocalParameter4fEXT = http_glNamedProgramLocalParameter4fEXT;
  tbl.glNamedProgramLocalParameter4fvEXT = http_glNamedProgramLocalParameter4fvEXT;
  tbl.glNamedProgramLocalParameterI4iEXT = http_glNamedProgramLocalParameterI4iEXT;
  tbl.glNamedProgramLocalParameterI4ivEXT = http_glNamedProgramLocalParameterI4ivEXT;
  tbl.glNamedProgramLocalParameterI4uiEXT = http_glNamedProgramLocalParameterI4uiEXT;
  tbl.glNamedProgramLocalParameterI4uivEXT = http_glNamedProgramLocalParameterI4uivEXT;
  tbl.glNamedProgramLocalParameters4fvEXT = http_glNamedProgramLocalParameters4fvEXT;
  tbl.glNamedProgramLocalParametersI4ivEXT = http_glNamedProgramLocalParametersI4ivEXT;
  tbl.glNamedProgramLocalParametersI4uivEXT = http_glNamedProgramLocalParametersI4uivEXT;
  tbl.glNamedProgramStringEXT = http_glNamedProgramStringEXT;
  tbl.glNamedRenderbufferStorageEXT = http_glNamedRenderbufferStorageEXT;
  tbl.glNamedRenderbufferStorageMultisampleCoverageEXT = http_glNamedRenderbufferStorageMultisampleCoverageEXT;
  tbl.glNamedRenderbufferStorageMultisampleEXT = http_glNamedRenderbufferStorageMultisampleEXT;
  tbl.glProgramUniform1dEXT = http_glProgramUniform1dEXT;
  tbl.glProgramUniform1dvEXT = http_glProgramUniform1dvEXT;
  tbl.glProgramUniform1fEXT = http_glProgramUniform1fEXT;
  tbl.glProgramUniform1fvEXT = http_glProgramUniform1fvEXT;
  tbl.glProgramUniform1iEXT = http_glProgramUniform1iEXT;
  tbl.glProgramUniform1ivEXT = http_glProgramUniform1ivEXT;
  tbl.glProgramUniform1uiEXT = http_glProgramUniform1uiEXT;
  tbl.glProgramUniform1uivEXT = http_glProgramUniform1uivEXT;
  tbl.glProgramUniform2dEXT = http_glProgramUniform2dEXT;
  tbl.glProgramUniform2dvEXT = http_glProgramUniform2dvEXT;
  tbl.glProgramUniform2fEXT = http_glProgramUniform2fEXT;
  tbl.glProgramUniform2fvEXT = http_glProgramUniform2fvEXT;
  tbl.glProgramUniform2iEXT = http_glProgramUniform2iEXT;
  tbl.glProgramUniform2ivEXT = http_glProgramUniform2ivEXT;
  tbl.glProgramUniform2uiEXT = http_glProgramUniform2uiEXT;
  tbl.glProgramUniform2uivEXT = http_glProgramUniform2uivEXT;
  tbl.glProgramUniform3dEXT = http_glProgramUniform3dEXT;
  tbl.glProgramUniform3dvEXT = http_glProgramUniform3dvEXT;
  tbl.glProgramUniform3fEXT = http_glProgramUniform3fEXT;
  tbl.glProgramUniform3fvEXT = http_glProgramUniform3fvEXT;
  tbl.glProgramUniform3iEXT = http_glProgramUniform3iEXT;
  tbl.glProgramUniform3ivEXT = http_glProgramUniform3ivEXT;
  tbl.glProgramUniform3uiEXT = http_glProgramUniform3uiEXT;
  tbl.glProgramUniform3uivEXT = http_glProgramUniform3uivEXT;
  tbl.glProgramUniform4dEXT = http_glProgramUniform4dEXT;
  tbl.glProgramUniform4dvEXT = http_glProgramUniform4dvEXT;
  tbl.glProgramUniform4fEXT = http_glProgramUniform4fEXT;
  tbl.glProgramUniform4fvEXT = http_glProgramUniform4fvEXT;
  tbl.glProgramUniform4iEXT = http_glProgramUniform4iEXT;
  tbl.glProgramUniform4ivEXT = http_glProgramUniform4ivEXT;
  tbl.glProgramUniform4uiEXT = http_glProgramUniform4uiEXT;
  tbl.glProgramUniform4uivEXT = http_glProgramUniform4uivEXT;
  tbl.glProgramUniformMatrix2dvEXT = http_glProgramUniformMatrix2dvEXT;
  tbl.glProgramUniformMatrix2fvEXT = http_glProgramUniformMatrix2fvEXT;
  tbl.glProgramUniformMatrix2x3dvEXT = http_glProgramUniformMatrix2x3dvEXT;
  tbl.glProgramUniformMatrix2x3fvEXT = http_glProgramUniformMatrix2x3fvEXT;
  tbl.glProgramUniformMatrix2x4dvEXT = http_glProgramUniformMatrix2x4dvEXT;
  tbl.glProgramUniformMatrix2x4fvEXT = http_glProgramUniformMatrix2x4fvEXT;
  tbl.glProgramUniformMatrix3dvEXT = http_glProgramUniformMatrix3dvEXT;
  tbl.glProgramUniformMatrix3fvEXT = http_glProgramUniformMatrix3fvEXT;
  tbl.glProgramUniformMatrix3x2dvEXT = http_glProgramUniformMatrix3x2dvEXT;
  tbl.glProgramUniformMatrix3x2fvEXT = http_glProgramUniformMatrix3x2fvEXT;
  tbl.glProgramUniformMatrix3x4dvEXT = http_glProgramUniformMatrix3x4dvEXT;
  tbl.glProgramUniformMatrix3x4fvEXT = http_glProgramUniformMatrix3x4fvEXT;
  tbl.glProgramUniformMatrix4dvEXT = http_glProgramUniformMatrix4dvEXT;
  tbl.glProgramUniformMatrix4fvEXT = http_glProgramUniformMatrix4fvEXT;
  tbl.glProgramUniformMatrix4x2dvEXT = http_glProgramUniformMatrix4x2dvEXT;
  tbl.glProgramUniformMatrix4x2fvEXT = http_glProgramUniformMatrix4x2fvEXT;
  tbl.glProgramUniformMatrix4x3dvEXT = http_glProgramUniformMatrix4x3dvEXT;
  tbl.glProgramUniformMatrix4x3fvEXT = http_glProgramUniformMatrix4x3fvEXT;
  tbl.glPushClientAttribDefaultEXT = http_glPushClientAttribDefaultEXT;
  tbl.glTextureBufferEXT = http_glTextureBufferEXT;
  tbl.glTextureImage1DEXT = http_glTextureImage1DEXT;
  tbl.glTextureImage2DEXT = http_glTextureImage2DEXT;
  tbl.glTextureImage3DEXT = http_glTextureImage3DEXT;
  tbl.glTextureParameterIivEXT = http_glTextureParameterIivEXT;
  tbl.glTextureParameterIuivEXT = http_glTextureParameterIuivEXT;
  tbl.glTextureParameterfEXT = http_glTextureParameterfEXT;
  tbl.glTextureParameterfvEXT = http_glTextureParameterfvEXT;
  tbl.glTextureParameteriEXT = http_glTextureParameteriEXT;
  tbl.glTextureParameterivEXT = http_glTextureParameterivEXT;
  tbl.glTextureRenderbufferEXT = http_glTextureRenderbufferEXT;
  tbl.glTextureSubImage1DEXT = http_glTextureSubImage1DEXT;
  tbl.glTextureSubImage2DEXT = http_glTextureSubImage2DEXT;
  tbl.glTextureSubImage3DEXT = http_glTextureSubImage3DEXT;
  tbl.glUnmapNamedBufferEXT = http_glUnmapNamedBufferEXT;
  tbl.glVertexArrayColorOffsetEXT = http_glVertexArrayColorOffsetEXT;
  tbl.glVertexArrayEdgeFlagOffsetEXT = http_glVertexArrayEdgeFlagOffsetEXT;
  tbl.glVertexArrayFogCoordOffsetEXT = http_glVertexArrayFogCoordOffsetEXT;
  tbl.glVertexArrayIndexOffsetEXT = http_glVertexArrayIndexOffsetEXT;
  tbl.glVertexArrayMultiTexCoordOffsetEXT = http_glVertexArrayMultiTexCoordOffsetEXT;
  tbl.glVertexArrayNormalOffsetEXT = http_glVertexArrayNormalOffsetEXT;
  tbl.glVertexArraySecondaryColorOffsetEXT = http_glVertexArraySecondaryColorOffsetEXT;
  tbl.glVertexArrayTexCoordOffsetEXT = http_glVertexArrayTexCoordOffsetEXT;
  tbl.glVertexArrayVertexAttribIOffsetEXT = http_glVertexArrayVertexAttribIOffsetEXT;
  tbl.glVertexArrayVertexAttribOffsetEXT = http_glVertexArrayVertexAttribOffsetEXT;
  tbl.glVertexArrayVertexOffsetEXT = http_glVertexArrayVertexOffsetEXT;

  // GL_EXT_discard_framebuffer

  tbl.glDiscardFramebufferEXT = http_glDiscardFramebufferEXT;

  // GL_EXT_disjoint_timer_query

  tbl.glGetQueryObjectivEXT = http_glGetQueryObjectivEXT;
  tbl.glQueryCounterEXT = http_glQueryCounterEXT;

  // GL_EXT_draw_buffers2

  tbl.glColorMaskIndexedEXT = http_glColorMaskIndexedEXT;
  tbl.glDisableIndexedEXT = http_glDisableIndexedEXT;
  tbl.glEnableIndexedEXT = http_glEnableIndexedEXT;
  tbl.glGetBooleanIndexedvEXT = http_glGetBooleanIndexedvEXT;
  tbl.glGetIntegerIndexedvEXT = http_glGetIntegerIndexedvEXT;
  tbl.glIsEnabledIndexedEXT = http_glIsEnabledIndexedEXT;

  // GL_EXT_draw_instanced

  tbl.glDrawArraysInstancedEXT = http_glDrawArraysInstancedEXT;
  tbl.glDrawElementsInstancedEXT = http_glDrawElementsInstancedEXT;

  // GL_EXT_draw_range_elements

  tbl.glDrawRangeElementsEXT = http_glDrawRangeElementsEXT;

  // GL_EXT_fog_coord

  tbl.glFogCoordPointerEXT = http_glFogCoordPointerEXT;
  tbl.glFogCoorddEXT = http_glFogCoorddEXT;
  tbl.glFogCoorddvEXT = http_glFogCoorddvEXT;
  tbl.glFogCoordfEXT = http_glFogCoordfEXT;
  tbl.glFogCoordfvEXT = http_glFogCoordfvEXT;

  // GL_EXT_fragment_lighting

  tbl.glFragmentColorMaterialEXT = http_glFragmentColorMaterialEXT;
  tbl.glFragmentLightModelfEXT = http_glFragmentLightModelfEXT;
  tbl.glFragmentLightModelfvEXT = http_glFragmentLightModelfvEXT;
  tbl.glFragmentLightModeliEXT = http_glFragmentLightModeliEXT;
  tbl.glFragmentLightModelivEXT = http_glFragmentLightModelivEXT;
  tbl.glFragmentLightfEXT = http_glFragmentLightfEXT;
  tbl.glFragmentLightfvEXT = http_glFragmentLightfvEXT;
  tbl.glFragmentLightiEXT = http_glFragmentLightiEXT;
  tbl.glFragmentLightivEXT = http_glFragmentLightivEXT;
  tbl.glFragmentMaterialfEXT = http_glFragmentMaterialfEXT;
  tbl.glFragmentMaterialfvEXT = http_glFragmentMaterialfvEXT;
  tbl.glFragmentMaterialiEXT = http_glFragmentMaterialiEXT;
  tbl.glFragmentMaterialivEXT = http_glFragmentMaterialivEXT;
  tbl.glGetFragmentLightfvEXT = http_glGetFragmentLightfvEXT;
  tbl.glGetFragmentLightivEXT = http_glGetFragmentLightivEXT;
  tbl.glGetFragmentMaterialfvEXT = http_glGetFragmentMaterialfvEXT;
  tbl.glGetFragmentMaterialivEXT = http_glGetFragmentMaterialivEXT;
  tbl.glLightEnviEXT = http_glLightEnviEXT;

  // GL_EXT_framebuffer_blit

  tbl.glBlitFramebufferEXT = http_glBlitFramebufferEXT;

  // GL_EXT_framebuffer_multisample

  tbl.glRenderbufferStorageMultisampleEXT = http_glRenderbufferStorageMultisampleEXT;

  // GL_EXT_framebuffer_object

  tbl.glBindFramebufferEXT = http_glBindFramebufferEXT;
  tbl.glBindRenderbufferEXT = http_glBindRenderbufferEXT;
  tbl.glCheckFramebufferStatusEXT = http_glCheckFramebufferStatusEXT;
  tbl.glDeleteFramebuffersEXT = http_glDeleteFramebuffersEXT;
  tbl.glDeleteRenderbuffersEXT = http_glDeleteRenderbuffersEXT;
  tbl.glFramebufferRenderbufferEXT = http_glFramebufferRenderbufferEXT;
  tbl.glFramebufferTexture1DEXT = http_glFramebufferTexture1DEXT;
  tbl.glFramebufferTexture2DEXT = http_glFramebufferTexture2DEXT;
  tbl.glFramebufferTexture3DEXT = http_glFramebufferTexture3DEXT;
  tbl.glGenFramebuffersEXT = http_glGenFramebuffersEXT;
  tbl.glGenRenderbuffersEXT = http_glGenRenderbuffersEXT;
  tbl.glGenerateMipmapEXT = http_glGenerateMipmapEXT;
  tbl.glGetFramebufferAttachmentParameterivEXT = http_glGetFramebufferAttachmentParameterivEXT;
  tbl.glGetRenderbufferParameterivEXT = http_glGetRenderbufferParameterivEXT;
  tbl.glIsFramebufferEXT = http_glIsFramebufferEXT;
  tbl.glIsRenderbufferEXT = http_glIsRenderbufferEXT;
  tbl.glRenderbufferStorageEXT = http_glRenderbufferStorageEXT;

  // GL_EXT_geometry_shader4

  tbl.glFramebufferTextureEXT = http_glFramebufferTextureEXT;
  tbl.glFramebufferTextureFaceEXT = http_glFramebufferTextureFaceEXT;
  tbl.glProgramParameteriEXT = http_glProgramParameteriEXT;

  // GL_EXT_gpu_program_parameters

  tbl.glProgramEnvParameters4fvEXT = http_glProgramEnvParameters4fvEXT;
  tbl.glProgramLocalParameters4fvEXT = http_glProgramLocalParameters4fvEXT;

  // GL_EXT_gpu_shader4

  tbl.glBindFragDataLocationEXT = http_glBindFragDataLocationEXT;
  tbl.glGetFragDataLocationEXT = http_glGetFragDataLocationEXT;
  tbl.glGetUniformuivEXT = http_glGetUniformuivEXT;
  tbl.glGetVertexAttribIivEXT = http_glGetVertexAttribIivEXT;
  tbl.glGetVertexAttribIuivEXT = http_glGetVertexAttribIuivEXT;
  tbl.glUniform1uiEXT = http_glUniform1uiEXT;
  tbl.glUniform1uivEXT = http_glUniform1uivEXT;
  tbl.glUniform2uiEXT = http_glUniform2uiEXT;
  tbl.glUniform2uivEXT = http_glUniform2uivEXT;
  tbl.glUniform3uiEXT = http_glUniform3uiEXT;
  tbl.glUniform3uivEXT = http_glUniform3uivEXT;
  tbl.glUniform4uiEXT = http_glUniform4uiEXT;
  tbl.glUniform4uivEXT = http_glUniform4uivEXT;
  tbl.glVertexAttribI1iEXT = http_glVertexAttribI1iEXT;
  tbl.glVertexAttribI1ivEXT = http_glVertexAttribI1ivEXT;
  tbl.glVertexAttribI1uiEXT = http_glVertexAttribI1uiEXT;
  tbl.glVertexAttribI1uivEXT = http_glVertexAttribI1uivEXT;
  tbl.glVertexAttribI2iEXT = http_glVertexAttribI2iEXT;
  tbl.glVertexAttribI2ivEXT = http_glVertexAttribI2ivEXT;
  tbl.glVertexAttribI2uiEXT = http_glVertexAttribI2uiEXT;
  tbl.glVertexAttribI2uivEXT = http_glVertexAttribI2uivEXT;
  tbl.glVertexAttribI3iEXT = http_glVertexAttribI3iEXT;
  tbl.glVertexAttribI3ivEXT = http_glVertexAttribI3ivEXT;
  tbl.glVertexAttribI3uiEXT = http_glVertexAttribI3uiEXT;
  tbl.glVertexAttribI3uivEXT = http_glVertexAttribI3uivEXT;
  tbl.glVertexAttribI4bvEXT = http_glVertexAttribI4bvEXT;
  tbl.glVertexAttribI4iEXT = http_glVertexAttribI4iEXT;
  tbl.glVertexAttribI4ivEXT = http_glVertexAttribI4ivEXT;
  tbl.glVertexAttribI4svEXT = http_glVertexAttribI4svEXT;
  tbl.glVertexAttribI4ubvEXT = http_glVertexAttribI4ubvEXT;
  tbl.glVertexAttribI4uiEXT = http_glVertexAttribI4uiEXT;
  tbl.glVertexAttribI4uivEXT = http_glVertexAttribI4uivEXT;
  tbl.glVertexAttribI4usvEXT = http_glVertexAttribI4usvEXT;
  tbl.glVertexAttribIPointerEXT = http_glVertexAttribIPointerEXT;

  // GL_EXT_histogram

  tbl.glGetHistogramEXT = http_glGetHistogramEXT;
  tbl.glGetHistogramParameterfvEXT = http_glGetHistogramParameterfvEXT;
  tbl.glGetHistogramParameterivEXT = http_glGetHistogramParameterivEXT;
  tbl.glGetMinmaxEXT = http_glGetMinmaxEXT;
  tbl.glGetMinmaxParameterfvEXT = http_glGetMinmaxParameterfvEXT;
  tbl.glGetMinmaxParameterivEXT = http_glGetMinmaxParameterivEXT;
  tbl.glHistogramEXT = http_glHistogramEXT;
  tbl.glMinmaxEXT = http_glMinmaxEXT;
  tbl.glResetHistogramEXT = http_glResetHistogramEXT;
  tbl.glResetMinmaxEXT = http_glResetMinmaxEXT;

  // GL_EXT_index_func

  tbl.glIndexFuncEXT = http_glIndexFuncEXT;

  // GL_EXT_index_material

  tbl.glIndexMaterialEXT = http_glIndexMaterialEXT;

  // GL_EXT_light_texture

  tbl.glApplyTextureEXT = http_glApplyTextureEXT;
  tbl.glTextureLightEXT = http_glTextureLightEXT;
  tbl.glTextureMaterialEXT = http_glTextureMaterialEXT;

  // GL_EXT_map_buffer_range

  tbl.glFlushMappedBufferRangeEXT = http_glFlushMappedBufferRangeEXT;
  tbl.glMapBufferRangeEXT = http_glMapBufferRangeEXT;

  // GL_EXT_multi_draw_arrays

  tbl.glMultiDrawArraysEXT = http_glMultiDrawArraysEXT;
  tbl.glMultiDrawElementsEXT = http_glMultiDrawElementsEXT;

  // GL_EXT_multisample

  tbl.glSampleMaskEXT = http_glSampleMaskEXT;
  tbl.glSamplePatternEXT = http_glSamplePatternEXT;

  // GL_EXT_multisampled_render_to_texture

  tbl.glFramebufferTexture2DMultisampleEXT = http_glFramebufferTexture2DMultisampleEXT;

  // GL_EXT_multiview_draw_buffers

  tbl.glDrawBuffersIndexedEXT = http_glDrawBuffersIndexedEXT;
  tbl.glGetIntegeri_vEXT = http_glGetIntegeri_vEXT;
  tbl.glReadBufferIndexedEXT = http_glReadBufferIndexedEXT;

  // GL_EXT_occlusion_query_boolean

  tbl.glBeginQueryEXT = http_glBeginQueryEXT;
  tbl.glDeleteQueriesEXT = http_glDeleteQueriesEXT;
  tbl.glEndQueryEXT = http_glEndQueryEXT;
  tbl.glGenQueriesEXT = http_glGenQueriesEXT;
  tbl.glGetQueryObjectuivEXT = http_glGetQueryObjectuivEXT;
  tbl.glGetQueryivEXT = http_glGetQueryivEXT;
  tbl.glIsQueryEXT = http_glIsQueryEXT;

  // GL_EXT_paletted_texture

  tbl.glColorTableEXT = http_glColorTableEXT;
  tbl.glGetColorTableEXT = http_glGetColorTableEXT;
  tbl.glGetColorTableParameterfvEXT = http_glGetColorTableParameterfvEXT;
  tbl.glGetColorTableParameterivEXT = http_glGetColorTableParameterivEXT;

  // GL_EXT_pixel_transform

  tbl.glGetPixelTransformParameterfvEXT = http_glGetPixelTransformParameterfvEXT;
  tbl.glGetPixelTransformParameterivEXT = http_glGetPixelTransformParameterivEXT;
  tbl.glPixelTransformParameterfEXT = http_glPixelTransformParameterfEXT;
  tbl.glPixelTransformParameterfvEXT = http_glPixelTransformParameterfvEXT;
  tbl.glPixelTransformParameteriEXT = http_glPixelTransformParameteriEXT;
  tbl.glPixelTransformParameterivEXT = http_glPixelTransformParameterivEXT;

  // GL_EXT_point_parameters

  tbl.glPointParameterfEXT = http_glPointParameterfEXT;
  tbl.glPointParameterfvEXT = http_glPointParameterfvEXT;

  // GL_EXT_polygon_offset

  tbl.glPolygonOffsetEXT = http_glPolygonOffsetEXT;

  // GL_EXT_provoking_vertex

  tbl.glProvokingVertexEXT = http_glProvokingVertexEXT;

  // GL_EXT_robustness

  tbl.glGetnUniformfvEXT = http_glGetnUniformfvEXT;
  tbl.glGetnUniformivEXT = http_glGetnUniformivEXT;
  tbl.glReadnPixelsEXT = http_glReadnPixelsEXT;

  // GL_EXT_scene_marker

  tbl.glBeginSceneEXT = http_glBeginSceneEXT;
  tbl.glEndSceneEXT = http_glEndSceneEXT;

  // GL_EXT_secondary_color

  tbl.glSecondaryColor3bEXT = http_glSecondaryColor3bEXT;
  tbl.glSecondaryColor3bvEXT = http_glSecondaryColor3bvEXT;
  tbl.glSecondaryColor3dEXT = http_glSecondaryColor3dEXT;
  tbl.glSecondaryColor3dvEXT = http_glSecondaryColor3dvEXT;
  tbl.glSecondaryColor3fEXT = http_glSecondaryColor3fEXT;
  tbl.glSecondaryColor3fvEXT = http_glSecondaryColor3fvEXT;
  tbl.glSecondaryColor3iEXT = http_glSecondaryColor3iEXT;
  tbl.glSecondaryColor3ivEXT = http_glSecondaryColor3ivEXT;
  tbl.glSecondaryColor3sEXT = http_glSecondaryColor3sEXT;
  tbl.glSecondaryColor3svEXT = http_glSecondaryColor3svEXT;
  tbl.glSecondaryColor3ubEXT = http_glSecondaryColor3ubEXT;
  tbl.glSecondaryColor3ubvEXT = http_glSecondaryColor3ubvEXT;
  tbl.glSecondaryColor3uiEXT = http_glSecondaryColor3uiEXT;
  tbl.glSecondaryColor3uivEXT = http_glSecondaryColor3uivEXT;
  tbl.glSecondaryColor3usEXT = http_glSecondaryColor3usEXT;
  tbl.glSecondaryColor3usvEXT = http_glSecondaryColor3usvEXT;
  tbl.glSecondaryColorPointerEXT = http_glSecondaryColorPointerEXT;

  // GL_EXT_separate_shader_objects

  tbl.glActiveProgramEXT = http_glActiveProgramEXT;
  tbl.glCreateShaderProgramEXT = http_glCreateShaderProgramEXT;
  tbl.glUseShaderProgramEXT = http_glUseShaderProgramEXT;

  // GL_EXT_shader_image_load_store

  tbl.glBindImageTextureEXT = http_glBindImageTextureEXT;
  tbl.glMemoryBarrierEXT = http_glMemoryBarrierEXT;

  // GL_EXT_stencil_clear_tag

  tbl.glStencilClearTagEXT = http_glStencilClearTagEXT;

  // GL_EXT_stencil_two_side

  tbl.glActiveStencilFaceEXT = http_glActiveStencilFaceEXT;

  // GL_EXT_subtexture

  tbl.glTexSubImage1DEXT = http_glTexSubImage1DEXT;
  tbl.glTexSubImage2DEXT = http_glTexSubImage2DEXT;
  tbl.glTexSubImage3DEXT = http_glTexSubImage3DEXT;

  // GL_EXT_texture3D

  tbl.glTexImage3DEXT = http_glTexImage3DEXT;

  // GL_EXT_texture_array

  tbl.glFramebufferTextureLayerEXT = http_glFramebufferTextureLayerEXT;

  // GL_EXT_texture_buffer_object

  tbl.glTexBufferEXT = http_glTexBufferEXT;

  // GL_EXT_texture_integer

  tbl.glClearColorIiEXT = http_glClearColorIiEXT;
  tbl.glClearColorIuiEXT = http_glClearColorIuiEXT;
  tbl.glGetTexParameterIivEXT = http_glGetTexParameterIivEXT;
  tbl.glGetTexParameterIuivEXT = http_glGetTexParameterIuivEXT;
  tbl.glTexParameterIivEXT = http_glTexParameterIivEXT;
  tbl.glTexParameterIuivEXT = http_glTexParameterIuivEXT;

  // GL_EXT_texture_object

  tbl.glAreTexturesResidentEXT = http_glAreTexturesResidentEXT;
  tbl.glBindTextureEXT = http_glBindTextureEXT;
  tbl.glDeleteTexturesEXT = http_glDeleteTexturesEXT;
  tbl.glGenTexturesEXT = http_glGenTexturesEXT;
  tbl.glIsTextureEXT = http_glIsTextureEXT;
  tbl.glPrioritizeTexturesEXT = http_glPrioritizeTexturesEXT;

  // GL_EXT_texture_perturb_normal

  tbl.glTextureNormalEXT = http_glTextureNormalEXT;

  // GL_EXT_texture_storage

  tbl.glTexStorage1DEXT = http_glTexStorage1DEXT;
  tbl.glTexStorage2DEXT = http_glTexStorage2DEXT;
  tbl.glTexStorage3DEXT = http_glTexStorage3DEXT;

  // GL_EXT_timer_query

  tbl.glGetQueryObjecti64vEXT = http_glGetQueryObjecti64vEXT;
  tbl.glGetQueryObjectui64vEXT = http_glGetQueryObjectui64vEXT;

  // GL_EXT_transform_feedback

  tbl.glBeginTransformFeedbackEXT = http_glBeginTransformFeedbackEXT;
  tbl.glBindBufferBaseEXT = http_glBindBufferBaseEXT;
  tbl.glBindBufferOffsetEXT = http_glBindBufferOffsetEXT;
  tbl.glBindBufferRangeEXT = http_glBindBufferRangeEXT;
  tbl.glEndTransformFeedbackEXT = http_glEndTransformFeedbackEXT;
  tbl.glGetTransformFeedbackVaryingEXT = http_glGetTransformFeedbackVaryingEXT;
  tbl.glTransformFeedbackVaryingsEXT = http_glTransformFeedbackVaryingsEXT;

  // GL_EXT_vertex_array

  tbl.glArrayElementEXT = http_glArrayElementEXT;
  tbl.glColorPointerEXT = http_glColorPointerEXT;
  tbl.glDrawArraysEXT = http_glDrawArraysEXT;
  tbl.glEdgeFlagPointerEXT = http_glEdgeFlagPointerEXT;
  tbl.glGetPointervEXT = http_glGetPointervEXT;
  tbl.glIndexPointerEXT = http_glIndexPointerEXT;
  tbl.glNormalPointerEXT = http_glNormalPointerEXT;
  tbl.glTexCoordPointerEXT = http_glTexCoordPointerEXT;
  tbl.glVertexPointerEXT = http_glVertexPointerEXT;

  // GL_EXT_vertex_attrib_64bit

  tbl.glGetVertexAttribLdvEXT = http_glGetVertexAttribLdvEXT;
  tbl.glVertexArrayVertexAttribLOffsetEXT = http_glVertexArrayVertexAttribLOffsetEXT;
  tbl.glVertexAttribL1dEXT = http_glVertexAttribL1dEXT;
  tbl.glVertexAttribL1dvEXT = http_glVertexAttribL1dvEXT;
  tbl.glVertexAttribL2dEXT = http_glVertexAttribL2dEXT;
  tbl.glVertexAttribL2dvEXT = http_glVertexAttribL2dvEXT;
  tbl.glVertexAttribL3dEXT = http_glVertexAttribL3dEXT;
  tbl.glVertexAttribL3dvEXT = http_glVertexAttribL3dvEXT;
  tbl.glVertexAttribL4dEXT = http_glVertexAttribL4dEXT;
  tbl.glVertexAttribL4dvEXT = http_glVertexAttribL4dvEXT;
  tbl.glVertexAttribLPointerEXT = http_glVertexAttribLPointerEXT;

  // GL_EXT_vertex_shader

  tbl.glBeginVertexShaderEXT = http_glBeginVertexShaderEXT;
  tbl.glBindLightParameterEXT = http_glBindLightParameterEXT;
  tbl.glBindMaterialParameterEXT = http_glBindMaterialParameterEXT;
  tbl.glBindParameterEXT = http_glBindParameterEXT;
  tbl.glBindTexGenParameterEXT = http_glBindTexGenParameterEXT;
  tbl.glBindTextureUnitParameterEXT = http_glBindTextureUnitParameterEXT;
  tbl.glBindVertexShaderEXT = http_glBindVertexShaderEXT;
  tbl.glDeleteVertexShaderEXT = http_glDeleteVertexShaderEXT;
  tbl.glDisableVariantClientStateEXT = http_glDisableVariantClientStateEXT;
  tbl.glEnableVariantClientStateEXT = http_glEnableVariantClientStateEXT;
  tbl.glEndVertexShaderEXT = http_glEndVertexShaderEXT;
  tbl.glExtractComponentEXT = http_glExtractComponentEXT;
  tbl.glGenSymbolsEXT = http_glGenSymbolsEXT;
  tbl.glGenVertexShadersEXT = http_glGenVertexShadersEXT;
  tbl.glGetInvariantBooleanvEXT = http_glGetInvariantBooleanvEXT;
  tbl.glGetInvariantFloatvEXT = http_glGetInvariantFloatvEXT;
  tbl.glGetInvariantIntegervEXT = http_glGetInvariantIntegervEXT;
  tbl.glGetLocalConstantBooleanvEXT = http_glGetLocalConstantBooleanvEXT;
  tbl.glGetLocalConstantFloatvEXT = http_glGetLocalConstantFloatvEXT;
  tbl.glGetLocalConstantIntegervEXT = http_glGetLocalConstantIntegervEXT;
  tbl.glGetVariantBooleanvEXT = http_glGetVariantBooleanvEXT;
  tbl.glGetVariantFloatvEXT = http_glGetVariantFloatvEXT;
  tbl.glGetVariantIntegervEXT = http_glGetVariantIntegervEXT;
  tbl.glGetVariantPointervEXT = http_glGetVariantPointervEXT;
  tbl.glInsertComponentEXT = http_glInsertComponentEXT;
  tbl.glIsVariantEnabledEXT = http_glIsVariantEnabledEXT;
  tbl.glSetInvariantEXT = http_glSetInvariantEXT;
  tbl.glSetLocalConstantEXT = http_glSetLocalConstantEXT;
  tbl.glShaderOp1EXT = http_glShaderOp1EXT;
  tbl.glShaderOp2EXT = http_glShaderOp2EXT;
  tbl.glShaderOp3EXT = http_glShaderOp3EXT;
  tbl.glSwizzleEXT = http_glSwizzleEXT;
  tbl.glVariantPointerEXT = http_glVariantPointerEXT;
  tbl.glVariantbvEXT = http_glVariantbvEXT;
  tbl.glVariantdvEXT = http_glVariantdvEXT;
  tbl.glVariantfvEXT = http_glVariantfvEXT;
  tbl.glVariantivEXT = http_glVariantivEXT;
  tbl.glVariantsvEXT = http_glVariantsvEXT;
  tbl.glVariantubvEXT = http_glVariantubvEXT;
  tbl.glVariantuivEXT = http_glVariantuivEXT;
  tbl.glVariantusvEXT = http_glVariantusvEXT;
  tbl.glWriteMaskEXT = http_glWriteMaskEXT;

  // GL_EXT_vertex_weighting

  tbl.glVertexWeightPointerEXT = http_glVertexWeightPointerEXT;
  tbl.glVertexWeightfEXT = http_glVertexWeightfEXT;
  tbl.glVertexWeightfvEXT = http_glVertexWeightfvEXT;

  // GL_EXT_x11_sync_object

  tbl.glImportSyncEXT = http_glImportSyncEXT;

  // GL_GREMEDY_frame_terminator

  tbl.glFrameTerminatorGREMEDY = http_glFrameTerminatorGREMEDY;

  // GL_GREMEDY_string_marker

  tbl.glStringMarkerGREMEDY = http_glStringMarkerGREMEDY;

  // GL_HP_image_transform

  tbl.glGetImageTransformParameterfvHP = http_glGetImageTransformParameterfvHP;
  tbl.glGetImageTransformParameterivHP = http_glGetImageTransformParameterivHP;
  tbl.glImageTransformParameterfHP = http_glImageTransformParameterfHP;
  tbl.glImageTransformParameterfvHP = http_glImageTransformParameterfvHP;
  tbl.glImageTransformParameteriHP = http_glImageTransformParameteriHP;
  tbl.glImageTransformParameterivHP = http_glImageTransformParameterivHP;

  // GL_IBM_multimode_draw_arrays

  tbl.glMultiModeDrawArraysIBM = http_glMultiModeDrawArraysIBM;
  tbl.glMultiModeDrawElementsIBM = http_glMultiModeDrawElementsIBM;

  // GL_IBM_vertex_array_lists

  tbl.glColorPointerListIBM = http_glColorPointerListIBM;
  tbl.glEdgeFlagPointerListIBM = http_glEdgeFlagPointerListIBM;
  tbl.glFogCoordPointerListIBM = http_glFogCoordPointerListIBM;
  tbl.glIndexPointerListIBM = http_glIndexPointerListIBM;
  tbl.glNormalPointerListIBM = http_glNormalPointerListIBM;
  tbl.glSecondaryColorPointerListIBM = http_glSecondaryColorPointerListIBM;
  tbl.glTexCoordPointerListIBM = http_glTexCoordPointerListIBM;
  tbl.glVertexPointerListIBM = http_glVertexPointerListIBM;

  // GL_IMG_multisampled_render_to_texture

  tbl.glFramebufferTexture2DMultisampleIMG = http_glFramebufferTexture2DMultisampleIMG;
  tbl.glRenderbufferStorageMultisampleIMG = http_glRenderbufferStorageMultisampleIMG;

  // GL_INGR_blend_func_separate

  tbl.glBlendFuncSeparateINGR = http_glBlendFuncSeparateINGR;

  // GL_INTEL_map_texture

  tbl.glMapTexture2DINTEL = http_glMapTexture2DINTEL;
  tbl.glSyncTextureINTEL = http_glSyncTextureINTEL;
  tbl.glUnmapTexture2DINTEL = http_glUnmapTexture2DINTEL;

  // GL_INTEL_parallel_arrays

  tbl.glColorPointervINTEL = http_glColorPointervINTEL;
  tbl.glNormalPointervINTEL = http_glNormalPointervINTEL;
  tbl.glTexCoordPointervINTEL = http_glTexCoordPointervINTEL;
  tbl.glVertexPointervINTEL = http_glVertexPointervINTEL;

  // GL_INTEL_texture_scissor

  tbl.glTexScissorFuncINTEL = http_glTexScissorFuncINTEL;
  tbl.glTexScissorINTEL = http_glTexScissorINTEL;

  // GL_KHR_blend_equation_advanced

  tbl.glBlendBarrierKHR = http_glBlendBarrierKHR;

  // GL_KHR_debug

  tbl.glDebugMessageCallback = http_glDebugMessageCallback;
  tbl.glDebugMessageControl = http_glDebugMessageControl;
  tbl.glDebugMessageInsert = http_glDebugMessageInsert;
  tbl.glGetDebugMessageLog = http_glGetDebugMessageLog;
  tbl.glGetObjectLabel = http_glGetObjectLabel;
  tbl.glGetObjectPtrLabel = http_glGetObjectPtrLabel;
  tbl.glObjectLabel = http_glObjectLabel;
  tbl.glObjectPtrLabel = http_glObjectPtrLabel;
  tbl.glPopDebugGroup = http_glPopDebugGroup;
  tbl.glPushDebugGroup = http_glPushDebugGroup;

  // GL_KHR_robustness

  tbl.glGetnUniformfv = http_glGetnUniformfv;
  tbl.glGetnUniformiv = http_glGetnUniformiv;
  tbl.glGetnUniformuiv = http_glGetnUniformuiv;
  tbl.glReadnPixels = http_glReadnPixels;

  // GL_KTX_buffer_region

  tbl.glBufferRegionEnabled = http_glBufferRegionEnabled;
  tbl.glDeleteBufferRegion = http_glDeleteBufferRegion;
  tbl.glDrawBufferRegion = http_glDrawBufferRegion;
  tbl.glNewBufferRegion = http_glNewBufferRegion;
  tbl.glReadBufferRegion = http_glReadBufferRegion;

  // GL_MESA_resize_buffers

  tbl.glResizeBuffersMESA = http_glResizeBuffersMESA;

  // GL_MESA_window_pos

  tbl.glWindowPos2dMESA = http_glWindowPos2dMESA;
  tbl.glWindowPos2dvMESA = http_glWindowPos2dvMESA;
  tbl.glWindowPos2fMESA = http_glWindowPos2fMESA;
  tbl.glWindowPos2fvMESA = http_glWindowPos2fvMESA;
  tbl.glWindowPos2iMESA = http_glWindowPos2iMESA;
  tbl.glWindowPos2ivMESA = http_glWindowPos2ivMESA;
  tbl.glWindowPos2sMESA = http_glWindowPos2sMESA;
  tbl.glWindowPos2svMESA = http_glWindowPos2svMESA;
  tbl.glWindowPos3dMESA = http_glWindowPos3dMESA;
  tbl.glWindowPos3dvMESA = http_glWindowPos3dvMESA;
  tbl.glWindowPos3fMESA = http_glWindowPos3fMESA;
  tbl.glWindowPos3fvMESA = http_glWindowPos3fvMESA;
  tbl.glWindowPos3iMESA = http_glWindowPos3iMESA;
  tbl.glWindowPos3ivMESA = http_glWindowPos3ivMESA;
  tbl.glWindowPos3sMESA = http_glWindowPos3sMESA;
  tbl.glWindowPos3svMESA = http_glWindowPos3svMESA;
  tbl.glWindowPos4dMESA = http_glWindowPos4dMESA;
  tbl.glWindowPos4dvMESA = http_glWindowPos4dvMESA;
  tbl.glWindowPos4fMESA = http_glWindowPos4fMESA;
  tbl.glWindowPos4fvMESA = http_glWindowPos4fvMESA;
  tbl.glWindowPos4iMESA = http_glWindowPos4iMESA;
  tbl.glWindowPos4ivMESA = http_glWindowPos4ivMESA;
  tbl.glWindowPos4sMESA = http_glWindowPos4sMESA;
  tbl.glWindowPos4svMESA = http_glWindowPos4svMESA;

  // GL_NVX_conditional_render

  tbl.glBeginConditionalRenderNVX = http_glBeginConditionalRenderNVX;
  tbl.glEndConditionalRenderNVX = http_glEndConditionalRenderNVX;

  // GL_NV_bindless_texture

  tbl.glGetImageHandleNV = http_glGetImageHandleNV;
  tbl.glGetTextureHandleNV = http_glGetTextureHandleNV;
  tbl.glGetTextureSamplerHandleNV = http_glGetTextureSamplerHandleNV;
  tbl.glIsImageHandleResidentNV = http_glIsImageHandleResidentNV;
  tbl.glIsTextureHandleResidentNV = http_glIsTextureHandleResidentNV;
  tbl.glMakeImageHandleNonResidentNV = http_glMakeImageHandleNonResidentNV;
  tbl.glMakeImageHandleResidentNV = http_glMakeImageHandleResidentNV;
  tbl.glMakeTextureHandleNonResidentNV = http_glMakeTextureHandleNonResidentNV;
  tbl.glMakeTextureHandleResidentNV = http_glMakeTextureHandleResidentNV;
  tbl.glProgramUniformHandleui64NV = http_glProgramUniformHandleui64NV;
  tbl.glProgramUniformHandleui64vNV = http_glProgramUniformHandleui64vNV;
  tbl.glUniformHandleui64NV = http_glUniformHandleui64NV;
  tbl.glUniformHandleui64vNV = http_glUniformHandleui64vNV;

  // GL_NV_blend_equation_advanced

  tbl.glBlendBarrierNV = http_glBlendBarrierNV;
  tbl.glBlendParameteriNV = http_glBlendParameteriNV;

  // GL_NV_conditional_render

  tbl.glBeginConditionalRenderNV = http_glBeginConditionalRenderNV;
  tbl.glEndConditionalRenderNV = http_glEndConditionalRenderNV;

  // GL_NV_copy_buffer

  tbl.glCopyBufferSubDataNV = http_glCopyBufferSubDataNV;

  // GL_NV_copy_image

  tbl.glCopyImageSubDataNV = http_glCopyImageSubDataNV;

  // GL_NV_coverage_sample

  tbl.glCoverageMaskNV = http_glCoverageMaskNV;
  tbl.glCoverageOperationNV = http_glCoverageOperationNV;

  // GL_NV_depth_buffer_float

  tbl.glClearDepthdNV = http_glClearDepthdNV;
  tbl.glDepthBoundsdNV = http_glDepthBoundsdNV;
  tbl.glDepthRangedNV = http_glDepthRangedNV;

  // GL_NV_draw_buffers

  tbl.glDrawBuffersNV = http_glDrawBuffersNV;

  // GL_NV_draw_texture

  tbl.glDrawTextureNV = http_glDrawTextureNV;

  // GL_NV_evaluators

  tbl.glEvalMapsNV = http_glEvalMapsNV;
  tbl.glGetMapAttribParameterfvNV = http_glGetMapAttribParameterfvNV;
  tbl.glGetMapAttribParameterivNV = http_glGetMapAttribParameterivNV;
  tbl.glGetMapControlPointsNV = http_glGetMapControlPointsNV;
  tbl.glGetMapParameterfvNV = http_glGetMapParameterfvNV;
  tbl.glGetMapParameterivNV = http_glGetMapParameterivNV;
  tbl.glMapControlPointsNV = http_glMapControlPointsNV;
  tbl.glMapParameterfvNV = http_glMapParameterfvNV;
  tbl.glMapParameterivNV = http_glMapParameterivNV;

  // GL_NV_explicit_multisample

  tbl.glGetMultisamplefvNV = http_glGetMultisamplefvNV;
  tbl.glSampleMaskIndexedNV = http_glSampleMaskIndexedNV;
  tbl.glTexRenderbufferNV = http_glTexRenderbufferNV;

  // GL_NV_fence

  tbl.glDeleteFencesNV = http_glDeleteFencesNV;
  tbl.glFinishFenceNV = http_glFinishFenceNV;
  tbl.glGenFencesNV = http_glGenFencesNV;
  tbl.glGetFenceivNV = http_glGetFenceivNV;
  tbl.glIsFenceNV = http_glIsFenceNV;
  tbl.glSetFenceNV = http_glSetFenceNV;
  tbl.glTestFenceNV = http_glTestFenceNV;

  // GL_NV_fragment_program

  tbl.glGetProgramNamedParameterdvNV = http_glGetProgramNamedParameterdvNV;
  tbl.glGetProgramNamedParameterfvNV = http_glGetProgramNamedParameterfvNV;
  tbl.glProgramNamedParameter4dNV = http_glProgramNamedParameter4dNV;
  tbl.glProgramNamedParameter4dvNV = http_glProgramNamedParameter4dvNV;
  tbl.glProgramNamedParameter4fNV = http_glProgramNamedParameter4fNV;
  tbl.glProgramNamedParameter4fvNV = http_glProgramNamedParameter4fvNV;

  // GL_NV_framebuffer_blit

  tbl.glBlitFramebufferNV = http_glBlitFramebufferNV;

  // GL_NV_framebuffer_multisample_coverage

  tbl.glRenderbufferStorageMultisampleCoverageNV = http_glRenderbufferStorageMultisampleCoverageNV;

  // GL_NV_geometry_program4

  tbl.glProgramVertexLimitNV = http_glProgramVertexLimitNV;

  // GL_NV_gpu_program4

  tbl.glGetProgramEnvParameterIivNV = http_glGetProgramEnvParameterIivNV;
  tbl.glGetProgramEnvParameterIuivNV = http_glGetProgramEnvParameterIuivNV;
  tbl.glGetProgramLocalParameterIivNV = http_glGetProgramLocalParameterIivNV;
  tbl.glGetProgramLocalParameterIuivNV = http_glGetProgramLocalParameterIuivNV;
  tbl.glProgramEnvParameterI4iNV = http_glProgramEnvParameterI4iNV;
  tbl.glProgramEnvParameterI4ivNV = http_glProgramEnvParameterI4ivNV;
  tbl.glProgramEnvParameterI4uiNV = http_glProgramEnvParameterI4uiNV;
  tbl.glProgramEnvParameterI4uivNV = http_glProgramEnvParameterI4uivNV;
  tbl.glProgramEnvParametersI4ivNV = http_glProgramEnvParametersI4ivNV;
  tbl.glProgramEnvParametersI4uivNV = http_glProgramEnvParametersI4uivNV;
  tbl.glProgramLocalParameterI4iNV = http_glProgramLocalParameterI4iNV;
  tbl.glProgramLocalParameterI4ivNV = http_glProgramLocalParameterI4ivNV;
  tbl.glProgramLocalParameterI4uiNV = http_glProgramLocalParameterI4uiNV;
  tbl.glProgramLocalParameterI4uivNV = http_glProgramLocalParameterI4uivNV;
  tbl.glProgramLocalParametersI4ivNV = http_glProgramLocalParametersI4ivNV;
  tbl.glProgramLocalParametersI4uivNV = http_glProgramLocalParametersI4uivNV;

  // GL_NV_gpu_shader5

  tbl.glGetUniformi64vNV = http_glGetUniformi64vNV;
  tbl.glProgramUniform1i64NV = http_glProgramUniform1i64NV;
  tbl.glProgramUniform1i64vNV = http_glProgramUniform1i64vNV;
  tbl.glProgramUniform1ui64NV = http_glProgramUniform1ui64NV;
  tbl.glProgramUniform1ui64vNV = http_glProgramUniform1ui64vNV;
  tbl.glProgramUniform2i64NV = http_glProgramUniform2i64NV;
  tbl.glProgramUniform2i64vNV = http_glProgramUniform2i64vNV;
  tbl.glProgramUniform2ui64NV = http_glProgramUniform2ui64NV;
  tbl.glProgramUniform2ui64vNV = http_glProgramUniform2ui64vNV;
  tbl.glProgramUniform3i64NV = http_glProgramUniform3i64NV;
  tbl.glProgramUniform3i64vNV = http_glProgramUniform3i64vNV;
  tbl.glProgramUniform3ui64NV = http_glProgramUniform3ui64NV;
  tbl.glProgramUniform3ui64vNV = http_glProgramUniform3ui64vNV;
  tbl.glProgramUniform4i64NV = http_glProgramUniform4i64NV;
  tbl.glProgramUniform4i64vNV = http_glProgramUniform4i64vNV;
  tbl.glProgramUniform4ui64NV = http_glProgramUniform4ui64NV;
  tbl.glProgramUniform4ui64vNV = http_glProgramUniform4ui64vNV;
  tbl.glUniform1i64NV = http_glUniform1i64NV;
  tbl.glUniform1i64vNV = http_glUniform1i64vNV;
  tbl.glUniform1ui64NV = http_glUniform1ui64NV;
  tbl.glUniform1ui64vNV = http_glUniform1ui64vNV;
  tbl.glUniform2i64NV = http_glUniform2i64NV;
  tbl.glUniform2i64vNV = http_glUniform2i64vNV;
  tbl.glUniform2ui64NV = http_glUniform2ui64NV;
  tbl.glUniform2ui64vNV = http_glUniform2ui64vNV;
  tbl.glUniform3i64NV = http_glUniform3i64NV;
  tbl.glUniform3i64vNV = http_glUniform3i64vNV;
  tbl.glUniform3ui64NV = http_glUniform3ui64NV;
  tbl.glUniform3ui64vNV = http_glUniform3ui64vNV;
  tbl.glUniform4i64NV = http_glUniform4i64NV;
  tbl.glUniform4i64vNV = http_glUniform4i64vNV;
  tbl.glUniform4ui64NV = http_glUniform4ui64NV;
  tbl.glUniform4ui64vNV = http_glUniform4ui64vNV;

  // GL_NV_half_float

  tbl.glColor3hNV = http_glColor3hNV;
  tbl.glColor3hvNV = http_glColor3hvNV;
  tbl.glColor4hNV = http_glColor4hNV;
  tbl.glColor4hvNV = http_glColor4hvNV;
  tbl.glFogCoordhNV = http_glFogCoordhNV;
  tbl.glFogCoordhvNV = http_glFogCoordhvNV;
  tbl.glMultiTexCoord1hNV = http_glMultiTexCoord1hNV;
  tbl.glMultiTexCoord1hvNV = http_glMultiTexCoord1hvNV;
  tbl.glMultiTexCoord2hNV = http_glMultiTexCoord2hNV;
  tbl.glMultiTexCoord2hvNV = http_glMultiTexCoord2hvNV;
  tbl.glMultiTexCoord3hNV = http_glMultiTexCoord3hNV;
  tbl.glMultiTexCoord3hvNV = http_glMultiTexCoord3hvNV;
  tbl.glMultiTexCoord4hNV = http_glMultiTexCoord4hNV;
  tbl.glMultiTexCoord4hvNV = http_glMultiTexCoord4hvNV;
  tbl.glNormal3hNV = http_glNormal3hNV;
  tbl.glNormal3hvNV = http_glNormal3hvNV;
  tbl.glSecondaryColor3hNV = http_glSecondaryColor3hNV;
  tbl.glSecondaryColor3hvNV = http_glSecondaryColor3hvNV;
  tbl.glTexCoord1hNV = http_glTexCoord1hNV;
  tbl.glTexCoord1hvNV = http_glTexCoord1hvNV;
  tbl.glTexCoord2hNV = http_glTexCoord2hNV;
  tbl.glTexCoord2hvNV = http_glTexCoord2hvNV;
  tbl.glTexCoord3hNV = http_glTexCoord3hNV;
  tbl.glTexCoord3hvNV = http_glTexCoord3hvNV;
  tbl.glTexCoord4hNV = http_glTexCoord4hNV;
  tbl.glTexCoord4hvNV = http_glTexCoord4hvNV;
  tbl.glVertex2hNV = http_glVertex2hNV;
  tbl.glVertex2hvNV = http_glVertex2hvNV;
  tbl.glVertex3hNV = http_glVertex3hNV;
  tbl.glVertex3hvNV = http_glVertex3hvNV;
  tbl.glVertex4hNV = http_glVertex4hNV;
  tbl.glVertex4hvNV = http_glVertex4hvNV;
  tbl.glVertexAttrib1hNV = http_glVertexAttrib1hNV;
  tbl.glVertexAttrib1hvNV = http_glVertexAttrib1hvNV;
  tbl.glVertexAttrib2hNV = http_glVertexAttrib2hNV;
  tbl.glVertexAttrib2hvNV = http_glVertexAttrib2hvNV;
  tbl.glVertexAttrib3hNV = http_glVertexAttrib3hNV;
  tbl.glVertexAttrib3hvNV = http_glVertexAttrib3hvNV;
  tbl.glVertexAttrib4hNV = http_glVertexAttrib4hNV;
  tbl.glVertexAttrib4hvNV = http_glVertexAttrib4hvNV;
  tbl.glVertexAttribs1hvNV = http_glVertexAttribs1hvNV;
  tbl.glVertexAttribs2hvNV = http_glVertexAttribs2hvNV;
  tbl.glVertexAttribs3hvNV = http_glVertexAttribs3hvNV;
  tbl.glVertexAttribs4hvNV = http_glVertexAttribs4hvNV;
  tbl.glVertexWeighthNV = http_glVertexWeighthNV;
  tbl.glVertexWeighthvNV = http_glVertexWeighthvNV;

  // GL_NV_non_square_matrices

  tbl.glUniformMatrix2x3fvNV = http_glUniformMatrix2x3fvNV;
  tbl.glUniformMatrix2x4fvNV = http_glUniformMatrix2x4fvNV;
  tbl.glUniformMatrix3x2fvNV = http_glUniformMatrix3x2fvNV;
  tbl.glUniformMatrix3x4fvNV = http_glUniformMatrix3x4fvNV;
  tbl.glUniformMatrix4x2fvNV = http_glUniformMatrix4x2fvNV;
  tbl.glUniformMatrix4x3fvNV = http_glUniformMatrix4x3fvNV;

  // GL_NV_occlusion_query

  tbl.glBeginOcclusionQueryNV = http_glBeginOcclusionQueryNV;
  tbl.glDeleteOcclusionQueriesNV = http_glDeleteOcclusionQueriesNV;
  tbl.glEndOcclusionQueryNV = http_glEndOcclusionQueryNV;
  tbl.glGenOcclusionQueriesNV = http_glGenOcclusionQueriesNV;
  tbl.glGetOcclusionQueryivNV = http_glGetOcclusionQueryivNV;
  tbl.glGetOcclusionQueryuivNV = http_glGetOcclusionQueryuivNV;
  tbl.glIsOcclusionQueryNV = http_glIsOcclusionQueryNV;

  // GL_NV_parameter_buffer_object

  tbl.glProgramBufferParametersIivNV = http_glProgramBufferParametersIivNV;
  tbl.glProgramBufferParametersIuivNV = http_glProgramBufferParametersIuivNV;
  tbl.glProgramBufferParametersfvNV = http_glProgramBufferParametersfvNV;

  // GL_NV_path_rendering

  tbl.glCopyPathNV = http_glCopyPathNV;
  tbl.glCoverFillPathInstancedNV = http_glCoverFillPathInstancedNV;
  tbl.glCoverFillPathNV = http_glCoverFillPathNV;
  tbl.glCoverStrokePathInstancedNV = http_glCoverStrokePathInstancedNV;
  tbl.glCoverStrokePathNV = http_glCoverStrokePathNV;
  tbl.glDeletePathsNV = http_glDeletePathsNV;
  tbl.glGenPathsNV = http_glGenPathsNV;
  tbl.glGetPathColorGenfvNV = http_glGetPathColorGenfvNV;
  tbl.glGetPathColorGenivNV = http_glGetPathColorGenivNV;
  tbl.glGetPathCommandsNV = http_glGetPathCommandsNV;
  tbl.glGetPathCoordsNV = http_glGetPathCoordsNV;
  tbl.glGetPathDashArrayNV = http_glGetPathDashArrayNV;
  tbl.glGetPathLengthNV = http_glGetPathLengthNV;
  tbl.glGetPathMetricRangeNV = http_glGetPathMetricRangeNV;
  tbl.glGetPathMetricsNV = http_glGetPathMetricsNV;
  tbl.glGetPathParameterfvNV = http_glGetPathParameterfvNV;
  tbl.glGetPathParameterivNV = http_glGetPathParameterivNV;
  tbl.glGetPathSpacingNV = http_glGetPathSpacingNV;
  tbl.glGetPathTexGenfvNV = http_glGetPathTexGenfvNV;
  tbl.glGetPathTexGenivNV = http_glGetPathTexGenivNV;
  tbl.glInterpolatePathsNV = http_glInterpolatePathsNV;
  tbl.glIsPathNV = http_glIsPathNV;
  tbl.glIsPointInFillPathNV = http_glIsPointInFillPathNV;
  tbl.glIsPointInStrokePathNV = http_glIsPointInStrokePathNV;
  tbl.glPathColorGenNV = http_glPathColorGenNV;
  tbl.glPathCommandsNV = http_glPathCommandsNV;
  tbl.glPathCoordsNV = http_glPathCoordsNV;
  tbl.glPathCoverDepthFuncNV = http_glPathCoverDepthFuncNV;
  tbl.glPathDashArrayNV = http_glPathDashArrayNV;
  tbl.glPathFogGenNV = http_glPathFogGenNV;
  tbl.glPathGlyphRangeNV = http_glPathGlyphRangeNV;
  tbl.glPathGlyphsNV = http_glPathGlyphsNV;
  tbl.glPathParameterfNV = http_glPathParameterfNV;
  tbl.glPathParameterfvNV = http_glPathParameterfvNV;
  tbl.glPathParameteriNV = http_glPathParameteriNV;
  tbl.glPathParameterivNV = http_glPathParameterivNV;
  tbl.glPathStencilDepthOffsetNV = http_glPathStencilDepthOffsetNV;
  tbl.glPathStencilFuncNV = http_glPathStencilFuncNV;
  tbl.glPathStringNV = http_glPathStringNV;
  tbl.glPathSubCommandsNV = http_glPathSubCommandsNV;
  tbl.glPathSubCoordsNV = http_glPathSubCoordsNV;
  tbl.glPathTexGenNV = http_glPathTexGenNV;
  tbl.glPointAlongPathNV = http_glPointAlongPathNV;
  tbl.glStencilFillPathInstancedNV = http_glStencilFillPathInstancedNV;
  tbl.glStencilFillPathNV = http_glStencilFillPathNV;
  tbl.glStencilStrokePathInstancedNV = http_glStencilStrokePathInstancedNV;
  tbl.glStencilStrokePathNV = http_glStencilStrokePathNV;
  tbl.glTransformPathNV = http_glTransformPathNV;
  tbl.glWeightPathsNV = http_glWeightPathsNV;

  // GL_NV_pixel_data_range

  tbl.glFlushPixelDataRangeNV = http_glFlushPixelDataRangeNV;
  tbl.glPixelDataRangeNV = http_glPixelDataRangeNV;

  // GL_NV_point_sprite

  tbl.glPointParameteriNV = http_glPointParameteriNV;
  tbl.glPointParameterivNV = http_glPointParameterivNV;

  // GL_NV_present_video

  tbl.glGetVideoi64vNV = http_glGetVideoi64vNV;
  tbl.glGetVideoivNV = http_glGetVideoivNV;
  tbl.glGetVideoui64vNV = http_glGetVideoui64vNV;
  tbl.glGetVideouivNV = http_glGetVideouivNV;
  tbl.glPresentFrameDualFillNV = http_glPresentFrameDualFillNV;
  tbl.glPresentFrameKeyedNV = http_glPresentFrameKeyedNV;

  // GL_NV_primitive_restart

  tbl.glPrimitiveRestartIndexNV = http_glPrimitiveRestartIndexNV;
  tbl.glPrimitiveRestartNV = http_glPrimitiveRestartNV;

  // GL_NV_read_buffer

  tbl.glReadBufferNV = http_glReadBufferNV;

  // GL_NV_register_combiners

  tbl.glCombinerInputNV = http_glCombinerInputNV;
  tbl.glCombinerOutputNV = http_glCombinerOutputNV;
  tbl.glCombinerParameterfNV = http_glCombinerParameterfNV;
  tbl.glCombinerParameterfvNV = http_glCombinerParameterfvNV;
  tbl.glCombinerParameteriNV = http_glCombinerParameteriNV;
  tbl.glCombinerParameterivNV = http_glCombinerParameterivNV;
  tbl.glFinalCombinerInputNV = http_glFinalCombinerInputNV;
  tbl.glGetCombinerInputParameterfvNV = http_glGetCombinerInputParameterfvNV;
  tbl.glGetCombinerInputParameterivNV = http_glGetCombinerInputParameterivNV;
  tbl.glGetCombinerOutputParameterfvNV = http_glGetCombinerOutputParameterfvNV;
  tbl.glGetCombinerOutputParameterivNV = http_glGetCombinerOutputParameterivNV;
  tbl.glGetFinalCombinerInputParameterfvNV = http_glGetFinalCombinerInputParameterfvNV;
  tbl.glGetFinalCombinerInputParameterivNV = http_glGetFinalCombinerInputParameterivNV;

  // GL_NV_register_combiners2

  tbl.glCombinerStageParameterfvNV = http_glCombinerStageParameterfvNV;
  tbl.glGetCombinerStageParameterfvNV = http_glGetCombinerStageParameterfvNV;

  // GL_NV_shader_buffer_load

  tbl.glGetBufferParameterui64vNV = http_glGetBufferParameterui64vNV;
  tbl.glGetIntegerui64vNV = http_glGetIntegerui64vNV;
  tbl.glGetNamedBufferParameterui64vNV = http_glGetNamedBufferParameterui64vNV;
  tbl.glGetUniformui64vNV = http_glGetUniformui64vNV;
  tbl.glIsBufferResidentNV = http_glIsBufferResidentNV;
  tbl.glIsNamedBufferResidentNV = http_glIsNamedBufferResidentNV;
  tbl.glMakeBufferNonResidentNV = http_glMakeBufferNonResidentNV;
  tbl.glMakeBufferResidentNV = http_glMakeBufferResidentNV;
  tbl.glMakeNamedBufferNonResidentNV = http_glMakeNamedBufferNonResidentNV;
  tbl.glMakeNamedBufferResidentNV = http_glMakeNamedBufferResidentNV;
  tbl.glProgramUniformui64NV = http_glProgramUniformui64NV;
  tbl.glProgramUniformui64vNV = http_glProgramUniformui64vNV;
  tbl.glUniformui64NV = http_glUniformui64NV;
  tbl.glUniformui64vNV = http_glUniformui64vNV;

  // GL_NV_texture_barrier

  tbl.glTextureBarrierNV = http_glTextureBarrierNV;

  // GL_NV_texture_multisample

  tbl.glTexImage2DMultisampleCoverageNV = http_glTexImage2DMultisampleCoverageNV;
  tbl.glTexImage3DMultisampleCoverageNV = http_glTexImage3DMultisampleCoverageNV;
  tbl.glTextureImage2DMultisampleCoverageNV = http_glTextureImage2DMultisampleCoverageNV;
  tbl.glTextureImage2DMultisampleNV = http_glTextureImage2DMultisampleNV;
  tbl.glTextureImage3DMultisampleCoverageNV = http_glTextureImage3DMultisampleCoverageNV;
  tbl.glTextureImage3DMultisampleNV = http_glTextureImage3DMultisampleNV;

  // GL_NV_transform_feedback

  tbl.glActiveVaryingNV = http_glActiveVaryingNV;
  tbl.glBeginTransformFeedbackNV = http_glBeginTransformFeedbackNV;
  tbl.glBindBufferBaseNV = http_glBindBufferBaseNV;
  tbl.glBindBufferOffsetNV = http_glBindBufferOffsetNV;
  tbl.glBindBufferRangeNV = http_glBindBufferRangeNV;
  tbl.glEndTransformFeedbackNV = http_glEndTransformFeedbackNV;
  tbl.glGetActiveVaryingNV = http_glGetActiveVaryingNV;
  tbl.glGetTransformFeedbackVaryingNV = http_glGetTransformFeedbackVaryingNV;
  tbl.glGetVaryingLocationNV = http_glGetVaryingLocationNV;
  tbl.glTransformFeedbackAttribsNV = http_glTransformFeedbackAttribsNV;
  tbl.glTransformFeedbackVaryingsNV = http_glTransformFeedbackVaryingsNV;

  // GL_NV_transform_feedback2

  tbl.glBindTransformFeedbackNV = http_glBindTransformFeedbackNV;
  tbl.glDeleteTransformFeedbacksNV = http_glDeleteTransformFeedbacksNV;
  tbl.glDrawTransformFeedbackNV = http_glDrawTransformFeedbackNV;
  tbl.glGenTransformFeedbacksNV = http_glGenTransformFeedbacksNV;
  tbl.glIsTransformFeedbackNV = http_glIsTransformFeedbackNV;
  tbl.glPauseTransformFeedbackNV = http_glPauseTransformFeedbackNV;
  tbl.glResumeTransformFeedbackNV = http_glResumeTransformFeedbackNV;

  // GL_NV_vdpau_interop

  tbl.glVDPAUFiniNV = http_glVDPAUFiniNV;
  tbl.glVDPAUGetSurfaceivNV = http_glVDPAUGetSurfaceivNV;
  tbl.glVDPAUInitNV = http_glVDPAUInitNV;
  tbl.glVDPAUIsSurfaceNV = http_glVDPAUIsSurfaceNV;
  tbl.glVDPAUMapSurfacesNV = http_glVDPAUMapSurfacesNV;
  tbl.glVDPAURegisterOutputSurfaceNV = http_glVDPAURegisterOutputSurfaceNV;
  tbl.glVDPAURegisterVideoSurfaceNV = http_glVDPAURegisterVideoSurfaceNV;
  tbl.glVDPAUSurfaceAccessNV = http_glVDPAUSurfaceAccessNV;
  tbl.glVDPAUUnmapSurfacesNV = http_glVDPAUUnmapSurfacesNV;
  tbl.glVDPAUUnregisterSurfaceNV = http_glVDPAUUnregisterSurfaceNV;

  // GL_NV_vertex_array_range

  tbl.glFlushVertexArrayRangeNV = http_glFlushVertexArrayRangeNV;
  tbl.glVertexArrayRangeNV = http_glVertexArrayRangeNV;

  // GL_NV_vertex_attrib_integer_64bit

  tbl.glGetVertexAttribLi64vNV = http_glGetVertexAttribLi64vNV;
  tbl.glGetVertexAttribLui64vNV = http_glGetVertexAttribLui64vNV;
  tbl.glVertexAttribL1i64NV = http_glVertexAttribL1i64NV;
  tbl.glVertexAttribL1i64vNV = http_glVertexAttribL1i64vNV;
  tbl.glVertexAttribL1ui64NV = http_glVertexAttribL1ui64NV;
  tbl.glVertexAttribL1ui64vNV = http_glVertexAttribL1ui64vNV;
  tbl.glVertexAttribL2i64NV = http_glVertexAttribL2i64NV;
  tbl.glVertexAttribL2i64vNV = http_glVertexAttribL2i64vNV;
  tbl.glVertexAttribL2ui64NV = http_glVertexAttribL2ui64NV;
  tbl.glVertexAttribL2ui64vNV = http_glVertexAttribL2ui64vNV;
  tbl.glVertexAttribL3i64NV = http_glVertexAttribL3i64NV;
  tbl.glVertexAttribL3i64vNV = http_glVertexAttribL3i64vNV;
  tbl.glVertexAttribL3ui64NV = http_glVertexAttribL3ui64NV;
  tbl.glVertexAttribL3ui64vNV = http_glVertexAttribL3ui64vNV;
  tbl.glVertexAttribL4i64NV = http_glVertexAttribL4i64NV;
  tbl.glVertexAttribL4i64vNV = http_glVertexAttribL4i64vNV;
  tbl.glVertexAttribL4ui64NV = http_glVertexAttribL4ui64NV;
  tbl.glVertexAttribL4ui64vNV = http_glVertexAttribL4ui64vNV;
  tbl.glVertexAttribLFormatNV = http_glVertexAttribLFormatNV;

  // GL_NV_vertex_buffer_unified_memory

  tbl.glBufferAddressRangeNV = http_glBufferAddressRangeNV;
  tbl.glColorFormatNV = http_glColorFormatNV;
  tbl.glEdgeFlagFormatNV = http_glEdgeFlagFormatNV;
  tbl.glFogCoordFormatNV = http_glFogCoordFormatNV;
  tbl.glGetIntegerui64i_vNV = http_glGetIntegerui64i_vNV;
  tbl.glIndexFormatNV = http_glIndexFormatNV;
  tbl.glNormalFormatNV = http_glNormalFormatNV;
  tbl.glSecondaryColorFormatNV = http_glSecondaryColorFormatNV;
  tbl.glTexCoordFormatNV = http_glTexCoordFormatNV;
  tbl.glVertexAttribFormatNV = http_glVertexAttribFormatNV;
  tbl.glVertexAttribIFormatNV = http_glVertexAttribIFormatNV;
  tbl.glVertexFormatNV = http_glVertexFormatNV;

  // GL_NV_vertex_program

  tbl.glAreProgramsResidentNV = http_glAreProgramsResidentNV;
  tbl.glBindProgramNV = http_glBindProgramNV;
  tbl.glDeleteProgramsNV = http_glDeleteProgramsNV;
  tbl.glExecuteProgramNV = http_glExecuteProgramNV;
  tbl.glGenProgramsNV = http_glGenProgramsNV;
  tbl.glGetProgramParameterdvNV = http_glGetProgramParameterdvNV;
  tbl.glGetProgramParameterfvNV = http_glGetProgramParameterfvNV;
  tbl.glGetProgramStringNV = http_glGetProgramStringNV;
  tbl.glGetProgramivNV = http_glGetProgramivNV;
  tbl.glGetTrackMatrixivNV = http_glGetTrackMatrixivNV;
  tbl.glGetVertexAttribPointervNV = http_glGetVertexAttribPointervNV;
  tbl.glGetVertexAttribdvNV = http_glGetVertexAttribdvNV;
  tbl.glGetVertexAttribfvNV = http_glGetVertexAttribfvNV;
  tbl.glGetVertexAttribivNV = http_glGetVertexAttribivNV;
  tbl.glIsProgramNV = http_glIsProgramNV;
  tbl.glLoadProgramNV = http_glLoadProgramNV;
  tbl.glProgramParameter4dNV = http_glProgramParameter4dNV;
  tbl.glProgramParameter4dvNV = http_glProgramParameter4dvNV;
  tbl.glProgramParameter4fNV = http_glProgramParameter4fNV;
  tbl.glProgramParameter4fvNV = http_glProgramParameter4fvNV;
  tbl.glProgramParameters4dvNV = http_glProgramParameters4dvNV;
  tbl.glProgramParameters4fvNV = http_glProgramParameters4fvNV;
  tbl.glRequestResidentProgramsNV = http_glRequestResidentProgramsNV;
  tbl.glTrackMatrixNV = http_glTrackMatrixNV;
  tbl.glVertexAttrib1dNV = http_glVertexAttrib1dNV;
  tbl.glVertexAttrib1dvNV = http_glVertexAttrib1dvNV;
  tbl.glVertexAttrib1fNV = http_glVertexAttrib1fNV;
  tbl.glVertexAttrib1fvNV = http_glVertexAttrib1fvNV;
  tbl.glVertexAttrib1sNV = http_glVertexAttrib1sNV;
  tbl.glVertexAttrib1svNV = http_glVertexAttrib1svNV;
  tbl.glVertexAttrib2dNV = http_glVertexAttrib2dNV;
  tbl.glVertexAttrib2dvNV = http_glVertexAttrib2dvNV;
  tbl.glVertexAttrib2fNV = http_glVertexAttrib2fNV;
  tbl.glVertexAttrib2fvNV = http_glVertexAttrib2fvNV;
  tbl.glVertexAttrib2sNV = http_glVertexAttrib2sNV;
  tbl.glVertexAttrib2svNV = http_glVertexAttrib2svNV;
  tbl.glVertexAttrib3dNV = http_glVertexAttrib3dNV;
  tbl.glVertexAttrib3dvNV = http_glVertexAttrib3dvNV;
  tbl.glVertexAttrib3fNV = http_glVertexAttrib3fNV;
  tbl.glVertexAttrib3fvNV = http_glVertexAttrib3fvNV;
  tbl.glVertexAttrib3sNV = http_glVertexAttrib3sNV;
  tbl.glVertexAttrib3svNV = http_glVertexAttrib3svNV;
  tbl.glVertexAttrib4dNV = http_glVertexAttrib4dNV;
  tbl.glVertexAttrib4dvNV = http_glVertexAttrib4dvNV;
  tbl.glVertexAttrib4fNV = http_glVertexAttrib4fNV;
  tbl.glVertexAttrib4fvNV = http_glVertexAttrib4fvNV;
  tbl.glVertexAttrib4sNV = http_glVertexAttrib4sNV;
  tbl.glVertexAttrib4svNV = http_glVertexAttrib4svNV;
  tbl.glVertexAttrib4ubNV = http_glVertexAttrib4ubNV;
  tbl.glVertexAttrib4ubvNV = http_glVertexAttrib4ubvNV;
  tbl.glVertexAttribPointerNV = http_glVertexAttribPointerNV;
  tbl.glVertexAttribs1dvNV = http_glVertexAttribs1dvNV;
  tbl.glVertexAttribs1fvNV = http_glVertexAttribs1fvNV;
  tbl.glVertexAttribs1svNV = http_glVertexAttribs1svNV;
  tbl.glVertexAttribs2dvNV = http_glVertexAttribs2dvNV;
  tbl.glVertexAttribs2fvNV = http_glVertexAttribs2fvNV;
  tbl.glVertexAttribs2svNV = http_glVertexAttribs2svNV;
  tbl.glVertexAttribs3dvNV = http_glVertexAttribs3dvNV;
  tbl.glVertexAttribs3fvNV = http_glVertexAttribs3fvNV;
  tbl.glVertexAttribs3svNV = http_glVertexAttribs3svNV;
  tbl.glVertexAttribs4dvNV = http_glVertexAttribs4dvNV;
  tbl.glVertexAttribs4fvNV = http_glVertexAttribs4fvNV;
  tbl.glVertexAttribs4svNV = http_glVertexAttribs4svNV;
  tbl.glVertexAttribs4ubvNV = http_glVertexAttribs4ubvNV;

  // GL_NV_video_capture

  tbl.glBeginVideoCaptureNV = http_glBeginVideoCaptureNV;
  tbl.glBindVideoCaptureStreamBufferNV = http_glBindVideoCaptureStreamBufferNV;
  tbl.glBindVideoCaptureStreamTextureNV = http_glBindVideoCaptureStreamTextureNV;
  tbl.glEndVideoCaptureNV = http_glEndVideoCaptureNV;
  tbl.glGetVideoCaptureStreamdvNV = http_glGetVideoCaptureStreamdvNV;
  tbl.glGetVideoCaptureStreamfvNV = http_glGetVideoCaptureStreamfvNV;
  tbl.glGetVideoCaptureStreamivNV = http_glGetVideoCaptureStreamivNV;
  tbl.glGetVideoCaptureivNV = http_glGetVideoCaptureivNV;
  tbl.glVideoCaptureNV = http_glVideoCaptureNV;
  tbl.glVideoCaptureStreamParameterdvNV = http_glVideoCaptureStreamParameterdvNV;
  tbl.glVideoCaptureStreamParameterfvNV = http_glVideoCaptureStreamParameterfvNV;
  tbl.glVideoCaptureStreamParameterivNV = http_glVideoCaptureStreamParameterivNV;

  // GL_OES_blend_equation_separate

  tbl.glBlendEquationSeparateOES = http_glBlendEquationSeparateOES;

  // GL_OES_blend_func_separate

  tbl.glBlendFuncSeparateOES = http_glBlendFuncSeparateOES;

  // GL_OES_blend_subtract

  tbl.glBlendEquationOES = http_glBlendEquationOES;

  // GL_OES_framebuffer_object

  tbl.glBindFramebufferOES = http_glBindFramebufferOES;
  tbl.glBindRenderbufferOES = http_glBindRenderbufferOES;
  tbl.glCheckFramebufferStatusOES = http_glCheckFramebufferStatusOES;
  tbl.glDeleteFramebuffersOES = http_glDeleteFramebuffersOES;
  tbl.glDeleteRenderbuffersOES = http_glDeleteRenderbuffersOES;
  tbl.glFramebufferRenderbufferOES = http_glFramebufferRenderbufferOES;
  tbl.glFramebufferTexture2DOES = http_glFramebufferTexture2DOES;
  tbl.glGenFramebuffersOES = http_glGenFramebuffersOES;
  tbl.glGenRenderbuffersOES = http_glGenRenderbuffersOES;
  tbl.glGenerateMipmapOES = http_glGenerateMipmapOES;
  tbl.glGetFramebufferAttachmentParameterivOES = http_glGetFramebufferAttachmentParameterivOES;
  tbl.glGetRenderbufferParameterivOES = http_glGetRenderbufferParameterivOES;
  tbl.glIsFramebufferOES = http_glIsFramebufferOES;
  tbl.glIsRenderbufferOES = http_glIsRenderbufferOES;
  tbl.glRenderbufferStorageOES = http_glRenderbufferStorageOES;

  // GL_OES_get_program_binary

  tbl.glGetProgramBinaryOES = http_glGetProgramBinaryOES;
  tbl.glProgramBinaryOES = http_glProgramBinaryOES;

  // GL_OES_mapbuffer

  tbl.glGetBufferPointervOES = http_glGetBufferPointervOES;
  tbl.glMapBufferOES = http_glMapBufferOES;
  tbl.glUnmapBufferOES = http_glUnmapBufferOES;

  // GL_OES_matrix_palette

  tbl.glCurrentPaletteMatrixOES = http_glCurrentPaletteMatrixOES;
  tbl.glMatrixIndexPointerOES = http_glMatrixIndexPointerOES;
  tbl.glWeightPointerOES = http_glWeightPointerOES;

  // GL_OES_single_precision

  tbl.glClearDepthfOES = http_glClearDepthfOES;
  tbl.glClipPlanefOES = http_glClipPlanefOES;
  tbl.glDepthRangefOES = http_glDepthRangefOES;
  tbl.glFrustumfOES = http_glFrustumfOES;
  tbl.glGetClipPlanefOES = http_glGetClipPlanefOES;
  tbl.glOrthofOES = http_glOrthofOES;

  // GL_OES_texture_3D

  tbl.glCompressedTexImage3DOES = http_glCompressedTexImage3DOES;
  tbl.glCompressedTexSubImage3DOES = http_glCompressedTexSubImage3DOES;
  tbl.glCopyTexSubImage3DOES = http_glCopyTexSubImage3DOES;
  tbl.glFramebufferTexture3DOES = http_glFramebufferTexture3DOES;
  tbl.glTexImage3DOES = http_glTexImage3DOES;
  tbl.glTexSubImage3DOES = http_glTexSubImage3DOES;

  // GL_OES_texture_cube_map

  tbl.glGetTexGenfvOES = http_glGetTexGenfvOES;
  tbl.glGetTexGenivOES = http_glGetTexGenivOES;
  tbl.glGetTexGenxvOES = http_glGetTexGenxvOES;
  tbl.glTexGenfOES = http_glTexGenfOES;
  tbl.glTexGenfvOES = http_glTexGenfvOES;
  tbl.glTexGeniOES = http_glTexGeniOES;
  tbl.glTexGenivOES = http_glTexGenivOES;
  tbl.glTexGenxOES = http_glTexGenxOES;
  tbl.glTexGenxvOES = http_glTexGenxvOES;

  // GL_OES_vertex_array_object

  tbl.glBindVertexArrayOES = http_glBindVertexArrayOES;
  tbl.glDeleteVertexArraysOES = http_glDeleteVertexArraysOES;
  tbl.glGenVertexArraysOES = http_glGenVertexArraysOES;
  tbl.glIsVertexArrayOES = http_glIsVertexArrayOES;

  // GL_PGI_misc_hints

  tbl.glHintPGI = http_glHintPGI;

  // GL_QCOM_alpha_test

  tbl.glAlphaFuncQCOM = http_glAlphaFuncQCOM;

  // GL_QCOM_driver_control

  tbl.glDisableDriverControlQCOM = http_glDisableDriverControlQCOM;
  tbl.glEnableDriverControlQCOM = http_glEnableDriverControlQCOM;
  tbl.glGetDriverControlStringQCOM = http_glGetDriverControlStringQCOM;
  tbl.glGetDriverControlsQCOM = http_glGetDriverControlsQCOM;

  // GL_QCOM_extended_get

  tbl.glExtGetBufferPointervQCOM = http_glExtGetBufferPointervQCOM;
  tbl.glExtGetBuffersQCOM = http_glExtGetBuffersQCOM;
  tbl.glExtGetFramebuffersQCOM = http_glExtGetFramebuffersQCOM;
  tbl.glExtGetRenderbuffersQCOM = http_glExtGetRenderbuffersQCOM;
  tbl.glExtGetTexLevelParameterivQCOM = http_glExtGetTexLevelParameterivQCOM;
  tbl.glExtGetTexSubImageQCOM = http_glExtGetTexSubImageQCOM;
  tbl.glExtGetTexturesQCOM = http_glExtGetTexturesQCOM;
  tbl.glExtTexObjectStateOverrideiQCOM = http_glExtTexObjectStateOverrideiQCOM;

  // GL_QCOM_extended_get2

  tbl.glExtGetProgramBinarySourceQCOM = http_glExtGetProgramBinarySourceQCOM;
  tbl.glExtGetProgramsQCOM = http_glExtGetProgramsQCOM;
  tbl.glExtGetShadersQCOM = http_glExtGetShadersQCOM;
  tbl.glExtIsProgramBinaryQCOM = http_glExtIsProgramBinaryQCOM;

  // GL_QCOM_tiled_rendering

  tbl.glEndTilingQCOM = http_glEndTilingQCOM;
  tbl.glStartTilingQCOM = http_glStartTilingQCOM;

  // GL_REGAL_ES1_0_compatibility

  tbl.glAlphaFuncx = http_glAlphaFuncx;
  tbl.glClearColorx = http_glClearColorx;
  tbl.glClearDepthx = http_glClearDepthx;
  tbl.glColor4x = http_glColor4x;
  tbl.glDepthRangex = http_glDepthRangex;
  tbl.glFogx = http_glFogx;
  tbl.glFogxv = http_glFogxv;
  tbl.glFrustumf = http_glFrustumf;
  tbl.glFrustumx = http_glFrustumx;
  tbl.glLightModelx = http_glLightModelx;
  tbl.glLightModelxv = http_glLightModelxv;
  tbl.glLightx = http_glLightx;
  tbl.glLightxv = http_glLightxv;
  tbl.glLineWidthx = http_glLineWidthx;
  tbl.glLoadMatrixx = http_glLoadMatrixx;
  tbl.glMaterialx = http_glMaterialx;
  tbl.glMaterialxv = http_glMaterialxv;
  tbl.glMultMatrixx = http_glMultMatrixx;
  tbl.glMultiTexCoord4x = http_glMultiTexCoord4x;
  tbl.glNormal3x = http_glNormal3x;
  tbl.glOrthof = http_glOrthof;
  tbl.glOrthox = http_glOrthox;
  tbl.glPointSizex = http_glPointSizex;
  tbl.glPolygonOffsetx = http_glPolygonOffsetx;
  tbl.glRotatex = http_glRotatex;
  tbl.glSampleCoveragex = http_glSampleCoveragex;
  tbl.glScalex = http_glScalex;
  tbl.glTexEnvx = http_glTexEnvx;
  tbl.glTexEnvxv = http_glTexEnvxv;
  tbl.glTexParameterx = http_glTexParameterx;
  tbl.glTranslatex = http_glTranslatex;

  // GL_REGAL_ES1_1_compatibility

  tbl.glClipPlanef = http_glClipPlanef;
  tbl.glClipPlanex = http_glClipPlanex;
  tbl.glGetClipPlanef = http_glGetClipPlanef;
  tbl.glGetClipPlanex = http_glGetClipPlanex;
  tbl.glGetFixedv = http_glGetFixedv;
  tbl.glGetLightxv = http_glGetLightxv;
  tbl.glGetMaterialxv = http_glGetMaterialxv;
  tbl.glGetTexEnvxv = http_glGetTexEnvxv;
  tbl.glGetTexParameterxv = http_glGetTexParameterxv;
  tbl.glPointParameterx = http_glPointParameterx;
  tbl.glPointParameterxv = http_glPointParameterxv;
  tbl.glPointSizePointerOES = http_glPointSizePointerOES;
  tbl.glTexParameterxv = http_glTexParameterxv;

  // GL_REGAL_log

  tbl.glLogMessageCallbackREGAL = http_glLogMessageCallbackREGAL;

  // GL_SGIS_detail_texture

  tbl.glDetailTexFuncSGIS = http_glDetailTexFuncSGIS;
  tbl.glGetDetailTexFuncSGIS = http_glGetDetailTexFuncSGIS;

  // GL_SGIS_fog_function

  tbl.glFogFuncSGIS = http_glFogFuncSGIS;
  tbl.glGetFogFuncSGIS = http_glGetFogFuncSGIS;

  // GL_SGIS_multisample

  tbl.glSampleMaskSGIS = http_glSampleMaskSGIS;
  tbl.glSamplePatternSGIS = http_glSamplePatternSGIS;

  // GL_SGIS_pixel_texture

  tbl.glGetPixelTexGenParameterfvSGIS = http_glGetPixelTexGenParameterfvSGIS;
  tbl.glGetPixelTexGenParameterivSGIS = http_glGetPixelTexGenParameterivSGIS;
  tbl.glPixelTexGenParameterfSGIS = http_glPixelTexGenParameterfSGIS;
  tbl.glPixelTexGenParameterfvSGIS = http_glPixelTexGenParameterfvSGIS;
  tbl.glPixelTexGenParameteriSGIS = http_glPixelTexGenParameteriSGIS;
  tbl.glPixelTexGenParameterivSGIS = http_glPixelTexGenParameterivSGIS;

  // GL_SGIS_point_parameters

  tbl.glPointParameterfSGIS = http_glPointParameterfSGIS;
  tbl.glPointParameterfvSGIS = http_glPointParameterfvSGIS;

  // GL_SGIS_sharpen_texture

  tbl.glGetSharpenTexFuncSGIS = http_glGetSharpenTexFuncSGIS;
  tbl.glSharpenTexFuncSGIS = http_glSharpenTexFuncSGIS;

  // GL_SGIS_texture4D

  tbl.glTexImage4DSGIS = http_glTexImage4DSGIS;
  tbl.glTexSubImage4DSGIS = http_glTexSubImage4DSGIS;

  // GL_SGIS_texture_color_mask

  tbl.glTextureColorMaskSGIS = http_glTextureColorMaskSGIS;

  // GL_SGIS_texture_filter4

  tbl.glGetTexFilterFuncSGIS = http_glGetTexFilterFuncSGIS;
  tbl.glTexFilterFuncSGIS = http_glTexFilterFuncSGIS;

  // GL_SGIX_async

  tbl.glAsyncMarkerSGIX = http_glAsyncMarkerSGIX;
  tbl.glDeleteAsyncMarkersSGIX = http_glDeleteAsyncMarkersSGIX;
  tbl.glFinishAsyncSGIX = http_glFinishAsyncSGIX;
  tbl.glGenAsyncMarkersSGIX = http_glGenAsyncMarkersSGIX;
  tbl.glIsAsyncMarkerSGIX = http_glIsAsyncMarkerSGIX;
  tbl.glPollAsyncSGIX = http_glPollAsyncSGIX;

  // GL_SGIX_flush_raster

  tbl.glFlushRasterSGIX = http_glFlushRasterSGIX;

  // GL_SGIX_fog_texture

  tbl.glTextureFogSGIX = http_glTextureFogSGIX;

  // GL_SGIX_fragment_lighting

  tbl.glFragmentColorMaterialSGIX = http_glFragmentColorMaterialSGIX;
  tbl.glFragmentLightModelfSGIX = http_glFragmentLightModelfSGIX;
  tbl.glFragmentLightModelfvSGIX = http_glFragmentLightModelfvSGIX;
  tbl.glFragmentLightModeliSGIX = http_glFragmentLightModeliSGIX;
  tbl.glFragmentLightModelivSGIX = http_glFragmentLightModelivSGIX;
  tbl.glFragmentLightfSGIX = http_glFragmentLightfSGIX;
  tbl.glFragmentLightfvSGIX = http_glFragmentLightfvSGIX;
  tbl.glFragmentLightiSGIX = http_glFragmentLightiSGIX;
  tbl.glFragmentLightivSGIX = http_glFragmentLightivSGIX;
  tbl.glFragmentMaterialfSGIX = http_glFragmentMaterialfSGIX;
  tbl.glFragmentMaterialfvSGIX = http_glFragmentMaterialfvSGIX;
  tbl.glFragmentMaterialiSGIX = http_glFragmentMaterialiSGIX;
  tbl.glFragmentMaterialivSGIX = http_glFragmentMaterialivSGIX;
  tbl.glGetFragmentLightfvSGIX = http_glGetFragmentLightfvSGIX;
  tbl.glGetFragmentLightivSGIX = http_glGetFragmentLightivSGIX;
  tbl.glGetFragmentMaterialfvSGIX = http_glGetFragmentMaterialfvSGIX;
  tbl.glGetFragmentMaterialivSGIX = http_glGetFragmentMaterialivSGIX;
  tbl.glLightEnviSGIX = http_glLightEnviSGIX;

  // GL_SGIX_framezoom

  tbl.glFrameZoomSGIX = http_glFrameZoomSGIX;

  // GL_SGIX_igloo_interface

  tbl.glIglooInterfaceSGIX = http_glIglooInterfaceSGIX;

  // GL_SGIX_instruments

  tbl.glGetInstrumentsSGIX = http_glGetInstrumentsSGIX;
  tbl.glInstrumentsBufferSGIX = http_glInstrumentsBufferSGIX;
  tbl.glPollInstrumentsSGIX = http_glPollInstrumentsSGIX;
  tbl.glReadInstrumentsSGIX = http_glReadInstrumentsSGIX;
  tbl.glStartInstrumentsSGIX = http_glStartInstrumentsSGIX;
  tbl.glStopInstrumentsSGIX = http_glStopInstrumentsSGIX;

  // GL_SGIX_list_priority

  tbl.glGetListParameterfvSGIX = http_glGetListParameterfvSGIX;
  tbl.glGetListParameterivSGIX = http_glGetListParameterivSGIX;
  tbl.glListParameterfSGIX = http_glListParameterfSGIX;
  tbl.glListParameterfvSGIX = http_glListParameterfvSGIX;
  tbl.glListParameteriSGIX = http_glListParameteriSGIX;
  tbl.glListParameterivSGIX = http_glListParameterivSGIX;

  // GL_SGIX_pixel_texture

  tbl.glPixelTexGenSGIX = http_glPixelTexGenSGIX;

  // GL_SGIX_polynomial_ffd

  tbl.glDeformSGIX = http_glDeformSGIX;
  tbl.glDeformationMap3dSGIX = http_glDeformationMap3dSGIX;
  tbl.glDeformationMap3fSGIX = http_glDeformationMap3fSGIX;
  tbl.glLoadIdentityDeformationMapSGIX = http_glLoadIdentityDeformationMapSGIX;

  // GL_SGIX_reference_plane

  tbl.glReferencePlaneSGIX = http_glReferencePlaneSGIX;

  // GL_SGIX_sprite

  tbl.glSpriteParameterfSGIX = http_glSpriteParameterfSGIX;
  tbl.glSpriteParameterfvSGIX = http_glSpriteParameterfvSGIX;
  tbl.glSpriteParameteriSGIX = http_glSpriteParameteriSGIX;
  tbl.glSpriteParameterivSGIX = http_glSpriteParameterivSGIX;

  // GL_SGIX_tag_sample_buffer

  tbl.glTagSampleBufferSGIX = http_glTagSampleBufferSGIX;

  // GL_SGI_color_table

  tbl.glColorTableParameterfvSGI = http_glColorTableParameterfvSGI;
  tbl.glColorTableParameterivSGI = http_glColorTableParameterivSGI;
  tbl.glColorTableSGI = http_glColorTableSGI;
  tbl.glCopyColorTableSGI = http_glCopyColorTableSGI;
  tbl.glGetColorTableParameterfvSGI = http_glGetColorTableParameterfvSGI;
  tbl.glGetColorTableParameterivSGI = http_glGetColorTableParameterivSGI;
  tbl.glGetColorTableSGI = http_glGetColorTableSGI;

  // GL_SUNX_constant_data

  tbl.glFinishTextureSUNX = http_glFinishTextureSUNX;

  // GL_SUN_global_alpha

  tbl.glGlobalAlphaFactorbSUN = http_glGlobalAlphaFactorbSUN;
  tbl.glGlobalAlphaFactordSUN = http_glGlobalAlphaFactordSUN;
  tbl.glGlobalAlphaFactorfSUN = http_glGlobalAlphaFactorfSUN;
  tbl.glGlobalAlphaFactoriSUN = http_glGlobalAlphaFactoriSUN;
  tbl.glGlobalAlphaFactorsSUN = http_glGlobalAlphaFactorsSUN;
  tbl.glGlobalAlphaFactorubSUN = http_glGlobalAlphaFactorubSUN;
  tbl.glGlobalAlphaFactoruiSUN = http_glGlobalAlphaFactoruiSUN;
  tbl.glGlobalAlphaFactorusSUN = http_glGlobalAlphaFactorusSUN;

  // GL_SUN_mesh_array

  tbl.glDrawMeshArraysSUN = http_glDrawMeshArraysSUN;

  // GL_SUN_read_video_pixels

  tbl.glReadVideoPixelsSUN = http_glReadVideoPixelsSUN;

  // GL_SUN_triangle_list

  tbl.glReplacementCodePointerSUN = http_glReplacementCodePointerSUN;
  tbl.glReplacementCodeubSUN = http_glReplacementCodeubSUN;
  tbl.glReplacementCodeubvSUN = http_glReplacementCodeubvSUN;
  tbl.glReplacementCodeuiSUN = http_glReplacementCodeuiSUN;
  tbl.glReplacementCodeuivSUN = http_glReplacementCodeuivSUN;
  tbl.glReplacementCodeusSUN = http_glReplacementCodeusSUN;
  tbl.glReplacementCodeusvSUN = http_glReplacementCodeusvSUN;

  // GL_SUN_vertex

  tbl.glColor3fVertex3fSUN = http_glColor3fVertex3fSUN;
  tbl.glColor3fVertex3fvSUN = http_glColor3fVertex3fvSUN;
  tbl.glColor4fNormal3fVertex3fSUN = http_glColor4fNormal3fVertex3fSUN;
  tbl.glColor4fNormal3fVertex3fvSUN = http_glColor4fNormal3fVertex3fvSUN;
  tbl.glColor4ubVertex2fSUN = http_glColor4ubVertex2fSUN;
  tbl.glColor4ubVertex2fvSUN = http_glColor4ubVertex2fvSUN;
  tbl.glColor4ubVertex3fSUN = http_glColor4ubVertex3fSUN;
  tbl.glColor4ubVertex3fvSUN = http_glColor4ubVertex3fvSUN;
  tbl.glNormal3fVertex3fSUN = http_glNormal3fVertex3fSUN;
  tbl.glNormal3fVertex3fvSUN = http_glNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiColor3fVertex3fSUN = http_glReplacementCodeuiColor3fVertex3fSUN;
  tbl.glReplacementCodeuiColor3fVertex3fvSUN = http_glReplacementCodeuiColor3fVertex3fvSUN;
  tbl.glReplacementCodeuiColor4fNormal3fVertex3fSUN = http_glReplacementCodeuiColor4fNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiColor4fNormal3fVertex3fvSUN = http_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiColor4ubVertex3fSUN = http_glReplacementCodeuiColor4ubVertex3fSUN;
  tbl.glReplacementCodeuiColor4ubVertex3fvSUN = http_glReplacementCodeuiColor4ubVertex3fvSUN;
  tbl.glReplacementCodeuiNormal3fVertex3fSUN = http_glReplacementCodeuiNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiNormal3fVertex3fvSUN = http_glReplacementCodeuiNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN = http_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN = http_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN = http_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
  tbl.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN = http_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
  tbl.glReplacementCodeuiTexCoord2fVertex3fSUN = http_glReplacementCodeuiTexCoord2fVertex3fSUN;
  tbl.glReplacementCodeuiTexCoord2fVertex3fvSUN = http_glReplacementCodeuiTexCoord2fVertex3fvSUN;
  tbl.glReplacementCodeuiVertex3fSUN = http_glReplacementCodeuiVertex3fSUN;
  tbl.glReplacementCodeuiVertex3fvSUN = http_glReplacementCodeuiVertex3fvSUN;
  tbl.glTexCoord2fColor3fVertex3fSUN = http_glTexCoord2fColor3fVertex3fSUN;
  tbl.glTexCoord2fColor3fVertex3fvSUN = http_glTexCoord2fColor3fVertex3fvSUN;
  tbl.glTexCoord2fColor4fNormal3fVertex3fSUN = http_glTexCoord2fColor4fNormal3fVertex3fSUN;
  tbl.glTexCoord2fColor4fNormal3fVertex3fvSUN = http_glTexCoord2fColor4fNormal3fVertex3fvSUN;
  tbl.glTexCoord2fColor4ubVertex3fSUN = http_glTexCoord2fColor4ubVertex3fSUN;
  tbl.glTexCoord2fColor4ubVertex3fvSUN = http_glTexCoord2fColor4ubVertex3fvSUN;
  tbl.glTexCoord2fNormal3fVertex3fSUN = http_glTexCoord2fNormal3fVertex3fSUN;
  tbl.glTexCoord2fNormal3fVertex3fvSUN = http_glTexCoord2fNormal3fVertex3fvSUN;
  tbl.glTexCoord2fVertex3fSUN = http_glTexCoord2fVertex3fSUN;
  tbl.glTexCoord2fVertex3fvSUN = http_glTexCoord2fVertex3fvSUN;
  tbl.glTexCoord4fColor4fNormal3fVertex4fSUN = http_glTexCoord4fColor4fNormal3fVertex4fSUN;
  tbl.glTexCoord4fColor4fNormal3fVertex4fvSUN = http_glTexCoord4fColor4fNormal3fVertex4fvSUN;
  tbl.glTexCoord4fVertex4fSUN = http_glTexCoord4fVertex4fSUN;
  tbl.glTexCoord4fVertex4fvSUN = http_glTexCoord4fVertex4fvSUN;

  // GL_WIN_swap_hint

  tbl.glAddSwapHintRectWIN = http_glAddSwapHintRectWIN;

}

void InitDispatchTableGlobalHttp(DispatchTableGlobal &tbl)
{

#if REGAL_SYS_WGL
  // WGL_3DL_stereo_control

  tbl.wglSetStereoEmitterState3DL = http_wglSetStereoEmitterState3DL;

  // WGL_AMD_gpu_association

  tbl.wglBlitContextFramebufferAMD = http_wglBlitContextFramebufferAMD;
  tbl.wglCreateAssociatedContextAMD = http_wglCreateAssociatedContextAMD;
  tbl.wglCreateAssociatedContextAttribsAMD = http_wglCreateAssociatedContextAttribsAMD;
  tbl.wglDeleteAssociatedContextAMD = http_wglDeleteAssociatedContextAMD;
  tbl.wglGetContextGPUIDAMD = http_wglGetContextGPUIDAMD;
  tbl.wglGetCurrentAssociatedContextAMD = http_wglGetCurrentAssociatedContextAMD;
  tbl.wglGetGPUIDsAMD = http_wglGetGPUIDsAMD;
  tbl.wglGetGPUInfoAMD = http_wglGetGPUInfoAMD;
  tbl.wglMakeAssociatedContextCurrentAMD = http_wglMakeAssociatedContextCurrentAMD;

  // WGL_ARB_buffer_region

  tbl.wglCreateBufferRegionARB = http_wglCreateBufferRegionARB;
  tbl.wglDeleteBufferRegionARB = http_wglDeleteBufferRegionARB;
  tbl.wglRestoreBufferRegionARB = http_wglRestoreBufferRegionARB;
  tbl.wglSaveBufferRegionARB = http_wglSaveBufferRegionARB;

  // WGL_ARB_create_context

  tbl.wglCreateContextAttribsARB = http_wglCreateContextAttribsARB;

  // WGL_ARB_extensions_string

  tbl.wglGetExtensionsStringARB = http_wglGetExtensionsStringARB;

  // WGL_ARB_make_current_read

  tbl.wglGetCurrentReadDCARB = http_wglGetCurrentReadDCARB;
  tbl.wglMakeContextCurrentARB = http_wglMakeContextCurrentARB;

  // WGL_ARB_pbuffer

  tbl.wglCreatePbufferARB = http_wglCreatePbufferARB;
  tbl.wglDestroyPbufferARB = http_wglDestroyPbufferARB;
  tbl.wglGetPbufferDCARB = http_wglGetPbufferDCARB;
  tbl.wglQueryPbufferARB = http_wglQueryPbufferARB;
  tbl.wglReleasePbufferDCARB = http_wglReleasePbufferDCARB;

  // WGL_ARB_pixel_format

  tbl.wglChoosePixelFormatARB = http_wglChoosePixelFormatARB;
  tbl.wglGetPixelFormatAttribfvARB = http_wglGetPixelFormatAttribfvARB;
  tbl.wglGetPixelFormatAttribivARB = http_wglGetPixelFormatAttribivARB;

  // WGL_ARB_render_texture

  tbl.wglBindTexImageARB = http_wglBindTexImageARB;
  tbl.wglReleaseTexImageARB = http_wglReleaseTexImageARB;
  tbl.wglSetPbufferAttribARB = http_wglSetPbufferAttribARB;

  // WGL_EXT_display_color_table

  tbl.wglBindDisplayColorTableEXT = http_wglBindDisplayColorTableEXT;
  tbl.wglCreateDisplayColorTableEXT = http_wglCreateDisplayColorTableEXT;
  tbl.wglDestroyDisplayColorTableEXT = http_wglDestroyDisplayColorTableEXT;
  tbl.wglLoadDisplayColorTableEXT = http_wglLoadDisplayColorTableEXT;

  // WGL_EXT_extensions_string

  tbl.wglGetExtensionsStringEXT = http_wglGetExtensionsStringEXT;

  // WGL_EXT_make_current_read

  tbl.wglGetCurrentReadDCEXT = http_wglGetCurrentReadDCEXT;
  tbl.wglMakeContextCurrentEXT = http_wglMakeContextCurrentEXT;

  // WGL_EXT_pbuffer

  tbl.wglCreatePbufferEXT = http_wglCreatePbufferEXT;
  tbl.wglDestroyPbufferEXT = http_wglDestroyPbufferEXT;
  tbl.wglGetPbufferDCEXT = http_wglGetPbufferDCEXT;
  tbl.wglQueryPbufferEXT = http_wglQueryPbufferEXT;
  tbl.wglReleasePbufferDCEXT = http_wglReleasePbufferDCEXT;

  // WGL_EXT_pixel_format

  tbl.wglChoosePixelFormatEXT = http_wglChoosePixelFormatEXT;
  tbl.wglGetPixelFormatAttribfvEXT = http_wglGetPixelFormatAttribfvEXT;
  tbl.wglGetPixelFormatAttribivEXT = http_wglGetPixelFormatAttribivEXT;

  // WGL_EXT_swap_control

  tbl.wglGetSwapIntervalEXT = http_wglGetSwapIntervalEXT;
  tbl.wglSwapIntervalEXT = http_wglSwapIntervalEXT;

  // WGL_GDI

  tbl.wglChoosePixelFormat = http_wglChoosePixelFormat;
  tbl.wglDescribePixelFormat = http_wglDescribePixelFormat;
  tbl.wglGetPixelFormat = http_wglGetPixelFormat;
  tbl.wglSetPixelFormat = http_wglSetPixelFormat;
  tbl.wglSwapBuffers = http_wglSwapBuffers;

  // WGL_I3D_digital_video_control

  tbl.wglGetDigitalVideoParametersI3D = http_wglGetDigitalVideoParametersI3D;
  tbl.wglSetDigitalVideoParametersI3D = http_wglSetDigitalVideoParametersI3D;

  // WGL_I3D_gamma

  tbl.wglGetGammaTableI3D = http_wglGetGammaTableI3D;
  tbl.wglGetGammaTableParametersI3D = http_wglGetGammaTableParametersI3D;
  tbl.wglSetGammaTableI3D = http_wglSetGammaTableI3D;
  tbl.wglSetGammaTableParametersI3D = http_wglSetGammaTableParametersI3D;

  // WGL_I3D_genlock

  tbl.wglDisableGenlockI3D = http_wglDisableGenlockI3D;
  tbl.wglEnableGenlockI3D = http_wglEnableGenlockI3D;
  tbl.wglGenlockSampleRateI3D = http_wglGenlockSampleRateI3D;
  tbl.wglGenlockSourceDelayI3D = http_wglGenlockSourceDelayI3D;
  tbl.wglGenlockSourceEdgeI3D = http_wglGenlockSourceEdgeI3D;
  tbl.wglGenlockSourceI3D = http_wglGenlockSourceI3D;
  tbl.wglGetGenlockSampleRateI3D = http_wglGetGenlockSampleRateI3D;
  tbl.wglGetGenlockSourceDelayI3D = http_wglGetGenlockSourceDelayI3D;
  tbl.wglGetGenlockSourceEdgeI3D = http_wglGetGenlockSourceEdgeI3D;
  tbl.wglGetGenlockSourceI3D = http_wglGetGenlockSourceI3D;
  tbl.wglIsEnabledGenlockI3D = http_wglIsEnabledGenlockI3D;
  tbl.wglQueryGenlockMaxSourceDelayI3D = http_wglQueryGenlockMaxSourceDelayI3D;

  // WGL_I3D_image_buffer

  tbl.wglAssociateImageBufferEventsI3D = http_wglAssociateImageBufferEventsI3D;
  tbl.wglCreateImageBufferI3D = http_wglCreateImageBufferI3D;
  tbl.wglDestroyImageBufferI3D = http_wglDestroyImageBufferI3D;
  tbl.wglReleaseImageBufferEventsI3D = http_wglReleaseImageBufferEventsI3D;

  // WGL_I3D_swap_frame_lock

  tbl.wglDisableFrameLockI3D = http_wglDisableFrameLockI3D;
  tbl.wglEnableFrameLockI3D = http_wglEnableFrameLockI3D;
  tbl.wglIsEnabledFrameLockI3D = http_wglIsEnabledFrameLockI3D;
  tbl.wglQueryFrameLockMasterI3D = http_wglQueryFrameLockMasterI3D;

  // WGL_I3D_swap_frame_usage

  tbl.wglBeginFrameTrackingI3D = http_wglBeginFrameTrackingI3D;
  tbl.wglEndFrameTrackingI3D = http_wglEndFrameTrackingI3D;
  tbl.wglGetFrameUsageI3D = http_wglGetFrameUsageI3D;
  tbl.wglQueryFrameTrackingI3D = http_wglQueryFrameTrackingI3D;

  // WGL_NV_DX_interop

  tbl.wglDXCloseDeviceNV = http_wglDXCloseDeviceNV;
  tbl.wglDXLockObjectsNV = http_wglDXLockObjectsNV;
  tbl.wglDXObjectAccessNV = http_wglDXObjectAccessNV;
  tbl.wglDXOpenDeviceNV = http_wglDXOpenDeviceNV;
  tbl.wglDXRegisterObjectNV = http_wglDXRegisterObjectNV;
  tbl.wglDXSetResourceShareHandleNV = http_wglDXSetResourceShareHandleNV;
  tbl.wglDXUnlockObjectsNV = http_wglDXUnlockObjectsNV;
  tbl.wglDXUnregisterObjectNV = http_wglDXUnregisterObjectNV;

  // WGL_NV_copy_image

  tbl.wglCopyImageSubDataNV = http_wglCopyImageSubDataNV;

  // WGL_NV_delay_before_swap

  tbl.wglDelayBeforeSwapNV = http_wglDelayBeforeSwapNV;

  // WGL_NV_gpu_affinity

  tbl.wglCreateAffinityDCNV = http_wglCreateAffinityDCNV;
  tbl.wglDeleteDCNV = http_wglDeleteDCNV;
  tbl.wglEnumGpuDevicesNV = http_wglEnumGpuDevicesNV;
  tbl.wglEnumGpusFromAffinityDCNV = http_wglEnumGpusFromAffinityDCNV;
  tbl.wglEnumGpusNV = http_wglEnumGpusNV;

  // WGL_NV_present_video

  tbl.wglBindVideoDeviceNV = http_wglBindVideoDeviceNV;
  tbl.wglEnumerateVideoDevicesNV = http_wglEnumerateVideoDevicesNV;
  tbl.wglQueryCurrentContextNV = http_wglQueryCurrentContextNV;

  // WGL_NV_swap_group

  tbl.wglBindSwapBarrierNV = http_wglBindSwapBarrierNV;
  tbl.wglJoinSwapGroupNV = http_wglJoinSwapGroupNV;
  tbl.wglQueryFrameCountNV = http_wglQueryFrameCountNV;
  tbl.wglQueryMaxSwapGroupsNV = http_wglQueryMaxSwapGroupsNV;
  tbl.wglQuerySwapGroupNV = http_wglQuerySwapGroupNV;
  tbl.wglResetFrameCountNV = http_wglResetFrameCountNV;

  // WGL_NV_vertex_array_range

  tbl.wglAllocateMemoryNV = http_wglAllocateMemoryNV;
  tbl.wglFreeMemoryNV = http_wglFreeMemoryNV;

  // WGL_NV_video_capture

  tbl.wglBindVideoCaptureDeviceNV = http_wglBindVideoCaptureDeviceNV;
  tbl.wglEnumerateVideoCaptureDevicesNV = http_wglEnumerateVideoCaptureDevicesNV;
  tbl.wglLockVideoCaptureDeviceNV = http_wglLockVideoCaptureDeviceNV;
  tbl.wglQueryVideoCaptureDeviceNV = http_wglQueryVideoCaptureDeviceNV;
  tbl.wglReleaseVideoCaptureDeviceNV = http_wglReleaseVideoCaptureDeviceNV;

  // WGL_NV_video_output

  tbl.wglBindVideoImageNV = http_wglBindVideoImageNV;
  tbl.wglGetVideoDeviceNV = http_wglGetVideoDeviceNV;
  tbl.wglGetVideoInfoNV = http_wglGetVideoInfoNV;
  tbl.wglReleaseVideoDeviceNV = http_wglReleaseVideoDeviceNV;
  tbl.wglReleaseVideoImageNV = http_wglReleaseVideoImageNV;
  tbl.wglSendPbufferToVideoNV = http_wglSendPbufferToVideoNV;

  // WGL_OML_sync_control

  tbl.wglGetMscRateOML = http_wglGetMscRateOML;
  tbl.wglGetSyncValuesOML = http_wglGetSyncValuesOML;
  tbl.wglSwapBuffersMscOML = http_wglSwapBuffersMscOML;
  tbl.wglSwapLayerBuffersMscOML = http_wglSwapLayerBuffersMscOML;
  tbl.wglWaitForMscOML = http_wglWaitForMscOML;
  tbl.wglWaitForSbcOML = http_wglWaitForSbcOML;

  // WGL_core

  tbl.wglCopyContext = http_wglCopyContext;
  tbl.wglCreateContext = http_wglCreateContext;
  tbl.wglCreateLayerContext = http_wglCreateLayerContext;
  tbl.wglDeleteContext = http_wglDeleteContext;
  tbl.wglDescribeLayerPlane = http_wglDescribeLayerPlane;
  tbl.wglGetCurrentContext = http_wglGetCurrentContext;
  tbl.wglGetCurrentDC = http_wglGetCurrentDC;
  tbl.wglGetDefaultProcAddress = http_wglGetDefaultProcAddress;
  tbl.wglGetLayerPaletteEntries = http_wglGetLayerPaletteEntries;
  tbl.wglGetProcAddress = http_wglGetProcAddress;
  tbl.wglMakeCurrent = http_wglMakeCurrent;
  tbl.wglRealizeLayerPalette = http_wglRealizeLayerPalette;
  tbl.wglSetLayerPaletteEntries = http_wglSetLayerPaletteEntries;
  tbl.wglShareLists = http_wglShareLists;
  tbl.wglSwapLayerBuffers = http_wglSwapLayerBuffers;
  tbl.wglSwapMultipleBuffers = http_wglSwapMultipleBuffers;
  tbl.wglUseFontBitmapsA = http_wglUseFontBitmapsA;
  tbl.wglUseFontBitmapsW = http_wglUseFontBitmapsW;
  tbl.wglUseFontOutlinesA = http_wglUseFontOutlinesA;
  tbl.wglUseFontOutlinesW = http_wglUseFontOutlinesW;
#endif // REGAL_SYS_WGL

#if REGAL_SYS_GLX

  // GLX_VERSION_1_0

  tbl.glXChooseVisual = http_glXChooseVisual;
  tbl.glXCopyContext = http_glXCopyContext;
  tbl.glXCreateContext = http_glXCreateContext;
  tbl.glXCreateGLXPixmap = http_glXCreateGLXPixmap;
  tbl.glXDestroyContext = http_glXDestroyContext;
  tbl.glXDestroyGLXPixmap = http_glXDestroyGLXPixmap;
  tbl.glXGetConfig = http_glXGetConfig;
  tbl.glXGetCurrentContext = http_glXGetCurrentContext;
  tbl.glXGetCurrentDrawable = http_glXGetCurrentDrawable;
  tbl.glXIsDirect = http_glXIsDirect;
  tbl.glXMakeCurrent = http_glXMakeCurrent;
  tbl.glXQueryExtension = http_glXQueryExtension;
  tbl.glXQueryVersion = http_glXQueryVersion;
  tbl.glXSwapBuffers = http_glXSwapBuffers;
  tbl.glXUseXFont = http_glXUseXFont;
  tbl.glXWaitGL = http_glXWaitGL;
  tbl.glXWaitX = http_glXWaitX;

  // GLX_VERSION_1_1

  tbl.glXGetClientString = http_glXGetClientString;
  tbl.glXQueryExtensionsString = http_glXQueryExtensionsString;
  tbl.glXQueryServerString = http_glXQueryServerString;

  // GLX_VERSION_1_2

  tbl.glXGetCurrentDisplay = http_glXGetCurrentDisplay;

  // GLX_VERSION_1_3

  tbl.glXChooseFBConfig = http_glXChooseFBConfig;
  tbl.glXCreateNewContext = http_glXCreateNewContext;
  tbl.glXCreatePbuffer = http_glXCreatePbuffer;
  tbl.glXCreatePixmap = http_glXCreatePixmap;
  tbl.glXCreateWindow = http_glXCreateWindow;
  tbl.glXDestroyPbuffer = http_glXDestroyPbuffer;
  tbl.glXDestroyPixmap = http_glXDestroyPixmap;
  tbl.glXDestroyWindow = http_glXDestroyWindow;
  tbl.glXGetCurrentReadDrawable = http_glXGetCurrentReadDrawable;
  tbl.glXGetFBConfigAttrib = http_glXGetFBConfigAttrib;
  tbl.glXGetFBConfigs = http_glXGetFBConfigs;
  tbl.glXGetSelectedEvent = http_glXGetSelectedEvent;
  tbl.glXGetVisualFromFBConfig = http_glXGetVisualFromFBConfig;
  tbl.glXMakeContextCurrent = http_glXMakeContextCurrent;
  tbl.glXQueryContext = http_glXQueryContext;
  tbl.glXQueryDrawable = http_glXQueryDrawable;
  tbl.glXSelectEvent = http_glXSelectEvent;

  // GLX_VERSION_1_4

  tbl.glXGetProcAddress = http_glXGetProcAddress;

  // GLX_AMD_gpu_association

  tbl.glXBlitContextFramebufferAMD = http_glXBlitContextFramebufferAMD;
  tbl.glXCreateAssociatedContextAMD = http_glXCreateAssociatedContextAMD;
  tbl.glXCreateAssociatedContextAttribsAMD = http_glXCreateAssociatedContextAttribsAMD;
  tbl.glXDeleteAssociatedContextAMD = http_glXDeleteAssociatedContextAMD;
  tbl.glXGetContextGPUIDAMD = http_glXGetContextGPUIDAMD;
  tbl.glXGetCurrentAssociatedContextAMD = http_glXGetCurrentAssociatedContextAMD;
  tbl.glXGetGPUIDsAMD = http_glXGetGPUIDsAMD;
  tbl.glXGetGPUInfoAMD = http_glXGetGPUInfoAMD;
  tbl.glXMakeAssociatedContextCurrentAMD = http_glXMakeAssociatedContextCurrentAMD;

  // GLX_ARB_create_context

  tbl.glXCreateContextAttribsARB = http_glXCreateContextAttribsARB;

  // GLX_ARB_get_proc_address

  tbl.glXGetProcAddressARB = http_glXGetProcAddressARB;

  // GLX_ATI_render_texture

  tbl.glXBindTexImageATI = http_glXBindTexImageATI;
  tbl.glXDrawableAttribATI = http_glXDrawableAttribATI;
  tbl.glXReleaseTexImageATI = http_glXReleaseTexImageATI;

  // GLX_EXT_import_context

  tbl.glXFreeContextEXT = http_glXFreeContextEXT;
  tbl.glXGetContextIDEXT = http_glXGetContextIDEXT;
  tbl.glXImportContextEXT = http_glXImportContextEXT;
  tbl.glXQueryContextInfoEXT = http_glXQueryContextInfoEXT;

  // GLX_EXT_swap_control

  tbl.glXSwapIntervalEXT = http_glXSwapIntervalEXT;

  // GLX_EXT_texture_from_pixmap

  tbl.glXBindTexImageEXT = http_glXBindTexImageEXT;
  tbl.glXReleaseTexImageEXT = http_glXReleaseTexImageEXT;

  // GLX_MESA_agp_offset

  tbl.glXGetAGPOffsetMESA = http_glXGetAGPOffsetMESA;

  // GLX_MESA_copy_sub_buffer

  tbl.glXCopySubBufferMESA = http_glXCopySubBufferMESA;

  // GLX_MESA_pixmap_colormap

  tbl.glXCreateGLXPixmapMESA = http_glXCreateGLXPixmapMESA;

  // GLX_MESA_query_renderer

  tbl.glXQueryCurrentRendererIntegerMESA = http_glXQueryCurrentRendererIntegerMESA;
  tbl.glXQueryCurrentRendererStringMESA = http_glXQueryCurrentRendererStringMESA;
  tbl.glXQueryRendererIntegerMESA = http_glXQueryRendererIntegerMESA;
  tbl.glXQueryRendererStringMESA = http_glXQueryRendererStringMESA;

  // GLX_MESA_release_buffers

  tbl.glXReleaseBuffersMESA = http_glXReleaseBuffersMESA;

  // GLX_MESA_set_3dfx_mode

  tbl.glXSet3DfxModeMESA = http_glXSet3DfxModeMESA;

  // GLX_MESA_swap_control

  tbl.glXGetSwapIntervalMESA = http_glXGetSwapIntervalMESA;
  tbl.glXSwapIntervalMESA = http_glXSwapIntervalMESA;

  // GLX_NV_copy_buffer

  tbl.glXCopyBufferSubDataNV = http_glXCopyBufferSubDataNV;
  tbl.glXNamedCopyBufferSubDataNV = http_glXNamedCopyBufferSubDataNV;

  // GLX_NV_copy_image

  tbl.glXCopyImageSubDataNV = http_glXCopyImageSubDataNV;

  // GLX_NV_delay_before_swap

  tbl.glXDelayBeforeSwapNV = http_glXDelayBeforeSwapNV;

  // GLX_NV_present_video

  tbl.glXBindVideoDeviceNV = http_glXBindVideoDeviceNV;
  tbl.glXEnumerateVideoDevicesNV = http_glXEnumerateVideoDevicesNV;

  // GLX_NV_swap_group

  tbl.glXBindSwapBarrierNV = http_glXBindSwapBarrierNV;
  tbl.glXJoinSwapGroupNV = http_glXJoinSwapGroupNV;
  tbl.glXQueryFrameCountNV = http_glXQueryFrameCountNV;
  tbl.glXQueryMaxSwapGroupsNV = http_glXQueryMaxSwapGroupsNV;
  tbl.glXQuerySwapGroupNV = http_glXQuerySwapGroupNV;
  tbl.glXResetFrameCountNV = http_glXResetFrameCountNV;

  // GLX_NV_vertex_array_range

  tbl.glXAllocateMemoryNV = http_glXAllocateMemoryNV;
  tbl.glXFreeMemoryNV = http_glXFreeMemoryNV;

  // GLX_NV_video_capture

  tbl.glXBindVideoCaptureDeviceNV = http_glXBindVideoCaptureDeviceNV;
  tbl.glXEnumerateVideoCaptureDevicesNV = http_glXEnumerateVideoCaptureDevicesNV;
  tbl.glXLockVideoCaptureDeviceNV = http_glXLockVideoCaptureDeviceNV;
  tbl.glXQueryVideoCaptureDeviceNV = http_glXQueryVideoCaptureDeviceNV;
  tbl.glXReleaseVideoCaptureDeviceNV = http_glXReleaseVideoCaptureDeviceNV;

  // GLX_NV_video_output

  tbl.glXBindVideoImageNV = http_glXBindVideoImageNV;
  tbl.glXGetVideoDeviceNV = http_glXGetVideoDeviceNV;
  tbl.glXGetVideoInfoNV = http_glXGetVideoInfoNV;
  tbl.glXReleaseVideoDeviceNV = http_glXReleaseVideoDeviceNV;
  tbl.glXReleaseVideoImageNV = http_glXReleaseVideoImageNV;
  tbl.glXSendPbufferToVideoNV = http_glXSendPbufferToVideoNV;

  // GLX_OML_sync_control

  tbl.glXGetMscRateOML = http_glXGetMscRateOML;
  tbl.glXGetSyncValuesOML = http_glXGetSyncValuesOML;
  tbl.glXSwapBuffersMscOML = http_glXSwapBuffersMscOML;
  tbl.glXWaitForMscOML = http_glXWaitForMscOML;
  tbl.glXWaitForSbcOML = http_glXWaitForSbcOML;

  // GLX_SGIX_fbconfig

  tbl.glXChooseFBConfigSGIX = http_glXChooseFBConfigSGIX;
  tbl.glXCreateContextWithConfigSGIX = http_glXCreateContextWithConfigSGIX;
  tbl.glXCreateGLXPixmapWithConfigSGIX = http_glXCreateGLXPixmapWithConfigSGIX;
  tbl.glXGetFBConfigAttribSGIX = http_glXGetFBConfigAttribSGIX;
  tbl.glXGetFBConfigFromVisualSGIX = http_glXGetFBConfigFromVisualSGIX;
  tbl.glXGetVisualFromFBConfigSGIX = http_glXGetVisualFromFBConfigSGIX;

  // GLX_SGIX_pbuffer

  tbl.glXCreateGLXPbufferSGIX = http_glXCreateGLXPbufferSGIX;
  tbl.glXDestroyGLXPbufferSGIX = http_glXDestroyGLXPbufferSGIX;
  tbl.glXGetSelectedEventSGIX = http_glXGetSelectedEventSGIX;
  tbl.glXQueryGLXPbufferSGIX = http_glXQueryGLXPbufferSGIX;
  tbl.glXSelectEventSGIX = http_glXSelectEventSGIX;

  // GLX_SGIX_swap_barrier

  tbl.glXBindSwapBarrierSGIX = http_glXBindSwapBarrierSGIX;
  tbl.glXQueryMaxSwapBarriersSGIX = http_glXQueryMaxSwapBarriersSGIX;

  // GLX_SGIX_swap_group

  tbl.glXJoinSwapGroupSGIX = http_glXJoinSwapGroupSGIX;

  // GLX_SGIX_video_resize

  tbl.glXBindChannelToWindowSGIX = http_glXBindChannelToWindowSGIX;
  tbl.glXChannelRectSGIX = http_glXChannelRectSGIX;
  tbl.glXChannelRectSyncSGIX = http_glXChannelRectSyncSGIX;
  tbl.glXQueryChannelDeltasSGIX = http_glXQueryChannelDeltasSGIX;
  tbl.glXQueryChannelRectSGIX = http_glXQueryChannelRectSGIX;

  // GLX_SGI_cushion

  tbl.glXCushionSGI = http_glXCushionSGI;

  // GLX_SGI_make_current_read

  tbl.glXGetCurrentReadDrawableSGI = http_glXGetCurrentReadDrawableSGI;
  tbl.glXMakeCurrentReadSGI = http_glXMakeCurrentReadSGI;

  // GLX_SGI_swap_control

  tbl.glXSwapIntervalSGI = http_glXSwapIntervalSGI;

  // GLX_SGI_video_sync

  tbl.glXGetVideoSyncSGI = http_glXGetVideoSyncSGI;
  tbl.glXWaitVideoSyncSGI = http_glXWaitVideoSyncSGI;

  // GLX_SUN_get_transparent_index

  tbl.glXGetTransparentIndexSUN = http_glXGetTransparentIndexSUN;

  // GLX_SUN_video_resize

  tbl.glXGetVideoResizeSUN = http_glXGetVideoResizeSUN;
  tbl.glXVideoResizeSUN = http_glXVideoResizeSUN;
#endif // REGAL_SYS_GLX

#if REGAL_SYS_OSX

  // CGL_VERSION_1_0

  tbl.CGLChoosePixelFormat = http_CGLChoosePixelFormat;
  tbl.CGLClearDrawable = http_CGLClearDrawable;
  tbl.CGLCopyContext = http_CGLCopyContext;
  tbl.CGLCreateContext = http_CGLCreateContext;
  tbl.CGLDescribePixelFormat = http_CGLDescribePixelFormat;
  tbl.CGLDescribeRenderer = http_CGLDescribeRenderer;
  tbl.CGLDestroyContext = http_CGLDestroyContext;
  tbl.CGLDestroyPixelFormat = http_CGLDestroyPixelFormat;
  tbl.CGLDestroyRendererInfo = http_CGLDestroyRendererInfo;
  tbl.CGLDisable = http_CGLDisable;
  tbl.CGLEnable = http_CGLEnable;
  tbl.CGLErrorString = http_CGLErrorString;
  tbl.CGLFlushDrawable = http_CGLFlushDrawable;
  tbl.CGLGetOffScreen = http_CGLGetOffScreen;
  tbl.CGLGetOption = http_CGLGetOption;
  tbl.CGLGetParameter = http_CGLGetParameter;
  tbl.CGLGetVersion = http_CGLGetVersion;
  tbl.CGLGetVirtualScreen = http_CGLGetVirtualScreen;
  tbl.CGLIsEnabled = http_CGLIsEnabled;
  tbl.CGLQueryRendererInfo = http_CGLQueryRendererInfo;
  tbl.CGLSetFullScreen = http_CGLSetFullScreen;
  tbl.CGLSetOffScreen = http_CGLSetOffScreen;
  tbl.CGLSetOption = http_CGLSetOption;
  tbl.CGLSetParameter = http_CGLSetParameter;
  tbl.CGLSetVirtualScreen = http_CGLSetVirtualScreen;

  // CGL_VERSION_1_1

  tbl.CGLCreatePBuffer = http_CGLCreatePBuffer;
  tbl.CGLDescribePBuffer = http_CGLDescribePBuffer;
  tbl.CGLDestroyPBuffer = http_CGLDestroyPBuffer;
  tbl.CGLGetPBuffer = http_CGLGetPBuffer;
  tbl.CGLSetPBuffer = http_CGLSetPBuffer;
  tbl.CGLTexImagePBuffer = http_CGLTexImagePBuffer;

  // CGL_VERSION_1_2

  tbl.CGLGetContextRetainCount = http_CGLGetContextRetainCount;
  tbl.CGLGetGlobalOption = http_CGLGetGlobalOption;
  tbl.CGLGetPBufferRetainCount = http_CGLGetPBufferRetainCount;
  tbl.CGLGetPixelFormat = http_CGLGetPixelFormat;
  tbl.CGLGetPixelFormatRetainCount = http_CGLGetPixelFormatRetainCount;
  tbl.CGLLockContext = http_CGLLockContext;
  tbl.CGLReleaseContext = http_CGLReleaseContext;
  tbl.CGLReleasePBuffer = http_CGLReleasePBuffer;
  tbl.CGLReleasePixelFormat = http_CGLReleasePixelFormat;
  tbl.CGLRetainContext = http_CGLRetainContext;
  tbl.CGLRetainPBuffer = http_CGLRetainPBuffer;
  tbl.CGLRetainPixelFormat = http_CGLRetainPixelFormat;
  tbl.CGLSetGlobalOption = http_CGLSetGlobalOption;
  tbl.CGLUnlockContext = http_CGLUnlockContext;

  // CGL_VERSION_1_3

  tbl.CGLGetCurrentContext = http_CGLGetCurrentContext;
  tbl.CGLGetShareGroup = http_CGLGetShareGroup;
  tbl.CGLGetSurface = http_CGLGetSurface;
  tbl.CGLSetCurrentContext = http_CGLSetCurrentContext;
  tbl.CGLSetSurface = http_CGLSetSurface;
  tbl.CGLTexImageIOSurface2D = http_CGLTexImageIOSurface2D;
  tbl.CGLUpdateContext = http_CGLUpdateContext;
#endif // REGAL_SYS_OSX

#if REGAL_SYS_EGL

  // EGL_ANGLE_query_surface_pointer

  tbl.eglQuerySurfacePointerANGLE = http_eglQuerySurfacePointerANGLE;

  // EGL_KHR_fence_sync

  tbl.eglClientWaitSyncKHR = http_eglClientWaitSyncKHR;
  tbl.eglCreateSyncKHR = http_eglCreateSyncKHR;
  tbl.eglDestroySyncKHR = http_eglDestroySyncKHR;
  tbl.eglGetSyncAttribKHR = http_eglGetSyncAttribKHR;

  // EGL_KHR_image_base

  tbl.eglCreateImageKHR = http_eglCreateImageKHR;
  tbl.eglDestroyImageKHR = http_eglDestroyImageKHR;

  // EGL_KHR_lock_surface

  tbl.eglLockSurfaceKHR = http_eglLockSurfaceKHR;
  tbl.eglUnlockSurfaceKHR = http_eglUnlockSurfaceKHR;

  // EGL_KHR_stream_consumer_gltexture

  tbl.eglStreamConsumerAcquireKHR = http_eglStreamConsumerAcquireKHR;
  tbl.eglStreamConsumerGLTextureExternalKHR = http_eglStreamConsumerGLTextureExternalKHR;
  tbl.eglStreamConsumerReleaseKHR = http_eglStreamConsumerReleaseKHR;

  // EGL_KHR_stream_cross_process_fd

  tbl.eglCreateStreamFromFileDescriptorKHR = http_eglCreateStreamFromFileDescriptorKHR;
  tbl.eglGetStreamFileDescriptorKHR = http_eglGetStreamFileDescriptorKHR;

  // EGL_KHR_stream_producer_eglsurface

  tbl.eglCreateStreamProducerSurfaceKHR = http_eglCreateStreamProducerSurfaceKHR;

  // EGL_KHR_wait_sync

  tbl.eglWaitSyncKHR = http_eglWaitSyncKHR;

  // EGL_MESA_drm_image

  tbl.eglCreateDRMImageMESA = http_eglCreateDRMImageMESA;
  tbl.eglExportDRMImageMESA = http_eglExportDRMImageMESA;

  // EGL_NV_coverage_sample

  tbl.eglCoverageMaskNV = http_eglCoverageMaskNV;
  tbl.eglCoverageOperationNV = http_eglCoverageOperationNV;

  // EGL_NV_post_sub_buffer

  tbl.eglPostSubBufferNV = http_eglPostSubBufferNV;

  // EGL_NV_sync

  tbl.eglClientWaitSyncNV = http_eglClientWaitSyncNV;
  tbl.eglCreateFenceSyncNV = http_eglCreateFenceSyncNV;
  tbl.eglDestroySyncNV = http_eglDestroySyncNV;
  tbl.eglFenceNV = http_eglFenceNV;
  tbl.eglGetSyncAttribNV = http_eglGetSyncAttribNV;
  tbl.eglSignalSyncNV = http_eglSignalSyncNV;

  // EGL_NV_system_time

  tbl.eglGetSystemTimeFrequencyNV = http_eglGetSystemTimeFrequencyNV;
  tbl.eglGetSystemTimeNV = http_eglGetSystemTimeNV;

  // EGL_VERSION_1_0

  tbl.eglChooseConfig = http_eglChooseConfig;
  tbl.eglCopyBuffers = http_eglCopyBuffers;
  tbl.eglCreateContext = http_eglCreateContext;
  tbl.eglCreatePbufferSurface = http_eglCreatePbufferSurface;
  tbl.eglCreatePixmapSurface = http_eglCreatePixmapSurface;
  tbl.eglCreateWindowSurface = http_eglCreateWindowSurface;
  tbl.eglDestroyContext = http_eglDestroyContext;
  tbl.eglDestroySurface = http_eglDestroySurface;
  tbl.eglGetConfigAttrib = http_eglGetConfigAttrib;
  tbl.eglGetConfigs = http_eglGetConfigs;
  tbl.eglGetCurrentContext = http_eglGetCurrentContext;
  tbl.eglGetCurrentDisplay = http_eglGetCurrentDisplay;
  tbl.eglGetCurrentSurface = http_eglGetCurrentSurface;
  tbl.eglGetDisplay = http_eglGetDisplay;
  tbl.eglGetError = http_eglGetError;
  tbl.eglGetProcAddress = http_eglGetProcAddress;
  tbl.eglInitialize = http_eglInitialize;
  tbl.eglMakeCurrent = http_eglMakeCurrent;
  tbl.eglQueryContext = http_eglQueryContext;
  tbl.eglQueryString = http_eglQueryString;
  tbl.eglQuerySurface = http_eglQuerySurface;
  tbl.eglSwapBuffers = http_eglSwapBuffers;
  tbl.eglTerminate = http_eglTerminate;
  tbl.eglWaitGL = http_eglWaitGL;
  tbl.eglWaitNative = http_eglWaitNative;

  // EGL_VERSION_1_1

  tbl.eglBindTexImage = http_eglBindTexImage;
  tbl.eglReleaseTexImage = http_eglReleaseTexImage;

  // EGL_VERSION_1_2

  tbl.eglBindAPI = http_eglBindAPI;
  tbl.eglCreatePbufferFromClientBuffer = http_eglCreatePbufferFromClientBuffer;
  tbl.eglQueryAPI = http_eglQueryAPI;
  tbl.eglReleaseThread = http_eglReleaseThread;
  tbl.eglSurfaceAttrib = http_eglSurfaceAttrib;
  tbl.eglSwapInterval = http_eglSwapInterval;
  tbl.eglWaitClient = http_eglWaitClient;
#endif // REGAL_SYS_EGL

}

REGAL_NAMESPACE_END

#endif
