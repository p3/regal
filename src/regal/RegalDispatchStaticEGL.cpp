/* NOTE: Do not edit this file, it is generated by a script:
   Export.py --api gl 4.2 --api wgl 4.0 --api glx 4.0 --api cgl 1.4 --api egl 1.0 --outdir src/regal
*/

/*
  Copyright (c) 2011 NVIDIA Corporation
  Copyright (c) 2011-2012 Cass Everitt
  Copyright (c) 2012 Scott Nations
  Copyright (c) 2012 Mathias Schott
  Copyright (c) 2012 Nigel Stewart
  All rights reserved.

  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:

    Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

    Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
  OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
  Intended formatting conventions:
  $ astyle --style=allman --indent=spaces=2 --indent-switches
*/

#include "pch.h" /* For MS precompiled header support */

#include "RegalUtil.h"

#if REGAL_SYS_EGL && REGAL_DRIVER && REGAL_STATIC_EGL

REGAL_GLOBAL_BEGIN

#include <string>
using namespace std;

#include "RegalDispatch.h"

#ifndef REGAL_NAMESPACE
#error REGAL_STATIC_EGL requires REGAL_NAMESPACE
#endif

#undef eglChooseConfig
#undef eglCopyBuffers
#undef eglCreateContext
#undef eglCreatePbufferSurface
#undef eglCreatePixmapSurface
#undef eglCreateWindowSurface
#undef eglDestroyContext
#undef eglDestroySurface
#undef eglGetConfigAttrib
#undef eglGetConfigs
#undef eglGetCurrentContext
#undef eglGetCurrentDisplay
#undef eglGetCurrentSurface
#undef eglGetDisplay
#undef eglGetError
#undef eglGetProcAddress
#undef eglInitialize
#undef eglMakeCurrent
#undef eglQueryContext
#undef eglQueryString
#undef eglQuerySurface
#undef eglSwapBuffers
#undef eglTerminate
#undef eglWaitGL
#undef eglWaitNative
#undef eglBindTexImage
#undef eglReleaseTexImage
#undef eglBindAPI
#undef eglCreatePbufferFromClientBuffer
#undef eglQueryAPI
#undef eglReleaseThread
#undef eglSurfaceAttrib
#undef eglSwapInterval
#undef eglWaitClient

extern "C"
{
  extern EGLBoolean  REGAL_CALL eglChooseConfig(EGLDisplay dpy, const EGLint *attrib_list, EGLConfig *configs, EGLint config_size, EGLint *num_config);
  extern EGLBoolean  REGAL_CALL eglCopyBuffers(EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target);
  extern EGLContext  REGAL_CALL eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint *attrib_list);
  extern EGLSurface  REGAL_CALL eglCreatePbufferSurface(EGLDisplay dpy, EGLConfig config, const EGLint *attrib_list);
  extern EGLSurface  REGAL_CALL eglCreatePixmapSurface(EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint *attrib_list);
  extern EGLSurface  REGAL_CALL eglCreateWindowSurface(EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint *attrib_list);
  extern EGLBoolean  REGAL_CALL eglDestroyContext(EGLDisplay dpy, EGLContext ctx);
  extern EGLBoolean  REGAL_CALL eglDestroySurface(EGLDisplay dpy, EGLSurface surface);
  extern EGLBoolean  REGAL_CALL eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint *value);
  extern EGLBoolean  REGAL_CALL eglGetConfigs(EGLDisplay dpy, EGLConfig *configs, EGLint config_size, EGLint *num_config);
  extern EGLContext  REGAL_CALL eglGetCurrentContext(void);
  extern EGLDisplay  REGAL_CALL eglGetCurrentDisplay(void);
  extern EGLSurface  REGAL_CALL eglGetCurrentSurface(EGLint readdraw);
  extern EGLDisplay  REGAL_CALL eglGetDisplay(EGLNativeDisplayType display_id);
  extern EGLint  REGAL_CALL eglGetError(void);
  extern __eglMustCastToProperFunctionPointerType  REGAL_CALL eglGetProcAddress(const char *procname);
  extern EGLBoolean  REGAL_CALL eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor);
  extern EGLBoolean  REGAL_CALL eglMakeCurrent(EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx);
  extern EGLBoolean  REGAL_CALL eglQueryContext(EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint *value);
  extern const char * REGAL_CALL eglQueryString(EGLDisplay dpy, EGLint name);
  extern EGLBoolean  REGAL_CALL eglQuerySurface(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint *value);
  extern EGLBoolean  REGAL_CALL eglSwapBuffers(EGLDisplay dpy, EGLSurface surface);
  extern EGLBoolean  REGAL_CALL eglTerminate(EGLDisplay dpy);
  extern EGLBoolean  REGAL_CALL eglWaitGL(void);
  extern EGLBoolean  REGAL_CALL eglWaitNative(EGLint engine);
  extern EGLBoolean  REGAL_CALL eglBindTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer);
  extern EGLBoolean  REGAL_CALL eglReleaseTexImage(EGLDisplay dpy, EGLSurface surface, EGLint buffer);
  extern EGLBoolean  REGAL_CALL eglBindAPI(EGLenum api);
  extern EGLSurface  REGAL_CALL eglCreatePbufferFromClientBuffer(EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint *attrib_list);
  extern EGLenum  REGAL_CALL eglQueryAPI(void);
  extern EGLBoolean  REGAL_CALL eglReleaseThread(void);
  extern EGLBoolean  REGAL_CALL eglSurfaceAttrib(EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value);
  extern EGLBoolean  REGAL_CALL eglSwapInterval(EGLDisplay dpy, EGLint interval);
  extern EGLBoolean  REGAL_CALL eglWaitClient(void);
}

REGAL_GLOBAL_END

REGAL_NAMESPACE_BEGIN

void InitDispatchTableStaticEGL(DispatchTableGlobal &tbl)
{
  // EGL global dispatch
  tbl.reglChooseConfig = ::eglChooseConfig;
  tbl.reglCopyBuffers = ::eglCopyBuffers;
  tbl.reglCreateContext = ::eglCreateContext;
  tbl.reglCreatePbufferSurface = ::eglCreatePbufferSurface;
  tbl.reglCreatePixmapSurface = ::eglCreatePixmapSurface;
  tbl.reglCreateWindowSurface = ::eglCreateWindowSurface;
  tbl.reglDestroyContext = ::eglDestroyContext;
  tbl.reglDestroySurface = ::eglDestroySurface;
  tbl.reglGetConfigAttrib = ::eglGetConfigAttrib;
  tbl.reglGetConfigs = ::eglGetConfigs;
  tbl.reglGetCurrentContext = ::eglGetCurrentContext;
  tbl.reglGetCurrentDisplay = ::eglGetCurrentDisplay;
  tbl.reglGetCurrentSurface = ::eglGetCurrentSurface;
  tbl.reglGetDisplay = ::eglGetDisplay;
  tbl.reglGetError = ::eglGetError;
  tbl.reglGetProcAddress = ::eglGetProcAddress;
  tbl.reglInitialize = ::eglInitialize;
  tbl.reglMakeCurrent = ::eglMakeCurrent;
  tbl.reglQueryContext = ::eglQueryContext;
  tbl.reglQueryString = ::eglQueryString;
  tbl.reglQuerySurface = ::eglQuerySurface;
  tbl.reglSwapBuffers = ::eglSwapBuffers;
  tbl.reglTerminate = ::eglTerminate;
  tbl.reglWaitGL = ::eglWaitGL;
  tbl.reglWaitNative = ::eglWaitNative;
  tbl.reglBindTexImage = ::eglBindTexImage;
  tbl.reglReleaseTexImage = ::eglReleaseTexImage;
  tbl.reglBindAPI = ::eglBindAPI;
  tbl.reglCreatePbufferFromClientBuffer = ::eglCreatePbufferFromClientBuffer;
  tbl.reglQueryAPI = ::eglQueryAPI;
  tbl.reglReleaseThread = ::eglReleaseThread;
  tbl.reglSurfaceAttrib = ::eglSurfaceAttrib;
  tbl.reglSwapInterval = ::eglSwapInterval;
  tbl.reglWaitClient = ::eglWaitClient;

}

REGAL_NAMESPACE_END

#endif
